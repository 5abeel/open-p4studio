################################################################################
 #  Copyright (C) 2024 Intel Corporation
 #
 #  Licensed under the Apache License, Version 2.0 (the "License");
 #  you may not use this file except in compliance with the License.
 #  You may obtain a copy of the License at
 #
 #  http://www.apache.org/licenses/LICENSE-2.0
 #
 #  Unless required by applicable law or agreed to in writing,
 #  software distributed under the License is distributed on an "AS IS" BASIS,
 #  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 #  See the License for the specific language governing permissions
 #  and limitations under the License.
 #
 #
 #  SPDX-License-Identifier: Apache-2.0
################################################################################

#!/usr/bin/python

"""
  Cloudbreak_Interrupt_List_{date/version}.csv file is generated by HW group.

  This python script takes a spreadsheet in CSV format (with certain
  known column headers) and outputs a C-language structure initialized
  with the values from the .csv file.

  The (current) structure output follows a typedef defined in lld/lld_tof3_interrupt.c

  typedef struct lld_blk_lvl_int_s {
    uint32_t status_reg;
    uint32_t enable_hi_reg;
    uint32_t enable_lo_reg;
    uint32_t status_inject_reg;
    uint32_t shadow_mask;
    lld_int_cb cb_fn[BF_MAX_DEV_COUNT];
    void *userdata[BF_MAX_DEV_COUNT];
    uint32_t count[BF_MAX_DEV_COUNT][LLD_TOF3_COUNT_NUMB];
    uint32_t count_shown[BF_MAX_DEV_COUNT][LLD_TOF3_COUNT_NUMB];
  } lld_tof3_blk_lvl_int_t;

  typedef struct lld_tof3_blk_lvl_int_list_s {
    uint32_t reg_top;
    uint32_t mask;//mask of the input value if reg_top is -1, otherwise mask for reg_top
    bool is_leaf;
    union next_lvl_p{
      lld_tof3_blk_lvl_int_t *blk_lvl_int;
      struct lld_tof3_blk_lvl_int_list_s *blk_lvl_list;
    } u;
    uint32_t n;
  } lld_tof3_blk_lvl_int_list_t;

  To run:
    python ./lld_tof3_int_generate.py
"""

import csv
import sys
import os
import datetime

import os.path
import hashlib
import copy
import re

from operator import mul
from types import StringTypes

def finish_list1_struct(f_list1):
    global label_handling
    global name_pipe
    if label_handling[0] == 1:
        #finish list1
        if name_pipe == "":
            f_list1.write("};\n\n")
        else:
            f_list1.write("};\\\n")
        label_handling[0] = 0

def finish_list2_struct(f_list2):
    global label_handling
    global name_pipe
    global no_list2
    if label_handling[1] == 1:
        #finish list2
        if name_pipe == "":
            f_list2.write("};\n\n")
        else:
            f_list2.write("};\\\n")
        no_list2 += 1
        label_handling[1] = 0

def finish_node_struct(f_node):
    global label_handling
    global name_pipe
    global no_node
    if label_handling[2] == 1:
        #finish node
        if name_pipe == "":
            f_node.write("};\n\n")
        else:
            f_node.write("};\\\n")
        no_node += 1
        label_handling[2] = 0

def finish_all_structs(f_list1, f_list2, f_node):
    global no_node
    global no_list2
    finish_list1_struct(f_list1)
    finish_list2_struct(f_list2)
    finish_node_struct(f_node)
    no_node = 0
    no_list2 = 0

def get_mask(mask_str):
    digi = re.findall(r'\d+', mask_str)
    if len(digi) == 1:
        return(0x1 << int(digi[0]))
    elif len(digi) == 2:
        result = 0
        if re.match('\:', mask_str):
            for i in range(int(digi[1]), int(digi[0])):
                result = int(int(result) | int(int(0x1) << int(i)))
        else:
            result = int(int(int(0x1) << int(digi[0])) | int(int(0x1) << int(digi[1])))
    return(result)

def add_entry_list1(row, f_list1):
    global label_handling
    global name_pipe
    global name_top
    global name_station
    global no_node
    global no_list2
    global tree1_tmp
    if label_handling[0] == 0:
        #add a new struct
        if name_pipe == "":
            f_list1.write("lld_tof3_blk_lvl_int_list_t %s_%s_sh_ints[] = {\n" % (name_top, name_station))
        else:
            if re.match('^MAU', name_station):
                f_list1.write("lld_tof3_blk_lvl_int_list_t %s_%s##pp##_%s##mm##_sh_ints[] = {\\\n" % (name_top, name_pipe, name_station))
            else:#PRSR DPRSR
                f_list1.write("lld_tof3_blk_lvl_int_list_t %s_%s##pp##_%s_sh_ints[] = {\\\n" % (name_top, name_pipe, name_station))
        label_handling[0] = 1
    #add an entry
    if name_pipe == "":
        if row["Tree1"] != "":
            tree1_tmp = str(row["Tree1"])
        f_list1.write("  {offsetof(tof3_reg, %s),\n" % (tree1_tmp))
        mask = get_mask(str(row["Mask1"]))
        f_list1.write("   %s,\n" % hex(mask))
        if row["Mask2"] == "": #directly connect to leaf
            f_list1.write("   true,\n")
            f_list1.write("   .u.blk_lvl_int = %s_%s_%d_blk_lvl_int,\n" % (name_top, name_station, no_node))
            f_list1.write("   STRUCT_LEN(%s_%s_%d_blk_lvl_int)},\n" % (name_top, name_station, no_node))
        else:
            f_list1.write("   false,\n")
            f_list1.write("   .u.blk_lvl_list = %s_%s_%d_blk_lvl_list,\n" % (name_top, name_station, no_list2))
            f_list1.write("   STRUCT_LEN(%s_%s_%d_blk_lvl_list)},\n" % (name_top, name_station, no_list2))
    else:
        if row["Tree1"] != "":
            tree1_tmp = str(row["Tree1"])
            tree1_tmp = tree1_tmp.replace("pipes", "pipes[pp]")
            tree1_tmp = tree1_tmp.replace(".mau.", ".mau[mm].")
        f_list1.write("  {offsetof(tof3_reg, %s),\\\n" % (tree1_tmp))
        mask = get_mask(str(row["Mask1"]))
        f_list1.write("   %s,\\\n" % hex(mask))
        if row["Mask2"] == "": #directly connect to leaf
            f_list1.write("   true,\\\n")
            if re.match('^MAU', name_station):
                f_list1.write("   .u.blk_lvl_int = %s_%s##pp##_%s##mm##_%d_blk_lvl_int,\\\n" % (name_top, name_pipe, name_station, no_node))
                f_list1.write("   STRUCT_LEN(%s_%s##pp##_%s##mm##_%d_blk_lvl_int)},\\\n" % (name_top, name_pipe, name_station, no_node))
            else:
                f_list1.write("   .u.blk_lvl_int = %s_%s##pp##_%s_%d_blk_lvl_int,\\\n" % (name_top, name_pipe, name_station, no_node))
                f_list1.write("   STRUCT_LEN(%s_%s##pp##_%s_%d_blk_lvl_int)},\\\n" % (name_top, name_pipe, name_station, no_node))
        else:
            f_list1.write("   false,\\\n")
            if re.match('^MAU', name_station):
                f_list1.write("   .u.blk_lvl_list = %s_%s##pp##_%s##mm##_%d_blk_lvl_list,\\\n" % (name_top, name_pipe, name_station, no_list2))
                f_list1.write("   STRUCT_LEN(%s_%s##pp##_%s##mm##_%d_blk_lvl_list)},\\\n" % (name_top, name_pipe, name_station, no_list2))
            else:
                f_list1.write("   .u.blk_lvl_list = %s_%s##pp##_%s_%d_blk_lvl_list,\\\n" % (name_top, name_pipe, name_station, no_list2))
                f_list1.write("   STRUCT_LEN(%s_%s##pp##_%s_%d_blk_lvl_list)},\\\n" % (name_top, name_pipe, name_station, no_list2))

def add_entry_list2(row, f_list2):
    global label_handling
    global name_pipe
    global name_top
    global name_station
    global no_list2
    global no_node
    global tree2_tmp
    if label_handling[1] == 0:
        #add a new struct
        if name_pipe == "":
            f_list2.write("lld_tof3_blk_lvl_int_list_t %s_%s_%d_blk_lvl_list[] = {\n" % (name_top, name_station, no_list2))
        else:
            if re.match('^MAU', name_station):
                f_list2.write("lld_tof3_blk_lvl_int_list_t %s_%s##pp##_%s##mm##_%d_blk_lvl_list[] = {\\\n" % (name_top, name_pipe, name_station, no_list2))
            else:#PRSR DPRSR
                f_list2.write("lld_tof3_blk_lvl_int_list_t %s_%s##pp##_%s_%d_blk_lvl_list[] = {\\\n" % (name_top, name_pipe, name_station, no_list2))
        label_handling[1] = 1
    #add an entry
    if name_pipe == "":
        if row["Tree2"] != "":
            tree2_tmp = str(row["Tree2"])
        f_list2.write("  {offsetof(tof3_reg, %s),\n" % (tree2_tmp))
        mask = get_mask(str(row["Mask2"]))
        f_list2.write("   %s,\n" % hex(mask))
        f_list2.write("   true,\n")
        f_list2.write("   .u.blk_lvl_int = %s_%s_%d_blk_lvl_int,\n" % (name_top, name_station, no_node))
        f_list2.write("   STRUCT_LEN(%s_%s_%d_blk_lvl_int)},\n" % (name_top, name_station, no_node))
    else:
        if row["Tree2"] != "":
            tree2_tmp = str(row["Tree2"])
            tree2_tmp = tree2_tmp.replace("pipes", "pipes[pp]")
            tree2_tmp = tree2_tmp.replace(".mau.", ".mau[mm].")
        f_list2.write("  {offsetof(tof3_reg, %s),\\\n" % (tree2_tmp))
        mask = get_mask(str(row["Mask2"]))
        f_list2.write("   %s,\\\n" % hex(mask))
        f_list2.write("   true,\\\n")
        if re.match('^MAU', name_station):
            f_list2.write("   .u.blk_lvl_int = %s_%s##pp##_%s##mm##_%d_blk_lvl_int,\\\n" % (name_top, name_pipe, name_station, no_node))
            f_list2.write("   STRUCT_LEN(%s_%s##pp##_%s##mm##_%d_blk_lvl_int)},\\\n" % (name_top, name_pipe, name_station, no_node))
        else:
            f_list2.write("   .u.blk_lvl_int = %s_%s##pp##_%s_%d_blk_lvl_int,\\\n" % (name_top, name_pipe, name_station, no_node))
            f_list2.write("   STRUCT_LEN(%s_%s##pp##_%s_%d_blk_lvl_int)},\\\n" % (name_top, name_pipe, name_station, no_node))

def add_entry_node(row, f_node):
    global label_handling
    global name_pipe
    global name_top
    global name_station
    global no_node
    if label_handling[2] == 0:
        #add a new struct
        if name_pipe == "":
            f_node.write("lld_tof3_blk_lvl_int_t %s_%s_%d_blk_lvl_int[] = {\n" % (name_top, name_station, no_node))
        else:
            if re.match('^MAU', name_station):
                f_node.write("lld_tof3_blk_lvl_int_t %s_%s##pp##_%s##mm##_%d_blk_lvl_int[] = {\\\n" % (name_top, name_pipe, name_station, no_node))
            else:
                f_node.write("lld_tof3_blk_lvl_int_t %s_%s##pp##_%s_%d_blk_lvl_int[] = {\\\n" % (name_top, name_pipe, name_station, no_node))
        label_handling[2] = 1
    #add an entry
    if name_pipe == "":
        if re.match('reserved', str(row["Status"])):
            print("skip reserved keyword")
            return
        f_node.write("  {offsetof(tof3_reg, %s),\n" % str(row["Status"]))
        if row["Enable0"] != "":
            f_node.write("   offsetof(tof3_reg, %s),\n" % str(row["Enable0"]))
        else:
            f_node.write("   -1,\n")
        if row["Enable1"] != "":
            f_node.write("   offsetof(tof3_reg, %s),\n" % str(row["Enable1"]))
        else:
            f_node.write("   -1,\n")
        if row["Status Injection"] != "":
            f_node.write("   offsetof(tof3_reg, %s),\n" % str(row["Status Injection"]))
        else:
            f_node.write("   -1,\n")
        #if row["Error Injection"] != "":
        #    f_node.write("   offsetof(tof3_reg, %s),\n" % str(row["Error Injection"]))
        #else:
        #    f_node.write("   -1,\n")
        f_node.write("   0xffffffff,\n")
        f_node.write("   {0},\n")
        f_node.write("   {0},\n")
        f_node.write("   {{0}},\n")
        f_node.write("   {{0}}},\n")
    else:
        temp = str(row["Status"])
        temp = temp.replace("pipes", "pipes[pp]")
        temp = temp.replace(".mau.", ".mau[mm].")
        f_node.write("  {offsetof(tof3_reg, %s),\\\n" % temp)
        if row["Enable0"] != "":
            temp = str(row["Enable0"])
            temp = temp.replace("pipes", "pipes[pp]")
            temp = temp.replace(".mau.", ".mau[mm].")
            f_node.write("   offsetof(tof3_reg, %s),\\\n" % temp)
        else:
            f_node.write("   -1,\\\n")
        if row["Enable1"] != "":
            temp = str(row["Enable1"])
            temp = temp.replace("pipes", "pipes[pp]")
            temp = temp.replace(".mau.", ".mau[mm].")
            f_node.write("   offsetof(tof3_reg, %s),\\\n" % temp)
        else:
            f_node.write("   -1,\\\n")
        if row["Status Injection"] != "":
            temp = str(row["Status Injection"])
            temp = temp.replace("pipes", "pipes[pp]")
            temp = temp.replace(".mau.", ".mau[mm].")
            f_node.write("   offsetof(tof3_reg, %s),\\\n" % temp)
        else:
            f_node.write("   -1,\\\n")
        #if row["Error Injection"] != "":
        #    temp = str(row["Error Injection"])
        #    temp = temp.replace("pipes", "pipes[pp]")
        #    temp = temp.replace(".mau.", ".mau[mm].")
        #    f_node.write("   offsetof(tof3_reg, %s),\\\n" % temp)
        #else:
        #    f_node.write("   -1,\\\n")
        f_node.write("   0xffffffff,\\\n")
        f_node.write("   {0},\\\n")
        f_node.write("   {0},\\\n")
        f_node.write("   {{0}},\\\n")
        f_node.write("   {{0}}},\\\n")


def csv_parse_int_list(f_list1, f_list2, f_node):
    global no_node
    global no_list2
    global label_handling
    global name_top
    global name_pipe
    global name_station
    global tree1_tmp
    global tree2_tmp
    name_top = ""
    name_pipe = ""
    name_station = ""
    label_handling = [0, 0, 0] #list1,list2,node. 1 means current row belongs to last list.
    no_node = 0 #No. of node struct under current block
    no_list2 = 0 #No. of list2 struct under current block
    tree1_tmp = ""
    tree2_tmp = ""
    with open("Cloudbreak_Interrupt_List_20200625.csv", 'r') as csv_file:
        csv_reader = csv.DictReader(csv_file)
        for row in csv_reader:
            if (row["Top"] != ""):
                if (re.match('^[^0-9]', row["Top"])):
                    finish_all_structs(f_list1, f_list2, f_node)
                    name_top = str(row["Top"])
                    name_pipe = ""
                    name_station = ""
                #elif not(re.match('\:', row["Top"])): #special blocks
                #    if not(re.match('PRSR$', row["STATION"])) and not(re.match('PRSR$', name_station)): #special blocks
                #        continue
                elif (name_station == "PBC") and (row["STATION"] == ""): #special blocks, finish last node
                     finish_node_struct(f_node)
            if row["PIPE"] != "":
                finish_all_structs(f_list1, f_list2, f_node)
                name_station = ""
                name_pipe = ""
                if re.match('pipe0', row["PIPE"]):
                    name_pipe = "pipe"
                elif re.match('pipe[1-3]', row["PIPE"]):
                    continue
            if row["STATION"] != "":
                finish_all_structs(f_list1, f_list2, f_node)
                name_station = ""
                if re.match('MAU0', row["STATION"]):
                    #define macro
                    name_station = "MAU"
                    f_list1.write("\n#define PIPE_MAU_BLK_SH_INTS(pp,mm)\\\n")
                    f_list2.write("\n#define PIPE_MAU_BLK_INT_LIST(pp,mm)\\\n")
                    f_node.write("\n#define PIPE_MAU_BLK_INT(pp,mm)\\\n")
                elif re.match('PRSR', row["STATION"]):
                    name_station = "PRSR"
                    f_list1.write("\n#define PIPE_PRSR_BLK_SH_INTS(pp)\\\n")
                    f_list2.write("\n#define PIPE_PRSR_BLK_INT_LIST(pp)\\\n")
                    f_node.write("\n#define PIPE_PRSR_BLK_INT(pp)\\\n")
                elif re.match('DPRSR', row["STATION"]):
                    name_station = "DPRSR"
                    f_list1.write("\n#define PIPE_DPRSR_BLK_SH_INTS(pp)\\\n")
                    f_list2.write("\n#define PIPE_DPRSR_BLK_INT_LIST(pp)\\\n")
                    f_node.write("\n#define PIPE_DPRSR_BLK_INT(pp)\\\n")
                elif re.match('PBC', row["STATION"]):
                    f_node.write("\n") #special case, needs one more line
                    name_station = str(row["STATION"])
                elif re.match('Reserved', row["STATION"]):
                    continue
                elif re.match('MAU[1-9]|MAU[0-9]{2}', row["STATION"]):
                    continue
                else:
                    name_station = str(row["STATION"])
            #else:
                #if re.match("PRSR|DPRSR", name_station) and row["Tree1"] != "":
                #    finish_list1_struct(f_list1)
                #    finish_list2_struct(f_list2)
                #    finish_node_struct(f_node)
            if row["Status"] != "":
                #otherwise, next row
                if row["Mask1"] != "":
                    finish_list2_struct(f_list2)
                    finish_node_struct(f_node)
                    add_entry_list1(row, f_list1)
                if row["Mask2"] != "":
                    finish_node_struct(f_node)
                    if row["Tree2"] != "":
                        finish_list2_struct(f_list2)
                    add_entry_list2(row, f_list2)
                add_entry_node(row, f_node)
    csv_file.close()

def get_left_numb(mask_str):
    digi = re.findall(r'\d+', mask_str)
    return(int(digi[0]))

def add_top_list(row, numb, f_top, f_top_rep):
    global is_null
    if numb == 8:
        if is_null == 1:
            f_top.write("   {0},\n")
        f_top.write("  },\n\n")
        f_top_rep.write("  {\n")
    elif numb > 8:
        if is_null == 1:
            f_top_rep.write("   {0},\n")
        f_top_rep.write("  },\n\n")
        f_top_rep.write("  {\n")
    elif numb != 0: #non first one, need to finish last one
        if is_null == 1:
            f_top.write("   {0},\n")
        f_top.write("  },\n\n")
        f_top.write("  {\n")
    else:
        f_top.write("lld_tof3_blk_lvl_int_list_t Tof3_int_top[16][20] = {\n")
        f_top.write("  {\n")
    is_null = 1

def get_top_mask(mask_str):
    rmd = 0
    digi = re.findall(r'\d+', mask_str)
    if len(digi) == 1:
        rmd = 0x1 << (int(digi[0])%32)
    else:
        rmd = 0x3 << (int(digi[0])%32)
    return(rmd)

def csv_parse_int_top_list(f_top, f_top_rep):
    top_name = ""
    pipe_name = ""
    station_name = ""
    global is_null
    is_null = 1;
    with open("Cloudbreak_Interrupt_List_20200625.csv", 'r') as csv_file:
        csv_reader = csv.DictReader(csv_file)
        for row in csv_reader:
            if re.match('pipe1', row["PIPE"]):
                #f_top_rep.write("  },\n\n")
                break
            if re.match('^Reserved', row["STATION"]):
                continue
            if row["Top"] != "" and not(re.match('^[0-9]', row["Top"])):
                top_name = str(row["Top"])
                pipe_name = ""
                station_name = ""
            if row["PIPE"] != "":
                pipe_name = str(row["PIPE"])
                station_name = ""
            if row["STATION"] != "":
                station_name = str(row["STATION"])
            if re.match('^[0-9]', row["Top"]):
                left = get_left_numb(row["Top"])
                top_array_mask = get_top_mask(row["Top"])
                if left%32 == 0:
                    #end last, start new struct
                    top_array_no = left/32
                    add_top_list(row, top_array_no, f_top, f_top_rep)
                #add an entry
                if re.match('pipe0', pipe_name):
                    f_top_rep.write("    {offsetof(tof3_reg, device_select.pcie_bar01_regs.shadow_int[%d]),\n" % top_array_no)
                    f_top_rep.write("     %s,\n" % hex(top_array_mask))
                    f_top_rep.write("     false,\n")
                    f_top_rep.write("     .u.blk_lvl_list = %s_%s_%s_sh_ints,\n" % (top_name, pipe_name, station_name))
                    f_top_rep.write("     STRUCT_LEN(%s_%s_%s_sh_ints),},\n" % (top_name, pipe_name, station_name))
                    is_null = 0
                    continue
                #if re.match('pipe[1-3]', pipe_name):
                #    continue
                if row["Tree1"] != "":
                    #list1
                    f_top.write("    {offsetof(tof3_reg, device_select.pcie_bar01_regs.shadow_int[%d]),\n" % top_array_no)
                    f_top.write("     %s,\n" % hex(top_array_mask))
                    f_top.write("     false,\n")
                    f_top.write("     .u.blk_lvl_list = %s_%s_sh_ints,\n" % (top_name, station_name))
                    f_top.write("     STRUCT_LEN(%s_%s_sh_ints),},\n" % (top_name, station_name))
                    is_null = 0
                elif row["Tree2"] != "":
                    #list2
                    f_top.write("    {offsetof(tof3_reg, device_select.pcie_bar01_regs.shadow_int[%d]),\n" % top_array_no)
                    f_top.write("     %s,\n" % hex(top_array_mask))
                    f_top.write("     false,\n")
                    f_top.write("     .u.blk_lvl_list = %s_%s_0_blk_lvl_list,\n" % (top_name, station_name))
                    f_top.write("     STRUCT_LEN(%s_%s_0_blk_lvl_list),},\n" % (top_name, station_name))
                    is_null = 0
                elif row["Status"] != "":
                    #node
                    f_top.write("    {offsetof(tof3_reg, device_select.pcie_bar01_regs.shadow_int[%d]),\n" % top_array_no)
                    f_top.write("     %s,\n" % hex(top_array_mask))
                    f_top.write("     true,\n")
                    f_top.write("     .u.blk_lvl_int = %s_%s_0_blk_lvl_int,\n" % (top_name, station_name))
                    f_top.write("     STRUCT_LEN(%s_%s_0_blk_lvl_int),},\n" % (top_name, station_name))
                    is_null = 0
    csv_file.close()


# Main
if __name__ == "__main__":
    with open("Tof3_Interrupt_Struct_list1.c", "w") as f_list1:
        with open("Tof3_Interrupt_Struct_list2.c", "w") as f_list2:
            with open("Tof3_Interrupt_Struct_node.c", "w") as f_node:
                csv_parse_int_list(f_list1, f_list2, f_node)
            f_node.close()
        f_list2.close()
    f_list1.close()
    with open("Tof3_Interrupt_Struct_top.c", "w") as f_top:
        with open("Tof3_Interrupt_Struct_top_rep.c", "w") as f_top_rep:
            csv_parse_int_top_list(f_top, f_top_rep)
        f_top_rep.close()
    f_top.close()
    #merge files into one file
    with open ("lld_tof3_interrupt_struct.h", 'w') as f:
        f.write("""
/* clang-format off */
/*******************************************************************************
 *
 *
 *
 ******************************************************************************/
/* ------- Generated code. Any mofications will be lost ------- */
#ifndef LLD_TOF3_INTERRUPT_STRUCT_INCLUDED
#define LLD_TOF3_INTERRUPT_STRUCT_INCLUDED

#ifndef __KERNEL__
#include <stdio.h>
#include <stdint.h>
#include <stdbool.h>
#else
#include <bf_types/bf_types.h>
#endif
#include <tof3_regs/tof3_reg_drv.h>

typedef struct lld_blk_lvl_int_s {
  uint32_t status_reg;
  uint32_t enable_hi_reg;
  uint32_t enable_lo_reg;
  uint32_t status_inject_reg;
  uint32_t shadow_mask;
  lld_int_cb cb_fn[BF_MAX_DEV_COUNT];
  void *userdata[BF_MAX_DEV_COUNT];
  uint32_t count[BF_MAX_DEV_COUNT][LLD_TOF3_COUNT_NUMB];
  uint32_t count_shown[BF_MAX_DEV_COUNT][LLD_TOF3_COUNT_NUMB];
} lld_tof3_blk_lvl_int_t;

typedef struct lld_tof3_blk_lvl_int_list_s {
  uint32_t reg_top;
  uint32_t mask;//mask of the input value if reg_top is -1, otherwise mask for reg_top
  bool is_leaf;
  union next_lvl_p{
    lld_tof3_blk_lvl_int_t *blk_lvl_int;
    struct lld_tof3_blk_lvl_int_list_s *blk_lvl_list;
  } u;
  uint32_t n;
} lld_tof3_blk_lvl_int_list_t;

#define STRUCT_LEN(x) (sizeof(x)/sizeof(x[0]))
""")
        f.write("\n/* ---%s--- */\n" % (str(datetime.date.today())))
        with open("Tof3_Interrupt_Struct_node.c") as f_node:
            for line in f_node:
                f.write(line)
        f_node.close()
        f.write("};\n")
        with open("Tof3_Interrupt_Struct_list2.c") as f_list2:
            for line in f_list2:
                f.write(line)
        f_list2.close()
        with open("Tof3_Interrupt_Struct_list1.c") as f_list1:
            for line in f_list1:
                f.write(line)
        f_list1.close()
        #special handling for multi PIPEs and multi MAUs
        f.write("\n")
        for p in range(0,4):
            f.write("PIPE_PRSR_BLK_INT(%d)\n\n" % p)
            f.write("PIPE_PRSR_BLK_INT_LIST(%d)\n\n" % p)
            f.write("PIPE_PRSR_BLK_SH_INTS(%d)\n\n" % p)
            f.write("PIPE_DPRSR_BLK_INT(%d)\n\n" % p)
            f.write("PIPE_DPRSR_BLK_INT_LIST(%d)\n\n" % p)
            f.write("PIPE_DPRSR_BLK_SH_INTS(%d)\n\n" % p)
            for m in range(0,20):
                f.write("PIPE_MAU_BLK_INT(%d,%d)\n\n" % (p,m))
                f.write("PIPE_MAU_BLK_INT_LIST(%d,%d)\n\n" % (p,m))
                f.write("PIPE_MAU_BLK_SH_INTS(%d,%d)\n\n" % (p,m))
        os.remove("Tof3_Interrupt_Struct_node.c")
        os.remove("Tof3_Interrupt_Struct_list2.c")
        os.remove("Tof3_Interrupt_Struct_list1.c")
        with open("Tof3_Interrupt_Struct_top.c") as f_top:
            for line in f_top:
                f.write(line)
        f_top.close()
        #f.write("  },\n  {\n")
        with open("Tof3_Interrupt_Struct_top_rep.c") as f_top:
            for line in f_top:
                f.write(line)
        f_top.close()
        f.write("  },\n\n")
        #f.write("  },\n  {\n")
        with open("Tof3_Interrupt_Struct_top_rep.c") as f_top:
            for line in f_top:
                temp = line.replace('pipe0','pipe1')
                temp = temp.replace('[8]', '[10]')
                temp = temp.replace('[9]', '[11]')
                f.write(temp)
        f_top.close()
        f.write("  },\n\n")
        #f.write("  },\n  {\n")
        with open("Tof3_Interrupt_Struct_top_rep.c") as f_top:
            for line in f_top:
                temp = line.replace('pipe0','pipe2')
                temp = temp.replace('[8]', '[12]')
                temp = temp.replace('[9]', '[13]')
                f.write(temp)
        f_top.close()
        f.write("  },\n\n")
        #f.write("  },\n  {\n")
        with open("Tof3_Interrupt_Struct_top_rep.c") as f_top:
            for line in f_top:
                temp = line.replace('pipe0','pipe3')
                temp = temp.replace('[8]', '[14]')
                temp = temp.replace('[9]', '[15]')
                f.write(temp)
        f_top.close()
        #special case, PBC
        for i in range(0, 4):
            f.write("    {offsetof(tof3_reg, device_select.pcie_bar01_regs.shadow_int[%d]),\n" % (15))
            hard_code = (504 + 2*i)
            top_array_mask = get_top_mask(str(hard_code)+':'+str(hard_code+2))
            f.write("     %s,\n" % hex(top_array_mask))
            f.write("     true,\n")
            f.write("     .u.blk_lvl_int = %s_%s_%d_blk_lvl_int,\n" % ('PBUS', 'PBC', i))
            f.write("     STRUCT_LEN(%s_%s_%d_blk_lvl_int),},\n" % ('PBUS', 'PBC', i))
        f.write("  },\n};\n") #end of top list
        f.write("#endif // LLD_TOF3_INTERRUPT_STRUCT_INCLUDED")
        f.write("/* clang-format on */\n")
    f.close()
    os.remove("Tof3_Interrupt_Struct_top.c")
    os.remove("Tof3_Interrupt_Struct_top_rep.c")
