/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/


/* clang-format off */

reg_decoder_fld_t tm_pre_mem_rspec__rdm_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__rdm_mem_word = { 1, tm_pre_mem_rspec__rdm_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__mit0_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__mit0_mem_word = { 1, tm_pre_mem_rspec__mit0_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__mit1_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__mit1_mem_word = { 1, tm_pre_mem_rspec__mit1_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__mit2_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__mit2_mem_word = { 1, tm_pre_mem_rspec__mit2_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__mit3_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__mit3_mem_word = { 1, tm_pre_mem_rspec__mit3_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pbt0_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pbt0_mem_word = { 1, tm_pre_mem_rspec__pbt0_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pbt1_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pbt1_mem_word = { 1, tm_pre_mem_rspec__pbt1_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit0_np_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit0_np_mem_word = { 1, tm_pre_mem_rspec__lit0_np_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit1_np_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit1_np_mem_word = { 1, tm_pre_mem_rspec__lit1_np_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__fifo_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__fifo_mem_word = { 1, tm_pre_mem_rspec__fifo_mem_word_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit0_bm_mem_word0_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit0_bm_mem_word0 = { 1, tm_pre_mem_rspec__lit0_bm_mem_word0_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit0_bm_mem_word1_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit0_bm_mem_word1 = { 1, tm_pre_mem_rspec__lit0_bm_mem_word1_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit0_bm_mem_word2_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit0_bm_mem_word2 = { 1, tm_pre_mem_rspec__lit0_bm_mem_word2_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit0_bm_mem_word3_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit0_bm_mem_word3 = { 1, tm_pre_mem_rspec__lit0_bm_mem_word3_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit1_bm_mem_word0_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit1_bm_mem_word0 = { 1, tm_pre_mem_rspec__lit1_bm_mem_word0_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit1_bm_mem_word1_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit1_bm_mem_word1 = { 1, tm_pre_mem_rspec__lit1_bm_mem_word1_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit1_bm_mem_word2_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit1_bm_mem_word2 = { 1, tm_pre_mem_rspec__lit1_bm_mem_word2_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__lit1_bm_mem_word3_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__lit1_bm_mem_word3 = { 1, tm_pre_mem_rspec__lit1_bm_mem_word3_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pmt0_mem_word0_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pmt0_mem_word0 = { 1, tm_pre_mem_rspec__pmt0_mem_word0_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pmt0_mem_word1_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pmt0_mem_word1 = { 1, tm_pre_mem_rspec__pmt0_mem_word1_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pmt0_mem_word2_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pmt0_mem_word2 = { 1, tm_pre_mem_rspec__pmt0_mem_word2_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pmt0_mem_word3_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pmt0_mem_word3 = { 1, tm_pre_mem_rspec__pmt0_mem_word3_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pmt1_mem_word0_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pmt1_mem_word0 = { 1, tm_pre_mem_rspec__pmt1_mem_word0_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pmt1_mem_word1_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pmt1_mem_word1 = { 1, tm_pre_mem_rspec__pmt1_mem_word1_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pmt1_mem_word2_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pmt1_mem_word2 = { 1, tm_pre_mem_rspec__pmt1_mem_word2_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t tm_pre_mem_rspec__pmt1_mem_word3_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t tm_pre_mem_rspec__pmt1_mem_word3 = { 1, tm_pre_mem_rspec__pmt1_mem_word3_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t mau_addrmap__dummy_register_fld_list[] = {
    { "dummy_register", 31, 0, 0, 0,
      "" },
};
reg_decoder_t mau_addrmap__dummy_register = { 1, mau_addrmap__dummy_register_fld_list, 32 /* bits */, 0 };

reg_decoder_fld_t prsr_mem_main_rspec__ml_tcam_row_word0_fld_list[] = {
    { "lookup_16", 15, 0, 0, 0,
      "" },
    { "lookup_8[0]", 23, 16, 0, 0,
      "" },
    { "lookup_8[1]", 31, 24, 0, 0,
      "" },
    { "curr_state", 39, 32, 0, 0,
      "" },
    { "ctr_zero", 40, 40, 0, 0,
      "[code]counter == 0[/code]" },
    { "ctr_neg", 41, 41, 0, 0,
      "[code]counter < 0[/code]" },
    { "ver_0", 42, 42, 0, 0,
      "[code]version[0][/code]" },
    { "ver_1", 43, 43, 0, 0,
      "[code]version[1][/code]" },
};
reg_decoder_t prsr_mem_main_rspec__ml_tcam_row_word0 = { 8, prsr_mem_main_rspec__ml_tcam_row_word0_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t prsr_mem_main_rspec__ml_tcam_row_word1_fld_list[] = {
    { "lookup_16", 15, 0, 0, 0,
      "" },
    { "lookup_8[0]", 23, 16, 0, 0,
      "" },
    { "lookup_8[1]", 31, 24, 0, 0,
      "" },
    { "curr_state", 39, 32, 0, 0,
      "" },
    { "ctr_zero", 40, 40, 0, 0,
      "[code]counter == 0[/code]" },
    { "ctr_neg", 41, 41, 0, 0,
      "[code]counter < 0[/code]" },
    { "ver_0", 42, 42, 0, 0,
      "[code]version[0][/code]" },
    { "ver_1", 43, 43, 0, 0,
      "[code]version[1][/code]" },
};
reg_decoder_t prsr_mem_main_rspec__ml_tcam_row_word1 = { 8, prsr_mem_main_rspec__ml_tcam_row_word1_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t prsr_mem_main_rspec__ml_ea_row_fld_list[] = {
    { "ctr_amt_idx", 7, 0, 0, 0,
      "Counter increment or load value:[list][*]pipe_top_level.pipes.i_prsr.ml_ea_row.ctr_load= 0: Immediate value to increment the counter by.[*]pipe_top_level.pipes.i_prsr.ml_ea_row.ctr_load= 1, pipe_top_level.pipes.i_prsr.ml_ea_row.ctr_ld_src= 0: Immediate value to load into the counter.[*]pipe_top_level.pipes.i_prsr.ml_ea_row.ctr_load= 1, pipe_top_level.pipes.i_prsr.ml_ea_row.ctr_ld_src= 1: Counter initialization RAM entry to load.[/list]" },
    { "ctr_ld_src", 8, 8, 0, 0,
      "Location to load the counter from:[list][*]0: Load immediate value from the pipe_top_level.pipes.i_prsr.ml_ea_row.ctr_amt_idx field.[*]1: Load counter from CounterRAM[pipe_top_level.pipes.i_prsr.ml_ea_row.ctr_amt_idx][/list]" },
    { "ctr_load", 9, 9, 0, 0,
      "Load the counter" },
    { "done", 10, 10, 0, 0,
      "This is the last header to be processed. Advance to the next packet.Note: pipe_top_level.pipes.i_prsr.ml_ea_row.shift_amt must specify the number of header bytes in the current word to identify the payload location." },
    { "shift_amt", 16, 11, 0, 0,
      "Shift the packet data input by this amount" },
    { "lookup_offset_16", 22, 17, 0, 0,
      "Offset from byte 0 the beginning of the 32B packet data input. If [code]MSB == 1[/code] then source from the additional static bytes." },
    { "lookup_offset_8[0]", 28, 23, 0, 0,
      "Offset from byte 0 the beginning of the 32B packet data input. If [code]MSB == 1[/code] then source from the additional static bytes." },
    { "lookup_offset_8[1]", 34, 29, 0, 0,
      "Offset from byte 0 the beginning of the 32B packet data input. If [code]MSB == 1[/code] then source from the additional static bytes." },
    { "ld_lookup_16", 35, 35, 0, 0,
      "" },
    { "ld_lookup_8[0]", 36, 36, 0, 0,
      "" },
    { "ld_lookup_8[1]", 37, 37, 0, 0,
      "" },
    { "nxt_state_mask", 45, 38, 0, 0,
      "Mask to apply to current state/next state:[list][*]0 = keep existing value[*]1 = use new value[/list][code]state = (nxt_state & nxt_state_mask) | (curr_state & ~nxt_state_mask)[/code]" },
    { "nxt_state", 53, 46, 0, 0,
      "" },
    { "buf_req", 59, 54, 0, 0,
      "Buffer occuapancy requirement for this entry to match. A buffer occupancy less than this will generate an error if the end of packet is seen, or will stall when the end of packet is not seen." },
};
reg_decoder_t prsr_mem_main_rspec__ml_ea_row = { 14, prsr_mem_main_rspec__ml_ea_row_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t prsr_mem_main_rspec__po_action_row_fld_list[] = {
    { "csum_addr[0]", 4, 0, 0, 0,
      "" },
    { "csum_addr[1]", 9, 5, 0, 0,
      "" },
    { "csum_en[0]", 10, 10, 0, 0,
      "" },
    { "csum_en[1]", 11, 11, 0, 0,
      "" },
    { "dst_offset_inc", 16, 12, 0, 0,
      "Increment the offset by this amount or, if pipe_top_level.pipes.i_prsr.po_action_row.dst_offset_rst is asserted, set the offset to this amount.The offset is updated [italic]after[/italic] the current offset is added to the destination addresses in this action entry." },
    { "dst_offset_rst", 17, 17, 0, 0,
      "Reset the destination offset before adding the value contained in pipe_top_level.pipes.i_prsr.po_action_row.dst_offset_rst.The offset is updated [italic]after[/italic] the current offset is added to the destination addresses in this action entry." },
    { "phv_32b_offset_add_dst_0", 18, 18, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_32b_offset_add_dst_1", 19, 19, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_32b_offset_add_dst_2", 20, 20, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_32b_offset_add_dst_3", 21, 21, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_16b_offset_add_dst_0", 22, 22, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_16b_offset_add_dst_1", 23, 23, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_16b_offset_add_dst_2", 24, 24, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_16b_offset_add_dst_3", 25, 25, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_8b_offset_add_dst_0", 26, 26, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_8b_offset_add_dst_1", 27, 27, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_8b_offset_add_dst_2", 28, 28, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_8b_offset_add_dst_3", 29, 29, 0, 0,
      "Add the current offset to the destination. Alters which [italic]PHV container[/italic] to use as the destination." },
    { "phv_32b_offset_rot_imm_0", 30, 30, 0, 0,
      "Right-rotate the immediate value by offset. Alters the [italic]immediate value[/italic] written to the destination." },
    { "phv_32b_offset_rot_imm_1", 31, 31, 0, 0,
      "Right-rotate the immediate value by offset. Alters the [italic]immediate value[/italic] written to the destination." },
    { "phv_16b_offset_rot_imm_0", 32, 32, 0, 0,
      "Right-rotate the immediate value by offset. Alters the [italic]immediate value[/italic] written to the destination." },
    { "phv_16b_offset_rot_imm_1", 33, 33, 0, 0,
      "Right-rotate the immediate value by offset. Alters the [italic]immediate value[/italic] written to the destination." },
    { "phv_8b_offset_rot_imm_0", 34, 34, 0, 0,
      "Right-rotate the immediate value by offset. Alters the [italic]immediate value[/italic] written to the destination." },
    { "phv_8b_offset_rot_imm_1", 35, 35, 0, 0,
      "Right-rotate the immediate value by offset. Alters the [italic]immediate value[/italic] written to the destination." },
    { "phv_8b_offset_rot_imm_2", 36, 36, 0, 0,
      "Right-rotate the immediate value by offset. Alters the [italic]immediate value[/italic] written to the destination." },
    { "phv_8b_offset_rot_imm_3", 37, 37, 0, 0,
      "Right-rotate the immediate value by offset. Alters the [italic]immediate value[/italic] written to the destination." },
    { "phv_32b_dst_0", 46, 38, 0, 0,
      "Destination PHV container" },
    { "phv_32b_dst_1", 55, 47, 0, 0,
      "Destination PHV container" },
    { "phv_32b_dst_2", 64, 56, 0, 0,
      "Destination PHV container" },
    { "phv_32b_dst_3", 73, 65, 0, 0,
      "Destination PHV container" },
    { "phv_16b_dst_0", 82, 74, 0, 0,
      "Destination PHV container" },
    { "phv_16b_dst_1", 91, 83, 0, 0,
      "Destination PHV container" },
    { "phv_16b_dst_2", 100, 92, 0, 0,
      "Destination PHV container" },
    { "phv_16b_dst_3", 109, 101, 0, 0,
      "Destination PHV container" },
    { "phv_8b_dst_0", 118, 110, 0, 0,
      "Destination PHV container" },
    { "phv_8b_dst_1", 127, 119, 0, 0,
      "Destination PHV container" },
    { "phv_8b_dst_2", 136, 128, 0, 0,
      "Destination PHV container" },
    { "phv_8b_dst_3", 145, 137, 0, 0,
      "Destination PHV container" },
    { "phv_32b_src_0", 153, 146, 0, 0,
      "Contains either an offset within the packet data or an immediate value (see phv_XXb_src_type_X). When providing an offset, [code]addr[5] == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_32b_src_1", 161, 154, 0, 0,
      "Contains either an offset within the packet data or an immediate value (see phv_XXb_src_type_X). When providing an offset, [code]addr[5] == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_32b_src_2", 167, 162, 0, 0,
      "Packet data offset. [code]MSB == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_32b_src_3", 173, 168, 0, 0,
      "Packet data offset. [code]MSB == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_16b_src_0", 181, 174, 0, 0,
      "Contains either an offset within the packet data or an immediate value (see phv_XXb_src_type_X). When providing an offset, [code]addr[5] == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_16b_src_1", 189, 182, 0, 0,
      "Contains either an offset within the packet data or an immediate value (see phv_XXb_src_type_X). When providing an offset, [code]addr[5] == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_16b_src_2", 195, 190, 0, 0,
      "Packet data offset. [code]MSB == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_16b_src_3", 201, 196, 0, 0,
      "Packet data offset. [code]MSB == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_8b_src_0", 209, 202, 0, 0,
      "Contains either an offset within the packet data or an immediate value (see phv_XXb_src_type_X). When providing an offset, [code]addr[5] == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_8b_src_1", 217, 210, 0, 0,
      "Contains either an offset within the packet data or an immediate value (see phv_XXb_src_type_X). When providing an offset, [code]addr[5] == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_8b_src_2", 225, 218, 0, 0,
      "Contains either an offset within the packet data or an immediate value (see phv_XXb_src_type_X). When providing an offset, [code]addr[5] == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_8b_src_3", 233, 226, 0, 0,
      "Contains either an offset within the packet data or an immediate value (see phv_XXb_src_type_X). When providing an offset, [code]addr[5] == 1[/code] indicates sourcing from the global version number and timestamp." },
    { "phv_32b_src_type_0", 234, 234, 0, 0,
      "Source:[list][*]0: use packet data as source[*]1: immediate value supplied as source[/list]" },
    { "phv_32b_src_type_1", 235, 235, 0, 0,
      "Source:[list][*]0: use packet data as source[*]1: immediate value supplied as source[/list]" },
    { "phv_16b_src_type_0", 236, 236, 0, 0,
      "Source:[list][*]0: use packet data as source[*]1: immediate value supplied as source[/list]" },
    { "phv_16b_src_type_1", 237, 237, 0, 0,
      "Source:[list][*]0: use packet data as source[*]1: immediate value supplied as source[/list]" },
    { "phv_8b_src_type_0", 238, 238, 0, 0,
      "Source:[list][*]0: use packet data as source[*]1: immediate value supplied as source[/list]" },
    { "phv_8b_src_type_1", 239, 239, 0, 0,
      "Source:[list][*]0: use packet data as source[*]1: immediate value supplied as source[/list]" },
    { "phv_8b_src_type_2", 240, 240, 0, 0,
      "Source:[list][*]0: use packet data as source[*]1: immediate value supplied as source[/list]" },
    { "phv_8b_src_type_3", 241, 241, 0, 0,
      "Source:[list][*]0: use packet data as source[*]1: immediate value supplied as source[/list]" },
    { "pri_upd_type", 242, 242, 0, 0,
      "Priority update type: [list][*]0: immediate value supplied as source (see pipe_top_level.pipes.i_prsr.po_action_row.pri_upd_val_mask and pipe_top_level.pipes.i_prsr.po_action_row.pri_upd_en_shr)[*]1: use packet data as source (see pipe_top_level.pipes.i_prsr.po_action_row.pri_upd_src, pipe_top_level.pipes.i_prsr.po_action_row.pri_upd_en_shr and pipe_top_level.pipes.i_prsr.po_action_row.pri_upd_val_mask)[/list]" },
    { "pri_upd_src", 247, 243, 0, 0,
      "Packet data offset. May not access the global version number or timestamp." },
    { "pri_upd_en_shr", 251, 248, 0, 0,
      "Priority update enable or right-shift amount. Determined by the update type:[list][*]0: Priority update (determined by LSB)[*]1: Right-shift the 16b value at pipe_top_level.pipes.i_prsr.po_action_row.pri_upd_src. Priority is the three LSBs of the shifted 16b value after masking[/list]" },
    { "pri_upd_val_mask", 254, 252, 0, 0,
      "Priority value or mask, determined by pipe_top_level.pipes.i_prsr.po_action_row.pri_upd_type:[list][*]0: immediate value to set as the priority[*]1: mask to apply to the extracted and shifted value[/list]" },
};
reg_decoder_t prsr_mem_main_rspec__po_action_row = { 62, prsr_mem_main_rspec__po_action_row_fld_list, 256 /* bits */, 0 };

reg_decoder_fld_t prsr_mem_main_rspec__ml_ctr_init_ram_fld_list[] = {
    { "add", 7, 0, 0, 0,
      "Value to add to the rotated & masked value" },
    { "mask", 10, 8, 0, 0,
      "Mask the rotate value: [code]rot_val & (2 ** (mask+1)-1)[/code]" },
    { "rotate", 13, 11, 0, 0,
      "Amount to right rotate the source value" },
    { "max", 21, 14, 0, 0,
      "Maximum permitted value in source" },
    { "src", 23, 22, 0, 0,
      "TCAM lookup input to use as the counter source:[list][*]0: lookup_16b -- 8 LSBs[*]1: lookup_16b -- 8 MSBs[*]2: lookup_8b[0][*]3: lookup_8b[1][/list]" },
};
reg_decoder_t prsr_mem_main_rspec__ml_ctr_init_ram = { 5, prsr_mem_main_rspec__ml_ctr_init_ram_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t prsr_mem_main_rspec__po_csum_ctrl_0_row_fld_list[] = {
    { "add", 15, 0, 0, 0,
      "16b constant to add to the checksum calculation" },
    { "swap[0]", 16, 16, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[1]", 17, 17, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[2]", 18, 18, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[3]", 19, 19, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[4]", 20, 20, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[5]", 21, 21, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[6]", 22, 22, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[7]", 23, 23, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[8]", 24, 24, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[9]", 25, 25, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[10]", 26, 26, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[11]", 27, 27, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[12]", 28, 28, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[13]", 29, 29, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[14]", 30, 30, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[15]", 31, 31, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[16]", 32, 32, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "shr", 33, 33, 0, 0,
      "Rotate the 32B packet word right by one prior to processing.Note: treat 32B input word as a left-aligned 34B data word." },
    { "mask[0]", 34, 34, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[1]", 35, 35, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[2]", 36, 36, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[3]", 37, 37, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[4]", 38, 38, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[5]", 39, 39, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[6]", 40, 40, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[7]", 41, 41, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[8]", 42, 42, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[9]", 43, 43, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[10]", 44, 44, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[11]", 45, 45, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[12]", 46, 46, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[13]", 47, 47, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[14]", 48, 48, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[15]", 49, 49, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[16]", 50, 50, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[17]", 51, 51, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[18]", 52, 52, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[19]", 53, 53, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[20]", 54, 54, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[21]", 55, 55, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[22]", 56, 56, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[23]", 57, 57, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[24]", 58, 58, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[25]", 59, 59, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[26]", 60, 60, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[27]", 61, 61, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[28]", 62, 62, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[29]", 63, 63, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[30]", 64, 64, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[31]", 65, 65, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "dst_bit_hdr_end_pos", 70, 66, 0, 0,
      "[list][*]VERIFY: indicates the bit within the destination PHV to record the validity of the checksum.Note: [code]target_bit_position = bit_position % container_size[/code].[*]RESIDUAL: indicates where the header ends in the current packet word. Any headers after the current header are automatically subtracted from the residual.[/list]Valid only when pipe_top_level.pipes.i_prsr.po_csum_ctrl_0_row.hdr_end is asserted." },
    { "dst", 79, 71, 0, 0,
      "Destination PHV field.Valid only when pipe_top_level.pipes.i_prsr.po_csum_ctrl_0_row.hdr_end is asserted." },
    { "hdr_end", 80, 80, 0, 0,
      "The header containing the checksum ends in this packet word.[list][*]0: Additional words to come[*]1: Final word of header. For VERIFY checksums, verify that the checksum is correct by comparing to zero. For RESIDUAL checksums, automatically subtract any headers that follow.[/list]" },
    { "type", 81, 81, 0, 0,
      "Checksum calculation type:[list][*]0: Verification -- Verify that a checksum is valid. A final sum of zero indicates a valid checksum.[*]1: Residual -- Calculate the residual of the checksum, i.e., the contribution of [italic]non-header[/italic] bytes of the packet.[/list]Sampled when pipe_top_level.pipes.i_prsr.po_csum_ctrl_0_row.start == 1." },
    { "start", 82, 82, 0, 0,
      "Start a new checksum calculation and clear any previously calculated value" },
    { "zeros_as_ones", 83, 83, 0, 0,
      "The current data word contains a checksum; an all-zeros checksum is encoded as all-ones. This is used by certain protocols, such as UDP, which use all zeros to indicate the checksum is not used. Indicates that an all-ones value at pipe_top_level.pipes.i_prsr.po_csum_ctrl_0_row.zeros_as_ones_pos should be converted to all-zeros." },
    { "zeros_as_ones_pos", 88, 84, 0, 0,
      "The position of the checksum within the data word. Only necessary when zeros-as-ones is in use." },
};
reg_decoder_t prsr_mem_main_rspec__po_csum_ctrl_0_row = { 58, prsr_mem_main_rspec__po_csum_ctrl_0_row_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t prsr_mem_main_rspec__po_csum_ctrl_1_row_fld_list[] = {
    { "add", 15, 0, 0, 0,
      "16b constant to add to the checksum calculation" },
    { "swap[0]", 16, 16, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[1]", 17, 17, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[2]", 18, 18, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[3]", 19, 19, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[4]", 20, 20, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[5]", 21, 21, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[6]", 22, 22, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[7]", 23, 23, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[8]", 24, 24, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[9]", 25, 25, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[10]", 26, 26, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[11]", 27, 27, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[12]", 28, 28, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[13]", 29, 29, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[14]", 30, 30, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[15]", 31, 31, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "swap[16]", 32, 32, 0, 0,
      "Swap the corresponding two bytes within each 16b field" },
    { "shr", 33, 33, 0, 0,
      "Rotate the 32B packet word right by one prior to processing.Note: treat 32B input word as a left-aligned 34B data word." },
    { "mask[0]", 34, 34, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[1]", 35, 35, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[2]", 36, 36, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[3]", 37, 37, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[4]", 38, 38, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[5]", 39, 39, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[6]", 40, 40, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[7]", 41, 41, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[8]", 42, 42, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[9]", 43, 43, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[10]", 44, 44, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[11]", 45, 45, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[12]", 46, 46, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[13]", 47, 47, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[14]", 48, 48, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[15]", 49, 49, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[16]", 50, 50, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[17]", 51, 51, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[18]", 52, 52, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[19]", 53, 53, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[20]", 54, 54, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[21]", 55, 55, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[22]", 56, 56, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[23]", 57, 57, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[24]", 58, 58, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[25]", 59, 59, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[26]", 60, 60, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[27]", 61, 61, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[28]", 62, 62, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[29]", 63, 63, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[30]", 64, 64, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "mask[31]", 65, 65, 0, 0,
      "Include the corresponding byte in the checksum calculation" },
    { "dst_bit_hdr_end_pos", 70, 66, 0, 0,
      "[list][*]VERIFY: indicates the bit within the destination PHV to record the validity of the checksum.Note: [code]target_bit_position = bit_position % container_size[/code].[*]RESIDUAL: indicates where the header ends in the current packet word. Any headers after the current header are automatically subtracted from the residual.[/list]Valid only when pipe_top_level.pipes.i_prsr.po_csum_ctrl_1_row.hdr_end is asserted." },
    { "dst", 79, 71, 0, 0,
      "Destination PHV field.Valid only when pipe_top_level.pipes.i_prsr.po_csum_ctrl_1_row.hdr_end is asserted." },
    { "hdr_end", 80, 80, 0, 0,
      "The header containing the checksum ends in this packet word.[list][*]0: Additional words to come[*]1: Final word of header. For VERIFY checksums, verify that the checksum is correct by comparing to zero. For RESIDUAL checksums, automatically subtract any headers that follow.[/list]" },
    { "type", 81, 81, 0, 0,
      "Checksum calculation type:[list][*]0: Verification -- Verify that a checksum is valid. A final sum of zero indicates a valid checksum.[*]1: Residual -- Calculate the residual of the checksum, i.e., the contribution of [italic]non-header[/italic] bytes of the packet.[/list]Sampled when pipe_top_level.pipes.i_prsr.po_csum_ctrl_1_row.start == 1." },
    { "start", 82, 82, 0, 0,
      "Start a new checksum calculation and clear any previously calculated value" },
    { "zeros_as_ones", 83, 83, 0, 0,
      "The current data word contains a checksum; an all-zeros checksum is encoded as all-ones. This is used by certain protocols, such as UDP, which use all zeros to indicate the checksum is not used. Indicates that an all-ones value at pipe_top_level.pipes.i_prsr.po_csum_ctrl_1_row.zeros_as_ones_pos should be converted to all-zeros." },
    { "zeros_as_ones_pos", 88, 84, 0, 0,
      "The position of the checksum within the data word. Only necessary when zeros-as-ones is in use." },
};
reg_decoder_t prsr_mem_main_rspec__po_csum_ctrl_1_row = { 58, prsr_mem_main_rspec__po_csum_ctrl_1_row_fld_list, 128 /* bits */, 0 };

reg_decoder_fld_t party_pgr_mem_rspec__buffer_mem_word_fld_list[] = {
    { "mem_word", 0, 0, 0, 0,
      "" },
};
reg_decoder_t party_pgr_mem_rspec__buffer_mem_word = { 1, party_pgr_mem_rspec__buffer_mem_word_fld_list, 128 /* bits */, 0 };

cmd_arg_item_t tm_pre_mem_rspec_mem_list[] = {
{ "rdm_mem_word", NULL, 0x0, &tm_pre_mem_rspec__rdm_mem_word, 0x660000 },
{ "mit0_mem_word", NULL, 0x100000, &tm_pre_mem_rspec__mit0_mem_word, 0x40000 },
{ "mit1_mem_word", NULL, 0x200000, &tm_pre_mem_rspec__mit1_mem_word, 0x40000 },
{ "mit2_mem_word", NULL, 0x300000, &tm_pre_mem_rspec__mit2_mem_word, 0x40000 },
{ "mit3_mem_word", NULL, 0x400000, &tm_pre_mem_rspec__mit3_mem_word, 0x40000 },
{ "pbt0_mem_word", NULL, 0x40000000, &tm_pre_mem_rspec__pbt0_mem_word, 0x1200 },
{ "pbt1_mem_word", NULL, 0x40100000, &tm_pre_mem_rspec__pbt1_mem_word, 0x1200 },
{ "lit0_np_mem_word", NULL, 0x40200000, &tm_pre_mem_rspec__lit0_np_mem_word, 0x1000 },
{ "lit1_np_mem_word", NULL, 0x40300000, &tm_pre_mem_rspec__lit1_np_mem_word, 0x1000 },
{ "fifo_mem_word", NULL, 0x40400000, &tm_pre_mem_rspec__fifo_mem_word, 0x40 },
{ "lit0_bm_mem_word0", NULL, 0x80000000, &tm_pre_mem_rspec__lit0_bm_mem_word0, 0x1000 },
{ "lit0_bm_mem_word1", NULL, 0x80040000, &tm_pre_mem_rspec__lit0_bm_mem_word1, 0x1000 },
{ "lit0_bm_mem_word2", NULL, 0x80080000, &tm_pre_mem_rspec__lit0_bm_mem_word2, 0x1000 },
{ "lit0_bm_mem_word3", NULL, 0x800c0000, &tm_pre_mem_rspec__lit0_bm_mem_word3, 0x1000 },
{ "lit1_bm_mem_word0", NULL, 0x80100000, &tm_pre_mem_rspec__lit1_bm_mem_word0, 0x1000 },
{ "lit1_bm_mem_word1", NULL, 0x80140000, &tm_pre_mem_rspec__lit1_bm_mem_word1, 0x1000 },
{ "lit1_bm_mem_word2", NULL, 0x80180000, &tm_pre_mem_rspec__lit1_bm_mem_word2, 0x1000 },
{ "lit1_bm_mem_word3", NULL, 0x801c0000, &tm_pre_mem_rspec__lit1_bm_mem_word3, 0x1000 },
{ "pmt0_mem_word0", NULL, 0x80200000, &tm_pre_mem_rspec__pmt0_mem_word0, 0x1200 },
{ "pmt0_mem_word1", NULL, 0x80240000, &tm_pre_mem_rspec__pmt0_mem_word1, 0x1200 },
{ "pmt0_mem_word2", NULL, 0x80280000, &tm_pre_mem_rspec__pmt0_mem_word2, 0x1200 },
{ "pmt0_mem_word3", NULL, 0x802c0000, &tm_pre_mem_rspec__pmt0_mem_word3, 0x1200 },
{ "pmt1_mem_word0", NULL, 0x80300000, &tm_pre_mem_rspec__pmt1_mem_word0, 0x1200 },
{ "pmt1_mem_word1", NULL, 0x80340000, &tm_pre_mem_rspec__pmt1_mem_word1, 0x1200 },
{ "pmt1_mem_word2", NULL, 0x80380000, &tm_pre_mem_rspec__pmt1_mem_word2, 0x1200 },
{ "pmt1_mem_word3", NULL, 0x803c0000, &tm_pre_mem_rspec__pmt1_mem_word3, 0x1200 },
};
cmd_arg_t tm_pre_mem_rspec_mem = { 26, tm_pre_mem_rspec_mem_list };

cmd_arg_item_t mau_addrmap_mem_list[] = {
{ "dummy_register", NULL, 0x0, &mau_addrmap__dummy_register, 0x4 },
};
cmd_arg_t mau_addrmap_mem = { 1, mau_addrmap_mem_list };

cmd_arg_item_t prsr_mem_main_rspec_mem_list[] = {
{ "ml_tcam_row_word0", NULL, 0x0, &prsr_mem_main_rspec__ml_tcam_row_word0, 0x1000 },
{ "ml_tcam_row_word1", NULL, 0x100, &prsr_mem_main_rspec__ml_tcam_row_word1, 0x1000 },
{ "ml_ea_row", NULL, 0x200, &prsr_mem_main_rspec__ml_ea_row, 0x1000 },
{ "po_action_row", NULL, 0x400, &prsr_mem_main_rspec__po_action_row, 0x2000 },
{ "ml_ctr_init_ram", NULL, 0x600, &prsr_mem_main_rspec__ml_ctr_init_ram, 0x100 },
{ "po_csum_ctrl_0_row", NULL, 0x620, &prsr_mem_main_rspec__po_csum_ctrl_0_row, 0x200 },
{ "po_csum_ctrl_1_row", NULL, 0x640, &prsr_mem_main_rspec__po_csum_ctrl_1_row, 0x200 },
};
cmd_arg_t prsr_mem_main_rspec_mem = { 7, prsr_mem_main_rspec_mem_list };

cmd_arg_item_t party_pgr_mem_rspec_mem_list[] = {
{ "buffer_mem_word", NULL, 0x0, &party_pgr_mem_rspec__buffer_mem_word, 0x4000 },
};
cmd_arg_t party_pgr_mem_rspec_mem = { 1, party_pgr_mem_rspec_mem_list };

cmd_arg_item_t pipe_addrmap_mem_list[] = {
{ "mau[0]", &mau_addrmap_mem, 0x0, NULL },
{ "mau[1]", &mau_addrmap_mem, 0x200000000, NULL },
{ "mau[2]", &mau_addrmap_mem, 0x400000000, NULL },
{ "mau[3]", &mau_addrmap_mem, 0x600000000, NULL },
{ "mau[4]", &mau_addrmap_mem, 0x800000000, NULL },
{ "mau[5]", &mau_addrmap_mem, 0xa00000000, NULL },
{ "mau[6]", &mau_addrmap_mem, 0xc00000000, NULL },
{ "mau[7]", &mau_addrmap_mem, 0xe00000000, NULL },
{ "mau[8]", &mau_addrmap_mem, 0x1000000000, NULL },
{ "mau[9]", &mau_addrmap_mem, 0x1200000000, NULL },
{ "mau[10]", &mau_addrmap_mem, 0x1400000000, NULL },
{ "mau[11]", &mau_addrmap_mem, 0x1600000000, NULL },
{ "i_prsr[0]", &prsr_mem_main_rspec_mem, 0x1c80000000, NULL },
{ "i_prsr[1]", &prsr_mem_main_rspec_mem, 0x1c80002000, NULL },
{ "i_prsr[2]", &prsr_mem_main_rspec_mem, 0x1c80004000, NULL },
{ "i_prsr[3]", &prsr_mem_main_rspec_mem, 0x1c80006000, NULL },
{ "i_prsr[4]", &prsr_mem_main_rspec_mem, 0x1c80008000, NULL },
{ "i_prsr[5]", &prsr_mem_main_rspec_mem, 0x1c8000a000, NULL },
{ "i_prsr[6]", &prsr_mem_main_rspec_mem, 0x1c8000c000, NULL },
{ "i_prsr[7]", &prsr_mem_main_rspec_mem, 0x1c8000e000, NULL },
{ "i_prsr[8]", &prsr_mem_main_rspec_mem, 0x1c80010000, NULL },
{ "i_prsr[9]", &prsr_mem_main_rspec_mem, 0x1c80012000, NULL },
{ "i_prsr[10]", &prsr_mem_main_rspec_mem, 0x1c80014000, NULL },
{ "i_prsr[11]", &prsr_mem_main_rspec_mem, 0x1c80016000, NULL },
{ "i_prsr[12]", &prsr_mem_main_rspec_mem, 0x1c80018000, NULL },
{ "i_prsr[13]", &prsr_mem_main_rspec_mem, 0x1c8001a000, NULL },
{ "i_prsr[14]", &prsr_mem_main_rspec_mem, 0x1c8001c000, NULL },
{ "i_prsr[15]", &prsr_mem_main_rspec_mem, 0x1c8001e000, NULL },
{ "i_prsr[16]", &prsr_mem_main_rspec_mem, 0x1c80020000, NULL },
{ "i_prsr[17]", &prsr_mem_main_rspec_mem, 0x1c80022000, NULL },
{ "party_pgr", &party_pgr_mem_rspec_mem, 0x1c8003c000, NULL },
{ "e_prsr[0]", &prsr_mem_main_rspec_mem, 0x1c80040000, NULL },
{ "e_prsr[1]", &prsr_mem_main_rspec_mem, 0x1c80042000, NULL },
{ "e_prsr[2]", &prsr_mem_main_rspec_mem, 0x1c80044000, NULL },
{ "e_prsr[3]", &prsr_mem_main_rspec_mem, 0x1c80046000, NULL },
{ "e_prsr[4]", &prsr_mem_main_rspec_mem, 0x1c80048000, NULL },
{ "e_prsr[5]", &prsr_mem_main_rspec_mem, 0x1c8004a000, NULL },
{ "e_prsr[6]", &prsr_mem_main_rspec_mem, 0x1c8004c000, NULL },
{ "e_prsr[7]", &prsr_mem_main_rspec_mem, 0x1c8004e000, NULL },
{ "e_prsr[8]", &prsr_mem_main_rspec_mem, 0x1c80050000, NULL },
{ "e_prsr[9]", &prsr_mem_main_rspec_mem, 0x1c80052000, NULL },
{ "e_prsr[10]", &prsr_mem_main_rspec_mem, 0x1c80054000, NULL },
{ "e_prsr[11]", &prsr_mem_main_rspec_mem, 0x1c80056000, NULL },
{ "e_prsr[12]", &prsr_mem_main_rspec_mem, 0x1c80058000, NULL },
{ "e_prsr[13]", &prsr_mem_main_rspec_mem, 0x1c8005a000, NULL },
{ "e_prsr[14]", &prsr_mem_main_rspec_mem, 0x1c8005c000, NULL },
{ "e_prsr[15]", &prsr_mem_main_rspec_mem, 0x1c8005e000, NULL },
{ "e_prsr[16]", &prsr_mem_main_rspec_mem, 0x1c80060000, NULL },
{ "e_prsr[17]", &prsr_mem_main_rspec_mem, 0x1c80062000, NULL },
};
cmd_arg_t pipe_addrmap_mem = { 49, pipe_addrmap_mem_list };

cmd_arg_item_t pipe_top_level_mem_list[] = {
{ "tm_pre", &tm_pre_mem_rspec_mem, 0x6100000000, NULL },
{ "pipes[0]", &pipe_addrmap_mem, 0x20000000000, NULL },
{ "pipes[1]", &pipe_addrmap_mem, 0x22000000000, NULL },
{ "pipes[2]", &pipe_addrmap_mem, 0x24000000000, NULL },
{ "pipes[3]", &pipe_addrmap_mem, 0x26000000000, NULL },
};
cmd_arg_t pipe_top_level_mem = { 5, pipe_top_level_mem_list };

