/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/


/*
 *  DataStructures to process hash computation using Json file
 *  generated by P4 compiler.
 *
 * BareFoot Networks Inc.
 */

#include <stdint.h>
#include <target-utils/third-party/cJSON/cJSON.h>

#ifndef __BF_HASH_COMPUTE_JSON__
#define __BF_HASH_COMPUTE_JSON__

#include <pipe_mgr/pipe_mgr_err.h>

#define BF_HASH_COMP_MAX_HASH_BITS (52)
#define BF_HASH_COMP_FIELD_OFFSET_INVALID (0xffff)
#define BF_HASH_COMP_BJ_LUT_INDEX_INVALID (0xffff)
#define BF_HASH_COMP_STAGE_INVALID (0xff)
#define BF_HASH_COMP_BYTE_INVALID (0xff)
#define BF_HASH_COMP_HANDLE_INVALID (0xffffffff)

typedef enum hash_comp_hash_types_ {
  BF_HASH_COMP_HASHTYPE_NONE = 0,
  BF_HASH_COMP_HASHTYPE_MATCH = 1
} hash_comp_hash_types_e;

typedef struct hash_comp_match_spec_xtract_ {
  // Will there be more than 255 words in matchspec ?
  uint8_t match_word;
  uint8_t valid_word;
  uint32_t bitmask_valid;  // bmask that contribute to hash in spec word
  uint32_t bitmask_match;  // bmask that contribute to hash in spec word
  uint8_t hashtype;
} hash_comp_xtract_t;

typedef struct bf_hash_bit_ {
  // msb is seed bit. Remaining 15 bits specify number of extraction words
  // (extracted from match spec) used for computing single hash-bit.
  uint16_t seed_xtractwords;
  hash_comp_xtract_t *xtract_list;
} bf_hash_bit_t;

typedef struct bf_hash_ghost_bit_info_ {
  int byte_in_match_spec;
  uint8_t bit_in_byte;
} bf_hash_ghost_bit_info_t;

typedef struct bf_hash_ghost_bit_to_hash_bit_ {
  uint16_t num_hash_bits;
  uint8_t *mapping;
} bf_hash_ghost_bit_to_hash_bit_t;

typedef struct bf_hash_field_ {
  /* Length of the key in bits, that is the number of match spec bytes times
   * eight. */
  uint16_t key_length;
  /* Only needed for Hash Action tables.  Array with one entry per hash bit and
   * stores the offset of the key bit corresponding to that hash bit. */
  uint16_t *key_field_offset;
  // Hash values generated for each key bit.
  uint64_t *hash_values;
  // Hash Seed value.
  uint64_t hash_seed;
  // Radix value (possible values 2, 4, 8) for hash_combinations.
  uint16_t radix_value;
  // Size of the hash combinations array.
  uint64_t hash_combs_size;
  // Pre-computed hash values.
  uint64_t *hash_combinations;
  bf_hash_bit_t hash_bit[BF_HASH_COMP_MAX_HASH_BITS];
  uint8_t hash_width;  // can be < BF_HASH_COMP_MAX_HASH_BITS.
  uint16_t num_ghost_bits;
  bf_hash_ghost_bit_info_t *ghost_bit_info;
  bf_hash_ghost_bit_to_hash_bit_t *ghost_bit_to_hash_bits;
} bf_hash_field_t;

/* Maximum possible number of 52-bit hashes. */
#define BF_MAX_52B_HASHES (8)

/* Lookup table. Lookup = JenkinHash(table-handle, stage) */
typedef struct hash_compute_table_ {
  uint32_t tbl_hndl;
  uint8_t stage;
  bool is_proxy_hash;
  // Count of 52b hashes.
  uint8_t wide_hash_len;
  // Specifies location of hash field structure.
  uint16_t hash_field_offset[BF_MAX_52B_HASHES];
} bf_hash_tbl_lut;

/* Hash compute profile. */
typedef struct bf_hash_comp_profile {
  int field_offset_allocated;
  // Number of hash lookup tables (LUTs).
  uint16_t total_table_count;
  // Number of hash tables rounded up to next power of 2.
  uint16_t lut_depth;
  // Total number of hash field lists.
  uint16_t total_hash_field_list;
  bf_hash_field_t *field_base;
  bf_hash_tbl_lut *lut;
  int hash_collison_count;
} bf_hash_comp_profile_t;

/* Collection of hash compute profiles. */
typedef struct bf_hash_comp_ {
  // Number of profiles in array.
  uint32_t num_profiles;
  // Array of profiles.
  bf_hash_comp_profile_t *profiles;
} bf_hash_comp_t;

#define BF_HASH_PROXY_KEY (0xAA)
#define BF_HASH_NON_PROXY_KEY (0x55)

#define BF_HASHTYPE(_proxy) \
  ((_proxy) ? BF_HASH_PROXY_KEY : BF_HASH_NON_PROXY_KEY)

pipe_status_t bf_hash_compute_init(bf_dev_id_t devid, uint32_t num_profiles);
void bf_hash_compute_destroy(bf_dev_id_t devid);
bf_hash_field_t *bf_hash_comp_get_field_base(bf_dev_id_t devid,
                                             profile_id_t prof_id);
bf_hash_comp_t *bf_hash_comp_get_hash_ctx(bf_dev_id_t devid);

#endif
