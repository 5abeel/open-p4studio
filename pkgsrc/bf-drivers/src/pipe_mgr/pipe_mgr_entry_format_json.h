/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/


/*!
 * @file pipe_mgr_entry_format_json.h
 * @date
 *
 *  DataStructures to process entry formatting using Json file
 *  generated by P4 compiler.
 */

#include <stdint.h>

/*
 *     Brief details on how table entry formatting is maintained and used
 *          ________________________________________
 *
 *  1. P4 Tofino compiler creates entry formatting details for
 *     all types of tables.
 *  2. Entry formatting details for EXM, TERN, ADT, TIND tables and default
 *     entry format for all tables is captured in mau.context.json
 *  3. Entry formatting details are parsed and built into
 *     LUTs (Look Up Tables).
 *  4. For a given table-handle and stage (for some table types its only
 *     table-handle) bob jenkin hash is computed to index into LUT.
 *  5. At the time of entry update (into any of the table types or for default
 *     entry), a fast look up is done into appropriate LUT (if updating
 *     EXM table, exm-lut is used; if new entry is added to TERN table, then
 *     tern table LUT is used to fetch formatting details).
 *  6. Look up result will give a single contiguous memory for better cache
 *     performace (although this memory is traversed as if it is collection
 *     of various entites. Example formatting for a given way, entry position
 *     entry fields).
 *
 *     NOTE : To avoid to many small memory chunks which leads to inefficient
 *            memory usage as well as to optimize cache performance, memory size
 *            required to perform entry formatting for a given (table,stage)
 *            is allocated contiguously even though there are varying number
 *            of fields like many entries, many ways, stage for a given P4
 *table.
 *            The way this is done is during JSON parsing, a count of different
 *            entry formatting fields (numbers of stage, number of entries,
 *            number of ways, number of fields etc) is done. Based on this
 *            dynamic count memory size is calculated and at appropriate offset
 *            formatting details are populated after fetching from JSON.
 *            While populating data structures (during json
 *            parsing), pointer arthmetic is done to jump to correct memory
 *            location. Such an implementation allows to use larger memory
 *            chunks as well as less cache evicts.
 *
 *           Entry formatting related Json Details
 *          ________________________________________
 *
 *  8. Entry formatting JSON Syntax/Format is
 *
 *    "EntryFormatNode": {
 *
 *        "TindEntryFormat": {
 *            "TotalTindTables": int,
 *            "AllTindTables": [ {
 *                "TindTableName": string
 *                "TindTableHandle": int,
 *                "TindTableFormat": [ {
 *                    "Stage" : int
 *                    "TindMatchEntryFormat": [ {
 *                        "Entry": int,
 *                        "EntryFieldCount": int,
 *                        "EntryFormat": [ {
 *                            "FIELDWIDTH": int,
 *                            "MEMWORDOFFSET": [
 *                              int,
 *                              int
 *                            ],
 *                          "SOURCENAME": string,
 *                          "PERFLOWENABLE": boolean,
 *                          "FIELDSB": int,
 *                          "FIELDNAME": string
 *                          "FIELDOFFSET": int,
 *                          "MSBIT": int,
 *                          "IMMNAME": string
 *                        }]
 *                    }]
 *                    "TindActionHandleCount": int,
 *                    "TindMatchEntryFieldCount": int,
 *                    "TindActionImmediateCount": int,
 *                    "TindMatchEntryCount": int,
 *                    "TindActionHandles": [{
 *                        "ImmediateCount": int,
 *                        "ACTION_HDL": int,
 *                        "IMMEDIATE": {
 *                            "instr": int,
 *                            "next_tbl_full": int,
 *                            "action_name": string
 *                            "table_name": string
 *                            "next_tbl": 0,
 *                            "--immediate--": [{
 *                                "PARAMSTART": int,
 *                                "PARAMSHIFT": int,
 *                                "DSTWIDTH": int,
 *                                "PARAMNAME": string
 *                                "PARAMVAL": int,
 *                                "PARAMTYPE": string
 *                                "DSTSTART": int,
 *                                "PARAMWIDTH": int
 *                            }]
 *                        }
 *                    }]
 *                }]
 *            }]
 *        }
 *
 *        "AdtEntryFormat": {
 *            "AllActionDataTables": [{
 *                "ActFuncTotalStageCount": int,
 *                "ActFuncTotalEntries": int,
 *                "ActionDataTableFormat": [{
 *                    "ActFuncStageCount": int,
 *                    "ActFuncHandle": int,
 *                    "Stage": int
 *                    "ActFuncFormat": [{
 *                        "ActFuncEntryCount": int,
 *                        "ActFuncEntryFormat": [{
 *                            "Entry": int,
 *                            "EntryFieldCount": int,
 *                            "EntryConstTupCount": int,
 *                            "EntryFormat": [{
 *                                "FIELDWIDTH": int,
 *                                "CONSTTUPLELIST": [{
 *                                    "DSTSTART": int,
 *                                    "CONSTANT": int,
 *                                    "DSTWIDTH": int
 *                                }],
 *                                "SOURCENAME": string
 *                                "SHIFT": int,
 *                                "WORDINDEX": int,
 *                                "MASKBITOFFSET": int,
 *                                "SOURCEOFFSET": int,
 *                                "FIELDNAME": string
 *                                "FIELDOFFSET": int,
 *                                "SOURCEWIDTH": int
 *                            }]
 *                        }],
 *                    }]
 *                }],
 *                "ActFuncHandleTotalCount": int,
 *                "ActFuncTotalEntryFieldCount": int,
 *                "ActFuncTotalConstTupleList": int,
 *                "ActionDataTableHandle": int
 *            }]
 *        }
 *
 *        "ExmEntryFormat": {
 *            "AllExmTables": [{
 *                "ExmTableHandle": int,
 *                "ExmTableName": string,
 *                "ExmMatchWayCount": int,
 *                "Stage": int
 *                "ExmTableFormat": [{
 *                    "ExmActionImmediateCount": int,
 *                    "ExmStageHandleCount": int,
 *                    "ExmMatchEntryFieldCount": int,
 *                    "ExmMatchEntryCount": int,
 *                    "ExmActionHandleCount": int,
 *                    "ExmMatchEntryFormat": [{
 *                        "MatchEntryFormat": [{
 *                            "EntryCount": int,
 *                            "Way": int
 *                            "WayFormat": [{
 *                                "Entry": int,
 *                                "EntryFieldCount": int,
 *                                "EntryFormat": [{
 *                                    "FIELDWIDTH": int,
 *                                    "MEMWORDOFFSET": [
 *                                        int,
 *                                        int
 *                                    ],
 *                                    "SOURCENAME": string,
 *                                    "PERFLOWENABLE": boolean,
 *                                    "SPECSTARTBIT": int,
 *                                    "FIELDSB": int,
 *                                    "MATCHMODE": string,
 *                                    "FIELDNAME": string,
 *                                    "FIELDOFFSET": int,
 *                                    "SPECLEN": int,
 *                                    "MATCHTYPE": string,
 *                                    "MSBIT": int,
 *                                    "IMMNAME": string
 *                                }],
 *                            }]
 *                        }],
 *                        "WayCount": int,
 *                        "StageHandle": int
 *                    }]
 *                    "ExmActionHandles": [{
 *                        "ImmediateCount": int,
 *                        "NEXTTBL": int,
 *                        "ACTION_HDL": int,
 *                        "IMMEDIATE": {
 *                            "instr": int,
 *                            "next_tbl_full": int,
 *                            "action_name": string,
 *                            "table_name": string,
 *                            "next_tbl": int,
 *                            "--immediate--": [{
 *                                "PARAMSTART": int,
 *                                "PARAMSHIFT": int,
 *                                "DSTWIDTH": int,
 *                                "PARAMNAME": string,
 *                                "PARAMVAL": int,
 *                                "PARAMTYPE": string,
 *                                "DSTSTART": int,
 *                                "PARAMWIDTH": int
 *                            }]
 *                        },
 *                        "INSTR": int
 *                    }],
 *                }]
 *            }]
 *        }
 *
 *        "TernEntryFormat": {
 *            "AllTernTables": [{
 *                "TernTableHandle": int,
 *                "TernTableName": string
 *                "TernTableFormat": [{
 *                    "TernRangeMaskCount": int,
 *                    "TernEntryFieldCount": int,
 *                    "Stage": int
 *                    "TernEntryFormat": [{
 *                        "Entry": int,
 *                        "EntryFieldCount": int,
 *                        "EntryFormat": [{
 *                            "STARTBIT": int,
 *                            "BITWIDTH": int,
 *                            "MEMWORDOFFSET": [
 *                                int,
 *                                int
 *                            ],
 *                            "MISC": {int, boolean},
 *                            "SRCOFFSET": int,
 *                            "FIELDNAME": string
 *                            "LOCATION": string,
 *                            "SRCLEN": int,
 *                            "MATCHTYPE": string,
 *                            "LSBMEMWORDOFFSET": int
 *                        }],
 *                    }],
 *                    "TernEntryCount": int,
 *                    "TernRangeMask": [{
 *                      "memids": [
 *                        int,
 *                      ],
 *                      "mask": int,
 *                      "wordindex": int
 *                    }],
 *                }]
 *            }],
 *        }
 *
 *        "DefaultEntryFormat": {
 *            "TotalTables": int,
 *            "DefaultEntries": [{
 *                "TotalActionHandles":  int
 *                "SelectorCount": int,
 *                "TableHandle": int,
 *                "LogicalId": int,
 *                "Stage": int
 *                "TotalActionFields": int,
 *                "Actions": [{
 *                    "ActionHandle": int,
 *                    "ActionFunction": {
 *                        "tbl_mask": int,
 *                        "next_tbl": int,
 *                        "tbl_name": string
 *                        "act_name": string
 *                        "instr": int
 *                    }
 *                }],
 *                "Immediate": [{
 *                    "ActionHandle": int
 *                    "ActionFunctionFields": [{
 *                        "PARAMSTART": int,
 *                        "PARAMSHIFT": int,
 *                        "DSTWIDTH": int,
 *                        "PARAMNAME": string
 *                        "PARAMVAL": int,
 *                        "PARAMTYPE": string
 *                        "DSTSTART": int,
 *                        "PARAMWIDTH": int
 *                    }]
 *                }],
 *            }],
 *        }
 *
 *
 *
 *
 *
 */

#ifndef __PIPE_MGR_ENTRY_FORMAT_JSON__
#define __PIPE_MGR_ENTRY_FORMAT_JSON__

#include <target-utils/third-party/cJSON/cJSON.h>
#include <pipe_mgr/pipe_mgr_err.h>

typedef enum {
  // Exm/Tind fields
  TBL_PKG_FIELD_SOURCE_VERSION = 0,
  TBL_PKG_FIELD_SOURCE_ZERO,
  TBL_PKG_FIELD_SOURCE_SPEC,
  TBL_PKG_FIELD_SOURCE_SELPTR,
  TBL_PKG_FIELD_SOURCE_ADTPTR,
  TBL_PKG_FIELD_SOURCE_INSTR,
  TBL_PKG_FIELD_SOURCE_NXT_TBL,
  TBL_PKG_FIELD_SOURCE_IMMEDIATE,
  TBL_PKG_FIELD_SOURCE_METERPTR,
  TBL_PKG_FIELD_SOURCE_STATSPTR,
  TBL_PKG_FIELD_SOURCE_STFLPTR,
  TBL_PKG_FIELD_SOURCE_SELLEN,
  TBL_PKG_FIELD_SOURCE_SELLENSHIFT,
  TBL_PKG_FIELD_SOURCE_PROXYHASH,
  TBL_PKG_FIELD_SOURCE_CONSTANT,
  // Ternary fields
  TBL_PKG_TERN_FIELD_LOCATION_ZERO,
  TBL_PKG_TERN_FIELD_LOCATION_PARITY,
  TBL_PKG_TERN_FIELD_LOCATION_PAYLOAD,
  TBL_PKG_TERN_FIELD_LOCATION_VERSION,
  TBL_PKG_TERN_FIELD_LOCATION_RANGE,
  TBL_PKG_TERN_FIELD_LOCATION_SPEC,

  // Used by phase0 table
  TBL_PKG_PHASE0_FIELD_LOCATION_SPEC,
  TBL_PKG_PHASE0_FIELD_LOCATION_CONSTANT,

  // Keep it last.
  TBL_PKG_FIELD_SOURCE_INVALID = 255
} pipemgr_tbl_pkg_match_field_source_en;

typedef enum {
  TBL_PKG_FIELD_MATCHMODE_S1Q0 = 0,
  TBL_PKG_FIELD_MATCHMODE_S0Q1,
  TBL_PKG_FIELD_MATCHMODE_INVALID
} pipemgr_tbl_pkg_match_field_matchmode_en;

typedef enum {
  TBL_PKG_FIELD_MATCHTYPE_EXACT,
  TBL_PKG_FIELD_MATCHTYPE_LPM,
  TBL_PKG_FIELD_MATCHTYPE_TERNARY,
  TBL_PKG_FIELD_MATCHTYPE_RANGE,
  TBL_PKG_FIELD_MATCHTYPE_INVALID
} pipemgr_tbl_pkg_match_field_matchtype_en;

/* ------  Action-Handle data structures  ----- */
/* Reverse mapping of action function handle to  mat-tbl-hdl
 * from where action spec and match spec can be decoded/print
 */

/* ------  Phase0 Table related data structures  ----- */

typedef struct pipemgr_tbl_pkg_phase0_action_field_t_ {
  uint32_t fieldname_str_index;
  uint16_t param_start;
  uint16_t param_width;
  uint16_t param_shift;
  uint32_t memword_index[2];  // (LSB memory word index, MSB memory word index)
  uint32_t constant_value;
  uint16_t lsbmemwordoffset;
  uint16_t fieldwidth;
  uint8_t location;
} pipemgr_tbl_pkg_phase0_action_field_t;

typedef struct pipemgr_tbl_pkg_phase0_match_field_t_ {
  uint8_t match_type;
  uint16_t startbit;
  uint32_t fieldname_str_index;
  uint8_t fieldwidth;
} pipemgr_tbl_pkg_phase0_match_field_t;

typedef struct pipemgr_tbl_pkg_phase0_action_entry_t_ {
  uint8_t entry;
  uint8_t fieldcount;
  pipemgr_tbl_pkg_phase0_action_field_t *actionfields;
} pipemgr_tbl_pkg_phase0_action_entry_t;

typedef struct pipemgr_tbl_pkg_phase0_action_t_ {
  uint8_t totalfields;
  uint8_t totalentries;
  pipemgr_tbl_pkg_phase0_action_entry_t *entry;
} pipemgr_tbl_pkg_phase0_action_t;

typedef struct pipemgr_tbl_pkg_phase0_match_t_ {
  uint8_t fieldcount;
  pipemgr_tbl_pkg_phase0_match_field_t *matchfields;
} pipemgr_tbl_pkg_phase0_match_t;

/* ------  Exm and TIND related data structures  ----- */

typedef struct pipemgr_tbl_pkg_action_parameter_field_t_ {
  uint32_t stringindex;  // unique action-name identifier.
  uint16_t start_offset;
  uint16_t bit_width;
  uint8_t is_parameter; /* 1 if parameter, 0 if constant/immediate */
  uint16_t param_start;
  uint16_t param_width;
  uint16_t param_shift;
  uint32_t constant_value;
  bool is_mod_field_conditionally_mask;
  bool is_mod_field_conditionally_value;
  uint16_t mask_offset;
  uint16_t mask_width;
} pipemgr_tbl_pkg_action_parameter_field_t;

typedef struct pipemgr_tbl_pkg_action_entry_field_t_ {
  uint32_t stringindex;  // unique identifier for action-name
  uint32_t action_handle;
  uint16_t instr;
  uint8_t next_tbl;
  uint8_t param_count;
  bool default_action;
  bool force_stats_pfe_set;
  bool force_meter_pfe_set;
  bool force_stful_pfe_set;
  bool force_stats_addr;
  bool force_meter_addr;
  bool force_stful_addr;
  uint32_t forced_full_stats_addr;
  uint32_t forced_full_meter_addr;
  uint32_t forced_full_stful_addr;
  pipemgr_tbl_pkg_action_parameter_field_t *act_param;
} pipemgr_tbl_pkg_action_entry_field_t;

typedef struct pipemgr_tbl_pkg_action_hndls_t_ {
  uint8_t action_hdl_count;
  pipemgr_tbl_pkg_action_entry_field_t *action_hdl;
} pipemgr_tbl_pkg_action_handles_t;

typedef struct pipemgr_tbl_pkg_match_entry_field_t_ {
  uint32_t stringindex;  // unique field-name identifier.
  uint8_t source;
  uint16_t msbit;
  uint8_t perflow;
  uint8_t immediate;        // If 1, indicates presence of immediate value
  uint16_t field_width;     // width/sub-width of match field inside RAM/HW.
                            // It can be sub-width or less than field width
                            // when compiler decides to break a P4 field
                            // non contiguously and scatter RAM bit allocation.
  uint16_t field_offset;    // Offset where field starts in HW/RAM line
  uint16_t fieldsb;         // source byte
  uint16_t spec_start_bit;  // Start bit position in match-spec.
  uint16_t spec_len;  // match field length. Can be greater than field_width
  uint16_t match_mode;
  uint8_t per_flow_color_aware;
  uint8_t per_flow_color_aware_bit_pos;
  uint32_t memword_index[2];  // (LSB memory word index, MSB memory word index)
} pipemgr_tbl_pkg_match_entry_field_t;

typedef struct pipemgr_tbl_pkg_match_entry_line_t_ {
  uint8_t entry;
  uint8_t field_count;
  pipemgr_tbl_pkg_match_entry_field_t *fields;  // Zero length array
                                                // would be better.
                                                // C99 discourages.
} pipemgr_tbl_pkg_match_entry_line_t;

typedef struct pipemgr_tbl_pkg_match_entry_format_t_ {
  uint8_t entry_count;
  uint16_t total_fields_in_all_entries;  // across all entries
  pipemgr_tbl_pkg_match_entry_line_t *entry_pkg;
} pipemgr_tbl_pkg_match_entry_format_t;

// Used only by EXM tables
typedef struct pipemgr_tbl_pkg_way_format_t_ {
  uint8_t way;
  pipemgr_tbl_pkg_match_entry_format_t *entry_format;
} pipemgr_tbl_pkg_way_format_t;

// Used only by EXM tables
typedef struct pipemgr_tbl_pkg_exm_stage_hdl_format_t_ {
  uint8_t way_count;
  uint8_t stage_handle;
  uint16_t total_fields_in_all_ways;   // across all entries and ways
  uint16_t total_entries_in_all_ways;  // across all ways
  uint8_t stash_way_count;
  uint16_t stash_total_fields_in_all_ways;   // across all entries and ways
  uint16_t stash_total_entries_in_all_ways;  // across all ways
  pipemgr_tbl_pkg_way_format_t *way_pkg;
  pipemgr_tbl_pkg_way_format_t *stash_way_pkg;
} pipemgr_tbl_pkg_exm_stage_hdl_format_t;

// Used only by EXM tables
typedef struct pipemgr_tbl_pkg_exm_format_t_ {
  uint8_t stage_handle_count;
  pipemgr_tbl_pkg_exm_stage_hdl_format_t *stg_hdl;
} pipemgr_tbl_pkg_exm_format_t;

/* ------  Tern table related data structures  ----- */

#define TBL_PKG_MAX_DEPTH_TCAM_UNITS (24)

typedef struct pipemgr_tbl_pkg_tern_range_mask_t_ {
  uint8_t word_index;
  uint64_t mask;
  uint8_t memids[TBL_PKG_MAX_DEPTH_TCAM_UNITS];
} pipemgr_tbl_pkg_tern_range_mask_t;

typedef struct pipemgr_tbl_pkg_tern_entry_field_t_ {
  uint32_t stringindex;       // unique field-name identifier.
  uint32_t memword_index[2];  // (LSB memory word index, MSB memory word index)
  uint16_t lsbmemwordoffset;
  uint16_t bitwidth;
  uint8_t location;  // pipemgr_tbl_pkg_match_field_source_en
  uint16_t srcoffset;
  uint16_t src_len;
  uint16_t startbit;
  uint8_t match_type;
  uint8_t range_type;
  uint8_t range_nibble_offset;
  bool range_hi_byte;
} pipemgr_tbl_pkg_tern_entry_field_t;

typedef struct pipemgr_tbl_pkg_tern_entry_t_ {
  uint8_t entry;
  uint8_t entryfieldcount;  // total field count in this entry
  pipemgr_tbl_pkg_tern_entry_field_t *field;
} pipemgr_tbl_pkg_tern_entry_t;

typedef struct pipemgr_tbl_pkg_tern_tbl_t_ {
  // handle, stage are in LUT
  uint8_t entrycount;    // total entries in this stage
  uint32_t totalfields;  // total fields for this stage
  uint8_t rangemaskcount;
  pipemgr_tbl_pkg_tern_range_mask_t *rangeformat;  // per table, per stage
                                                   // range mask
  pipemgr_tbl_pkg_tern_entry_t *entry;
} pipemgr_tbl_pkg_tern_tbl_t;

/* ------  Action Data table related data structures  ----- */

// Entries that get populated into Action Data Table
typedef struct pipemgr_tbl_pkg_act_fn_field_constvalues_t_ {
  uint32_t dststart;
  uint32_t dstwidth;
  uint32_t constvalue;  // use uint16_t if dstwidth is < 16bits ??
} pipemgr_tbl_pkg_act_fn_field_constvalues_t;

// Entries that get populated into Action Data Table
typedef struct pipemgr_tbl_pkg_act_fn_entry_field_t_ {
  uint32_t stringindex;  // unique field-name identifier.
  uint8_t source;        // zero, constant, spec,
  uint16_t word_index;
  uint16_t field_offset;
  uint16_t field_width;
  uint16_t source_offset;
  uint16_t source_width;
  uint16_t shift;
  bool is_mod_field_conditionally_mask;
  bool is_mod_field_conditionally_value;
  uint16_t mask_offset;
  uint16_t mask_width;
  uint8_t constvalue_count;
  pipemgr_tbl_pkg_act_fn_field_constvalues_t *constvalues;
} pipemgr_tbl_pkg_act_fn_entry_field_t;

typedef struct pipemgr_tbl_pkg_act_fn_entry_t_ {
  uint8_t entry;
  uint8_t entryfieldcount;   // total field count in this entry
  uint8_t totalconsttuples;  // total consttuples in this entry
  pipemgr_tbl_pkg_act_fn_entry_field_t *field;
} pipemgr_tbl_pkg_act_fn_entry_t;

typedef struct pipemgr_tbl_pkg_act_fn_stage_format_t_ {
  uint8_t stage;
  uint8_t entrycount;         // total entries in this stage
  uint32_t totalconsttuples;  // total tuples for this stage
  uint32_t totalfields;       // total fields for this stage
  pipemgr_tbl_pkg_act_fn_entry_t *entry;
} pipemgr_tbl_pkg_act_fn_stage_format_t;

typedef struct pipemgr_tbl_pkg_act_fn_handle_t_ {
  uint32_t actfunchandle;
  uint8_t stagecount;
  uint32_t totalconsttuples;  // total tuples for this action-function
  uint32_t totalfields;       // total fields for this action-function
  uint32_t totalentries;      // total entries for this action-function
  pipemgr_tbl_pkg_act_fn_stage_format_t *stageformat;
} pipemgr_tbl_pkg_act_fn_handle_t;

typedef struct pipemgr_tbl_pkg_adt_t_ {
  uint8_t act_fn_hdl_count;
  pipemgr_tbl_pkg_act_fn_handle_t *hdl;
} pipemgr_tbl_pkg_adt_t;

/* ------  Default Entries related data structures  ----- */

typedef struct pipemgr_tbl_pkg_default_action_param_t_ {
  uint32_t action_fn_handle;
  uint8_t act_param_count;
  pipemgr_tbl_pkg_action_parameter_field_t *act_field;
} pipemgr_tbl_pkg_default_action_param_t;

typedef struct pipemgr_tbl_pkg_default_action_fn_t_ {
  uint32_t action_fn_handle;
  uint32_t next_tbl_exec;
  uint16_t tbl_mask;
  uint16_t next_tbl_default;
  uint16_t next_tbl;
  uint16_t instr;
  uint8_t next_tbl_long_branch;


  uint32_t string_index;          // index to get action function name
  bool force_stats_pfe_set;
  bool force_meter_pfe_set;
  bool force_stful_pfe_set;
  bool force_stats_addr;
  bool force_meter_addr;
  bool force_stful_addr;
  uint32_t forced_full_stats_addr;
  uint32_t forced_full_meter_addr;
  uint32_t forced_full_stful_addr;
} pipemgr_tbl_pkg_default_action_fn_t;

typedef struct pipemgr_tbl_pkg_default_entry_t_ {
  uint16_t totalactionhandles;
  uint8_t logicalid;

  uint8_t selectorcount;
  uint8_t stage;
  pipemgr_tbl_pkg_default_action_fn_t *actions;
  pipemgr_tbl_pkg_default_action_param_t *act_param;
} pipemgr_tbl_pkg_default_entry_t;

/* ------  matchspec and actionspec related data structures  ----- */
typedef struct pipemgr_tbl_pkg_spec_field_t_ {
  uint32_t fieldname_str_index;
  uint16_t fieldwidth;
  uint16_t startbit;
  uint8_t match_type;
} pipemgr_tbl_pkg_spec_field_t;

typedef struct pipemgr_tbl_pkg_spec_t_ {
  uint8_t fieldcount;
  pipemgr_tbl_pkg_spec_field_t *fields;
} pipemgr_tbl_pkg_spec_t;

typedef struct pipemgr_tbl_pkg_action_spec_t_ {
  uint32_t actionfunc_name_str_index;
  uint8_t fieldcount;
  pipemgr_tbl_pkg_spec_field_t *fields;
} pipemgr_tbl_pkg_action_spec_t;

/* ------  range table related data structures  ----- */
typedef struct pipemgr_tbl_pkg_rangetbl_mau_field_t_ {
  uint16_t fieldwidth;
  uint16_t startbit;
} pipemgr_tbl_pkg_rangetbl_mau_field_t;

typedef struct pipemgr_tbl_pkg_rangetbl_field_t_ {
  uint32_t fieldname_str_index;
  uint8_t maufieldcount;
  uint16_t param_fieldwidth;
  uint16_t param_startbit;
  pipemgr_tbl_pkg_rangetbl_mau_field_t *maufields;
} pipemgr_tbl_pkg_rangetbl_field_t;

typedef struct pipemgr_tbl_pkg_rangetbl_t_ {
  uint8_t fieldcount;
  pipemgr_tbl_pkg_rangetbl_field_t *fields;
} pipemgr_tbl_pkg_rangetbl_t;

/* ------  Learn quanta related data structures  -----  */
typedef struct pipemgr_tbl_pkg_lq_field_t_ {
  uint32_t fieldname_str_index;
  uint16_t fieldwidth;
  uint16_t totalfieldwidth;
  uint16_t phvoffset;
  uint16_t startbit;
  uint16_t byteoffset;
} pipemgr_tbl_pkg_lq_field_t;

typedef struct pipemgr_tbl_pkg_lq_t_ {
  uint8_t fieldcount;
  uint8_t lq_cfg_type;
  uint32_t lq_name_str_index;
  uint16_t lrn_cfg_type_sz;
  uint32_t handle;
  pipemgr_tbl_pkg_lq_field_t *fields;
} pipemgr_tbl_pkg_lq_t;

/* ------   Snap shot related data structures  -----  */

typedef struct pipemgr_tbl_pkg_logical_table_details_t_ {
  uint16_t logical_id;
  uint8_t direction;
  bool table_type_tcam;
  uint8_t inuse_physical_buses;
  uint8_t physical_buses[32];  // Will a logical table use more than 32 buses ??
  uint32_t tablename_str_index;
  uint8_t stage;
  uint16_t tcam_addr_shift;
  uint32_t table_handle;
  bool has_attached_gateway;
} pipemgr_tbl_pkg_logical_table_details_t;

typedef struct pipemgr_tbl_pkg_snapshot_pov_t_ {
  // Max width of PHV is 32... Use macro
  uint8_t pov_bit_count;           // how many out of 32 are valid.
  uint8_t pov_bit[32];             // Bit index within the container.
  uint32_t pov_hdr_str_index[32];  // Index to g_tbl_pkg_ctx[]->p4_strings array
                                   // which holds the header name this POV bit
                                   // is for.
  uint16_t position_offset[32];    // Byte position with PD struct
  bool hidden[32];
} pipemgr_tbl_pkg_snapshot_pov_t;

typedef enum {
  PIPE_MGR_NORMAL_PHV = 0,
  PIPE_MGR_MOCHA_PHV,
  PIPE_MGR_DARK_PHV,
  PIPE_MGR_UNKNOWN_PHV
} pipe_mgr_phv_type_en;
typedef struct pipemgr_tbl_pkg_snapshot_phv_t_ {
  uint16_t phvnumber;
  uint8_t direction;
  uint16_t fieldwidth;
  uint16_t fieldlsb;
  uint16_t fieldmsb;
  uint16_t phvlsb;
  uint16_t phvmsb;
  uint8_t container_width;
  pipe_mgr_phv_type_en container_type;
  uint32_t phvname_str_index;
  uint16_t position_offset;  // When phvs are collected together for
                             // for creating trigger spec or when
                             // snapshot captured data is to be
                             // fetched, this value indicates offset
                             // within byte array where data is stored.
  // If PHV is container of POV bits, pov_hdrs will NOT
  // be NULL.
  pipemgr_tbl_pkg_snapshot_pov_t *pov_hdrs;
} pipemgr_tbl_pkg_snapshot_phv_t;

typedef struct pipemgr_tbl_pkg_snapshot_t_ {
  uint16_t total_phv_recs;
  uint16_t total_pov_hdrs;
  uint16_t total_tables;  // logical tables
  pipemgr_tbl_pkg_snapshot_phv_t *phv_recs;
  pipemgr_tbl_pkg_snapshot_pov_t *pov_hdrs;
  pipemgr_tbl_pkg_logical_table_details_t *tables;
} pipemgr_tbl_pkg_snapshot_t;

/* -- Lookup Tables; maintained one per EXM, TIND, ADT, TERN, Default, ... */

/* LookupIndex = BobJenkinHash(table-handle, stage) */
typedef struct pipemgr_tbl_pkg_lut_ {
  uint32_t tbl_hndl;
  uint8_t stage;
  uint16_t match_field_mem_size; /* this value
                                  * helps to jump to memory area
                                  * where action paramter details
                                  * are stored. Used in EXM and TIND tables.
                                  */
  union {
    pipemgr_tbl_pkg_match_entry_format_t *tind_ptr;
    pipemgr_tbl_pkg_exm_format_t *exm_ptr;
    pipemgr_tbl_pkg_adt_t *adt_ptr;
    pipemgr_tbl_pkg_tern_tbl_t *tern_ptr;
    pipemgr_tbl_pkg_default_entry_t *dft_ptr;
    pipemgr_tbl_pkg_phase0_match_t *phase0_match_ptr;
    pipemgr_tbl_pkg_phase0_action_t *phase0_action_ptr;
    pipemgr_tbl_pkg_spec_t *matchspec_ptr;
    pipemgr_tbl_pkg_action_spec_t *actionspec_ptr;
    pipemgr_tbl_pkg_lq_t *lq_ptr;
    pipemgr_tbl_pkg_rangetbl_t *rangetbl_ptr;
    pipemgr_tbl_pkg_snapshot_t *snapshot_ptr;
  } u;
} pipemgr_tbl_pkg_lut_t;

/* ----  Table Packing Context maintained one per device ---- */

#define PIPEMGR_TBL_PKG_MAX_P4_FIELD_NAMES (50000)

typedef struct pipemgr_tbl_pkg_prof_ctx_ {
  pipemgr_tbl_pkg_lut_t *exm_lut;
  pipemgr_tbl_pkg_lut_t *tern_lut;
  pipemgr_tbl_pkg_lut_t *tind_lut;
  pipemgr_tbl_pkg_lut_t *adt_lut;
  pipemgr_tbl_pkg_lut_t *dft_lut;
  pipemgr_tbl_pkg_lut_t *phase0_match_lut;
  pipemgr_tbl_pkg_lut_t *phase0_action_lut;
  pipemgr_tbl_pkg_lut_t *matchspec_lut;
  pipemgr_tbl_pkg_lut_t *actionspec_lut;
  pipemgr_tbl_pkg_lut_t *rangetbl_lut;
  pipemgr_tbl_pkg_lut_t *lq_lut;
  pipemgr_tbl_pkg_lut_t *snapshot_lut;
  uint16_t exm_lut_depth;
  uint16_t tern_lut_depth;
  uint16_t tind_lut_depth;
  uint16_t adt_lut_depth;
  uint16_t dft_lut_depth;
  uint16_t phase0_action_lut_depth;
  uint16_t phase0_match_lut_depth;
  uint16_t matchspec_lut_depth;
  uint16_t actionspec_lut_depth;
  uint16_t rangetbl_lut_depth;
  uint16_t lq_lut_depth;
  uint16_t snapshot_lut_depth;
  int exm_lut_collision_count;
  int tern_lut_collision_count;
  int tind_lut_collision_count;
  int adt_lut_collision_count;
  int dft_lut_collision_count;
  int phase0_match_lut_collision_count;
  int phase0_action_lut_collision_count;
  int matchspec_lut_collision_count;
  int actionspec_lut_collision_count;
  int rangetbl_lut_collision_count;
  int lq_lut_collision_count;
  int snapshot_lut_collision_count;
  uint16_t total_exm_tbl;
  uint16_t total_tern_tbl;
  uint16_t total_tind_tbl;
  uint16_t total_adt_tbl;
  uint16_t total_dft_entries;
  uint16_t total_phase0_tbls;
  uint16_t total_actionspec_tbls;
  uint16_t total_matchspec_tbls;
  uint16_t total_rangetbls;
  uint16_t total_lqs;
  uint16_t total_snapshot_stages;
  uint32_t field_name_str_index;  // Monotonically increasing index that is used
  // to index into array of field-names, action-names,..
  char *p4_strings[PIPEMGR_TBL_PKG_MAX_P4_FIELD_NAMES];  // array of p4 program
  // strings (field names, table names etc)
} pipemgr_tbl_pkg_profile_ctx_t;

typedef struct pipemgr_tbl_pkg_ctx_ {
  uint32_t num_profiles;
  pipemgr_tbl_pkg_profile_ctx_t *profiles;
} pipemgr_tbl_pkg_ctx_t;

pipe_status_t pipemgr_tbl_pkging_init(bf_dev_id_t, uint32_t num_profiles);
void pipemgr_tbl_pkging_cleanup(bf_dev_id_t devid);

#endif
