/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/

#include <algorithm>
#include <fstream>
#include <iomanip>
#include <iostream>
#include <iostream>
#include <map>
#include <set>
#include <sstream>

#include <ctype.h>
#include <getopt.h>
#include <string.h>
#include <unistd.h>

#include "bf_switch/bf_switch_types.h"
#include "s3/meta/meta.h"

using namespace std;
using namespace smi;

namespace {
/*
void string_to_upper(string &s) {
  transform(s.begin(),
            s.end(),
            s.begin(),
            [](unsigned char c) { return toupper(c); });
}
*/
void string_to_lower(string &s) {
  transform(s.begin(), s.end(), s.begin(), [](unsigned char c) {
    return tolower(c);
  });
}
void usage(int argc, char *argv[]) {
  (void)argc;
  (void)argv;
  cout << "Usage: enum_gen"
       << " --input <model_filename> --output <header_filename>"
       << " [--prefix <enum_prefix>]"
       << " [--v verbose] \n";
}

int parse_options(int argc,
                  char **argv,
                  std::string &input_file,
                  std::string &output_file,
                  std::string &enum_prefix,
                  bool *verbose) {
  while (1) {
    int option_index = 0;
    /* Options without short equivalents */
    enum long_opts {
      OPT_START = 256,
      OPT_INPUT,
      OPT_OUTPUT,
      OPT_PREFIX,
    };
    static struct option long_options[] = {
        {"help", no_argument, 0, 'h'},
        {"input", required_argument, 0, OPT_INPUT},
        {"output", required_argument, 0, OPT_OUTPUT},
        {"prefix", required_argument, 0, OPT_PREFIX},
        {"verbose", no_argument, 0, 'v'},

        {0, 0, 0, 0}};
    int c = getopt_long(argc, argv, "h", long_options, &option_index);
    if (c == -1) {
      break;
    }
    switch (c) {
      case OPT_INPUT:
        input_file = optarg;
        break;
      case OPT_OUTPUT:
        output_file = optarg;
        break;
      case OPT_PREFIX:
        enum_prefix = optarg;
        break;
      case 'v':
        *verbose = true;
        break;
      case 'h':
      case '?':
        usage(argc, argv);
        return c == 'h' ? 1 : 0;
        break;
    }
  }
  return 0;
}
}  // namespace
int main(int argc, char *argv[]) {
  std::string input_file;
  std::string output_file;
  std::string enum_prefix;
  char empty_string[] = "";
  ofstream of;
  bool verbose = false;
  int rv =
      parse_options(argc, argv, input_file, output_file, enum_prefix, &verbose);
  if (rv != 0) return rv;

  std::unique_ptr<ModelInfo> model_info =
      build_model_info_from_file(input_file.c_str(), verbose);
  if (model_info == nullptr) {
    return -1;
  }

  if (enum_prefix.empty()) {
    enum_prefix = empty_string;
  }

  of.open(output_file.c_str());

  of << "/* THIS FILE IS AUTOGENERATED. DO NOT MODIFY MANUALLY! "
        "*/\n\n";
  uint32_t model_version = model_info->get_version();
  of << "/* model version: " << model_version << " */\n\n";

  of << "#ifndef __" << enum_prefix << "MODEL_H__\n#define __" << enum_prefix
     << "MODEL_H__\n\n";

  of << "/** @defgroup obj_model BF_SMI object model\n";
  of << " * Generated header file from the model schema\n";
  of << " * @{\n";
  of << " */\n\n";

  /* enums: objects */
  stringstream obj_buffer;
  /* enums: attributes */
  stringstream attr_buffer;
  /* enums: values */
  stringstream val_buffer;
  /* ot -> string buffer */
  stringstream ot_string_buffer;
  /* attr -> string buffer */
  stringstream attr_string_buffer;

  ot_string_buffer << "static const char * ot_to_str(unsigned long int ot) {\n";
  ot_string_buffer << "  switch (ot) {\n";
  attr_string_buffer
      << "static const char * attr_to_str(unsigned long int attr) {\n";
  attr_string_buffer << "  switch (attr) {\n";

  for (auto it = model_info->begin(); it != model_info->end(); it++) {
    ObjectInfo object_info = *it;

    string object_name_fqn(object_info.get_object_name_fqn());

    obj_buffer << "#define " << enum_prefix << object_name_fqn << " "
               << object_info.object_type << "\n";

    ot_string_buffer << "    case " << enum_prefix << object_name_fqn << ":\n";
    ot_string_buffer << "      return \"" << enum_prefix << object_name_fqn
                     << "\";\n";

    std::vector<AttributeMetadata> attr_md_list =
        object_info.get_attribute_list();
    for (const auto &attr_md : attr_md_list) {
      string attr_name_fqn(attr_md.get_attr_name_fqn());

      attr_buffer << "#define " << enum_prefix << attr_name_fqn << " "
                  << attr_md.attr_id << "\n";
      attr_string_buffer << "    case " << enum_prefix << attr_name_fqn
                         << ":\n";
      attr_string_buffer << "      return \"" << enum_prefix << attr_name_fqn
                         << "\";\n";

      if (attr_md.type == SWITCH_TYPE_ENUM ||
          (attr_md.type == SWITCH_TYPE_LIST &&
           attr_md.get_value_metadata()->type == SWITCH_TYPE_ENUM)) {
        const ValueMetadata *value_md = attr_md.get_value_metadata();
        string attr_name_fqn_lower(attr_name_fqn);
        string_to_lower(attr_name_fqn_lower);
        string enum_prefix_lower(enum_prefix);
        string_to_lower(enum_prefix_lower);
        val_buffer << "\ntypedef enum _" << enum_prefix_lower
                   << attr_name_fqn_lower << " {\n";
        std::vector<EnumMetadata> enums = value_md->get_enum_metadata();
        for (auto &enumdata : enums) {
          string val_name(enumdata.enum_name_fqn);
          val_buffer << "  " << enum_prefix << val_name << " = "
                     << enumdata.enum_value << ",\n";
        }
        val_buffer << "  " << enum_prefix << attr_name_fqn << "_MAX,\n";
        val_buffer << "} " << enum_prefix_lower << attr_name_fqn_lower << ";\n";
      }
    }
  }

  ot_string_buffer << "    default:\n";
  ot_string_buffer << "      return \"Invalid object type\";\n";
  ot_string_buffer << "  }\n"
                   << "}\n";
  attr_string_buffer << "    default:\n";
  attr_string_buffer << "      return \"Invalid attribute type\";\n";
  attr_string_buffer << "  }\n"
                     << "}\n";

  of << obj_buffer.str();
  of << attr_buffer.str();
  of << val_buffer.str();
  // Leaving these out since they are not used anywhere
  // of << ot_string_buffer.str();
  // of << attr_string_buffer.str();

  of << "/** @} */\n";
  of << "\n#endif  // __" << enum_prefix << "MODEL_H__";
  of.close();
  return 0;
}
