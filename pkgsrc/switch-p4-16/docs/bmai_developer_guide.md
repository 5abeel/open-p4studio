# BMAI Developer Guide

## Revision
| Rev  | Rev Date   | Author(s)          | Change Description |
|------|------------|--------------------|--------------------|
| v0.1 | 08/11/2021 | Ravi Vantipalli    | Initial version    |
| v0.2 | 08/25/2021 | Ravi Vantipalli    | concurrency section|

## Table of Contents
- [Scope](#scope)
- [Overview](#overview)
  - [Features](#features)
  - [Stateful Dependencies](#stateful-dependencies)
  - [Example](#example)
- [Design](#design)
  - [Components](#components)
- [Schema](#schema)
- [Details](#details)
  - [Object Tags](#object-tags)
  - [Attribute Tags](#attribute-tags)
  - [model.h](#model-h)
- [Store](#store)
  - [DB Store](#db-store)
  - [Secondary Index](#secondary-index)
  - [Object Graph](#object-graph)
- [Life of an object](#life-of-an-object)
- [Data Structures](#data-structures)
  - [Object class](#object-class)
  - [Auto Object class](#auto-object-class)
  - [p4_object class](#p4_object-class)
  - [Triggers](#triggers)
  - [BFRT backend](#bfrt-backend)
  - [Recommendation](#recommendation)
- [Concurrency model](#concurrency-model)
- [CLI](#cli)
- [Code auto-generation](#code-auto-generation)
- [S3 Code flow](#s3-code-flow)
- [Sample Object](#sample-object)
  - [User object](#user-object)
  - [Auto object](#auto-object)
  - [P4 code](#p4-code)
  - [Implementation](#implementation)
- [SAI](#sai)

## Scope
This document describes the BMAI and S3 frameworks used to generate control plane APIs for a P4 program.

## Overview
BMAI, short for Barefoot Model-Driven Abstraction Interface, provides an infrastructure for developers to create their own higher-level object abstractions of P4 constructs and automatically generate APIs which can be used by the control plane to configure those objects. BMAI helps developers create well-designed, efficient APIs to program a network.

### Features
Objects are any entities which can be user configurable. In the networking world, a vlan or a route is treated as an object. An object can hold a set of attributes which describe various properties of this object. For a vlan object, examples of attributes are learning, flooding, aging, etc or more complex attributes like list of vlan_members or other object IDs.

* BMAI is a framework to create object state.
* It maintains a relationship graph between objects in a stateful manner.
* It can be used to create and attach subscribers to each object and its attributes.
* Trigger events on the subscribers based on the stateful graph and object state.

The objects are exposed to the framework via a structured JSON schema. The schema can be used to define a set of objects and the relationship between them through a pre-defined specification. This specification is well understood by the framework and is transformed into a dependency graph upon consumption.
Objects have attributes, and these attributes return a specific type of data. For a route object, the IP address can be stored and retrieved as a String, the vrf ID can be an integer, etc.

Note: Although BMAI is developed to serve the needs of a data plane application and the corresponding network primitives, it can also be used as a standalone library which other applications can use to store state, generate CLI, etc.

### Stateful Dependencies
The dependencies between various objects are maintained in a graph like structure. This enables the framework to enable various events based on pre-compiled triggers. These dependencies also ensure the objects are not inadvertently deleted when they are depended on by other objects.

### Example
The best use case for BMAI is when it is used to facilitate the interaction between the user object and its subscribers. This will be explained using a "vehicle" object as an example. A vehicle can start, stop and change gears if it is a manual transmission system. We state these properties as attributes.
```
"vehicle" : {
    "type": {
        "type": list
        [ "manual", "automatic" ]
    "start" : {
        "type": bool
    },
    "stop" : {
        "type": bool
    },
    "gear" : {
        "type": list
        [ "first", "second", "third" ]
    }
}
```
An API user can now create any number of vehicles from the above types. The object's attributes can later be modified also.

We also specify subscriber objects which will react to changes in the vehicle. Assuming the truck is manual and the sedan is automatic, the gear attribute does not apply to the sedan. Hence, the sedan does not subscribe to changes of the gear.
```json
"truck" : {
    "observe" : "vehicle",
    "subscribe" : [ "start", "stop", "gear" ]
}
"sedan" : {
    "observe" : "vehicle",
    "subscribe" : [ "start", "stop" ]
}
```

At this point the dependency graph generated by the framework can be visualized like below. In the classic observer OOP design pattern, the vehicle could be described as the subject and the truck/sedan objects are the observers.


                 Fire event                     Fire event
          ------------------------        ----------------------
          |                      |        |                    |
          \/                     |        |                   \/
    ------------             ----------------            ------------
    |          |             |              |            |          |
    |   truck  |------------>|    vehicle   |<-----------|  sedan   |
    |          |  subscribe  |              |  subscribe |          |
    ------------             ----------------            ------------


**Things to note**
* The framework creates a total of 3 object handles in the data store. One for the vehicle object and one each for the subscriber objects. Every object can be accessed using the CRUD APIs by passing in the handle.
* The developer defines the behavior of the subscriber objects.
* The classes defined above are stateless. They are not persistent. They are invoked when events are triggered, perform a data transformation and get cleaned up.

## Design
The underlying framework of BMAI is called the Simple State Service or "S3". The below diagram explains the various components in S3. It consists of the S3 API, schema parser, dependency graph and the backend used to communicate with Bf-runtime. The JSON schema, table object library and the APIs are the only components that are not necessarily part of S3 and rather use S3 as their underlying service.

                      /+++++++++\
                      |   SAI   |
                      \+++++++++/
                           |
                  +-----------------+
     /++++++++\   |                 |   /+++++\
     | Thrift |-->|    Public API   |<--| CLI |
     \++++++++/   |                 |   \+++++/
                  +-----------------+
                           |
                  +-----------------+        +----------------+
                  |                 |  uses  |   Dependency   |
                  |        S3       |------->|     Graph      |
                  |                 |        +----------------+
                  +-----------------+                 /\
                           |                          | populate
                           |                          |
                  /-----------------\         +---------------+
                  |       P4        |         |               |
                  |    Specific     |         | Schema Parser |
                  |  Implementation |         |               |
                  \-----------------/         +---------------+
                           |                    /\         /\
                   +-------------+              /           \
                   |             |             /             \
                   |  BF-Runtime |     +-------------+    +-------------+
                   |             |     |             |    |             |
                   +-------------+     | switch.json |    | new_p4.json |
                                       |             |    |             |
                                       +-------------+    +-------------+

### Components

- Schema: A simple description of an object model. This is consumed at runtime and used for all operations. It is also consumed at compile time to generate non-generic APIs. This model lists all the user and auto objects and their relationship. This schema also serves as the base for CLI generation, API adaptors, template generators and PTF libraries in SMI.
  - It is important to note that an auto JSON object does not describe a P4 table but only acts as a reference to the table.
- Parser: A generic JSON parser which reads the schema file and generates a dependency graph consumed by S3.
- switch_store:
  - main programming interface,
  - Implements the 4 primary APIs create/delete/set/get
  - provides the following services: State keeping, verification of operations against schema, reference tracking, triggers
- db_store: very simple kv store with narrow APIs, meant to be swappable with a real one when we address db-like problems.
- Factory: Implements a factory pattern. Table classes register with this factory along with a generated type so that they can be invoked at runtime.
- Bf_rt_backend: A wrapper for Bf-Rt APIs. Implements helper functions for
  - Match action direct/indirect tables
  - Counters get/set
  - Action profile/selector tables
  - Selector group tables
- Log: Internally uses the "fmt" library and bf-syslib logging
- Event: Notification module for various events like port status, learn, etc. In addition there is also support for notifications for object operations like create/delete/set.
- API: Lightweight C and C++ frontend for the switch_store. It acts as the entry point for CLI, SAI, thrift. It also defines "bf_smi_init" for bf_switchd analogous to "switch_api_init" in the current implementation.
- Table library: Schema specific implementation. This is unique to each schema. Currently, only one implementation exists specific to switch.p4 and switch.json. The implementation is basically equivalent to "switch_pd.c" in switchAPI. An entirely new schema can be used for a different application using S3 as the underlying service.
  - As noted above, JSON is only a means to map an application primitive with the P4 tables. The actual transformation of the user objects happens in these library implementations.

## Schema
At the core of S3 is the JSON schema which describes all the objects. The objects are broadly divided into 2 categories described in the schema using the "class" tag.

* "User" object
  - These are the user configurable objects like vlan, route, etc. Once again referring back to the observer pattern, these objects are the subjects. These are also the only objects that are user configurable.
* "Auto" object
  - These are the P4 objects which refer to the P4 tables in p4 program. They are the subscriber objects to the above user objects. They do not have any information about the internals of the table but rather hold the business logic that goes into programming the table. They are also interchangeably referred to as auto/p4/table objects in the rest of the document. Also, note that not all auto objects refer to P4 tables. There are some objects which are present to function as helpers. An example is a "bd" object which doesn’t point to any table but instead used for implementing logic.
The auto objects subscribe to events from the user objects. These subscriptions are pre-defined in the schema and the framework consumes this information to trigger the appropriate events.

An example graph for a route object would look like below.

       ------------                                ------------
       | ipv4_fib |-------------                   | ipv6_fib |
       ------------            \/                  ------------
                          -------------                 |
             -----------> |   route   | <----------------
             |            -------------
      ----------------         /\               ----------------
      | ipv4_fib_lpm |          ----------------| ipv6_fib_lpm |
      ----------------                          ----------------

```json
"route" : {
    "class" : "user",
    "attributes" : {
        "device_handle" : {
        	"type" : "OBJECT_ID"
        },
        "ip_address" : {
            "type" : "IP_PREFIX"
        },
    	"vrf_handle" : {
      	    "type" : "OBJECT_ID"
        },
    	"nexthop_handle" : {
      	    "type" : "OBJECT_ID"
        }
    }
}
```

In the above sample schema, the "route" object is described. At the beginning, the class tag denotes it is a user object and the "attribute" tag lists the various attributes of the route object.

```json
"ipv4_fib" : {
    "class" : "auto",
    "attributes" : {
        "parent_handle" : "route"
    },
    "dependencies" : ["nexthop_handle"]
}
"ipv6_fib" : {
    "class" : "auto",
    "attributes" : {
        "parent_handle" : "route"
   },
   "dependencies" : ["nexthop_handle"]
}
```


Once again, these objects are classified as table objects by assigning "auto" category to the class tag. The relationship between the auto object and its parent object is defined by the parent handle attribute which in this case is "route".  The fib objects also subscribe to nexthop updates using the dependencies list.

## Details
This section describes all the various JSON tags supported by the parser.

### Object tags
* **class** - Defines the object category
  - "user"
  - "auto"
* **description** - A brief description of the object. Used by the CLI for informative purpose
* **attributes** - List of attributes supported by this object
* **membership** - This is helper tag which automates the addition/deletion of membership. As an example, we would want a "rmac" object to be part of a "rmac_group" list of members. This can be defined in the following way. Basically, we tell "rmac" object that upon its creation, it should be added to the "rmac_group" object’s "rmac_handles" attribute. Of course, we can choose to manually add it programmatically if not via the schema.
<table><tr><td>

```json
"rmac_group" : {
  "attributes" : {
    "rmac_handles" : {
      "description" : "List of rmacs",
      "is_read_only" : true,
        "type_info" : {
          "type" : "TYPE_LIST"
        }
    }
  }
}
```
</td><td>

```json
"rmac" : {
  "attributes" : {
    "rmac_group_handle" : {
      "type_info" : {
        "allowed_object_types" : [
            "rmac_group"
        ],
        "type" : "TYPE_OBJECT_ID"
      }
    }
  },
  "membership" : {
    "object" : "rmac_group",
    "attribute" : "rmac_handles"
  }
}
```
</td></tr></table>

* **key_groups** - This is primarily a mechanism to lookup an object in the db store. In the below example, a combination of device and vlan_id can be used to uniquely identify a vlan.
```json
"vlan" : {
  "class" : "user",
  "description" : "Create a vlan",
  "attributes" : {
    "device" : {
      "description": "Device handle",
    },
    "vlan_id" : {
      "description": "Vlan ID"
    },
  "key_groups" : [
    [ "device", "vlan_id" ]
  ]
}
```
* **dependencies** - This is primarily a mechanism used by auto objects to be invoked when certain attributes in the parent user objects are updated. For example, if the "nexthop" of a "route" gets updated, we would want to update the fib table with the new nexthop. "dependencies" is the mechanism by which the above described observer pattern functions.
```json
"ipv4_fib" : {
    "class" : "auto",
    "attributes" : {
        "status" : {
            "type_info" : {
                "type" : "SWITCH_TYPE_BOOL"
            }
        },
        "parent_handle" : {
            "type_info" : {
                "allowed_object_types" : [ "route" ],
            }
        }
    },
    "dependencies" : [
        {
            "object" : "route",
            "attribute" : "nexthop_handle"
        }
    ]
}
```
Now, an attribute_set(route, SWITCH_ROUTE_ATTR_NEXTHOP, nexthop) would reevaluate the ipv4_fib object.

### Attribute tags
* **description** - A brief description of the attribute. Used by the CLI for informative purpose. This tag is mandatory for all user object attributes which are not internal. It can be ignored for auto objects.
* **type_info** - Used to define the type of the object. Supported types are uint8, uint16, uint32, uint64, string, mac, ip_address, object_id, bool, list
* **is_immutable** - Not modifiable once set after creation
* **is_create_only** - Only set during object creation
* **is_internal** - Not visible to application. Mainly for internal state
* **is_read_only** - Usually for object properties
* **is_mandatory** - Mandatory on creation
* **allowed_object_types** - This tag can be used for both user and auto objects alike. This is a list object, which means the attribute can be one of the types specified in the list. In the case of auto objects, it also means that the auto objects has to be evaluated for each of the parent object types specified in the list.

#### Allowed object types example
"interface" object’s port_lag_handle. This means the port_lag_handle can accept either a "port" or "lag" object as a valid value.
```json
"interface" : {
  "attributes" : {
    "port_lag_handle" : {
      "type_info" : {
        "allowed_object_types" : [ "port", "lag" ],
        "type" : "SWITCH_TYPE_OBJECT_ID"
      }
   }
}
```
Example: "bd" auto object. The "bd" object is invoked every time one of the 4 objects are created.
```json
"bd" : {
  "class" : "auto",
  "attributes" : {
  "parent_handle" : {
    "type_info" : {
        "type" : "SWITCH_TYPE_OBJECT_ID",
        "allowed_object_types" : [
            "vlan", "rif", "vrf", "bridge"
        ]
    }
}
```

### model.h
The framework generates a list of macros for every object and attribute in a single header file that can be used by the application. It is named as "model.h" and gets installed into the eventual prefix directory. A more detailed description can be found later in the document.

## Store
### DB Store
BMAI exposes a CRUD API to store and retrieve object information. The objects are stored in a key value store organized as a simple database. Each new object is allocated a sequential ID which is used as a key. A typical view for a "vlan" object will look like below.

| object ID | vlan_id      | learning       | age interval  |
|-----------|--------------|----------------|---------------|
|  vlan 1   | 1000         | true           | 30000         |
|  vlan 2   | 30           | false          | 60000         |
|  vlan 3   | 200          | true           | 40000         |

### Secondary Index
In addition to the Object Store, a secondary index is maintained to perform lookups based on key groups. This index is a simple key value store again with the key being a string representation of the key group members and the value being the object handle.

### Object Graph
The third and final data structure which maintains state is the object graph. This object graph is required to maintain the following features.
- Auto object forward references
- Parent inverse references
- Dependency management

## Life of an object

                   +-----------------+      Application invokes
                   |       API       |      object_create("route")
                   +-----------------+
                            |
                            | User object create
                            \/
                   +-----------------+      Validate route attributes
          +------->|     Switch      |      Execute triggers
          |        |      Store      |      Update DB store
          |        +-----------------+
          |                 |
          |                 | Create auto objects
     Recursively            \/
      evaluate     +-----------------+      Generate auto object list
         all       |                 |      For route, ipv4_fib, ipv6_fib
       children    |     Factory     |      ipv4_fib_lpm, ipv6_fib_lpm
          |        |                 |      Instantiate auto objects
          |        +-----------------+
          |                 |
          |                 | Data transformation
          |                 \/
          |        +-----------------+
          |        |       P4        |
          +--------|    Specific     |      Set match and action params
                   |  Implementation |
                   +-----------------+
                            |
                            | Program HW
                            \/
                   +-----------------+
                   |    BF-Runtime   |
                   +-----------------+

## Data Structures

### Object class
The "object" class is the main interface based on which all table classes are derived.

```cpp
class object {
 public:
  virtual switch_status_t create_update() = 0;
  virtual switch_status_t del() = 0;
  virtual ~object() {}
};
```
Any class that is derived from this object interface does not get an object_id assigned.

### Auto Object class
The "auto_object" class is the DB object that is derived from the "object" base class. Any class that is derived from this auto_object gets a object_id assigned and stored in the DB.

### p4_object class
These are the custom wrapper classes implemented on top of the Bf-Rt classes to simplify key/data updates. The programmer can just focus on programming the correct value and not worry too much about the data types.

The p4_object class uses the auto_object class internally and hence gets its own object ID.

### Triggers
Triggers are the mechanism by which switch_store <-> factory communication happens. At initialization time, factory registers a bunch of triggers as callbacks to facilitate creation and update of objects and their attributes.

Optionally, triggers can be registered for each object_type. Supported triggers are,
- before_object_create
- before_object_delete
- after_object_create
- after_object_delete
- after_object_update
- after_object_update

### BFRT backend
BF-Runtime is the underlying API used by SMI to program the tables. It is recommended to familiarize with bf-rt before proceeding further.

At a high level, bf-rt abstracts a p4 table into a table object which holds match and action information. In bf-rt terminology, a match field is referred to as a "KeyField" while action parameters are referred to as "DataField". Both of these entities are exposed as C++ classes.

The programming of a table hence finally comes down to a bunch of setValue calls on each of the table, key and data objects.
The backend wrapper implementation is structured the following way

**_MatchKey** - Wrapper class to the "BfRtTableKey" object
- set_exact()
- set_ternary()
- set_lpm()
- set_range()

**_ActionEntry** - Wrapper class to the "BfRtTableData" object
- set_arg

**_Table** - Wrapper class to the "BfRtTable"object
- entry_add()
- entry_delete()
- entry_modify()
- default_entry_set()

**p4_object_match_action** - Helper class to program match action direct/indirect tables

**p4_object_match_action_list** - Helper class to program match action direct/indirect tables for list of entries

**p4_object_action_selector** - Helper class to program action profile/selector tables

**p4_object_selector_group** - Helper class to program action selector group tables

### Recommendation
* Choose to derive from an "object" when all you want to do is some computation which does not immediately affect the store or a p4 table.
* Choose to derive from an "auto_object" when you want to maintain state or come back later for updates or if the helper classes are not useful for the operation.
* Choose to derive from one of the backend classes, if you want to program the hardware.

## Concurrency model
S3 uses global locks to maintain consistency in the data stores.

As explained in the Store section above, S3 works with 3 main data stores namely db store, secondary index and object graph. Each of these 3 stores have their own global lock. Any thread working on the objects can obtain a lock on only one of these stores at any point in time. This means, if 2 parallel threads are in progress, one of them can take the db store lock while the second thread can take the object graph's lock while working on the same object. This allows for very minimal lock contention.

This schema works very well when the objects under contention are in a steady state. Steady state meaning they are not being deleted. Because of the independent locks for the 3 data stores, the following sequence can happen during object deletion.
- Thread 2 reading db store for object A
- Thread 1 starts deleting object A
- Thread 1 deletes object graph data of A
- Thread 2 tries reading object graph of A
- Thread 1 deletes object A

To avoid this and other scenarios, S3 also supports per object lock. This lock synchronizes access to all the 3 data stores. In the above scenario, thread 2 can obtain an object level lock for A and the deletion in Thread 1 will be paused until the lock is released by thread 2.

Note: Object level locking can only protect against object deletion at this time. Locks during updates of the object are a NOP.

## CLI
TODO

## Code auto-generation
TODO

## S3 Code flow
```c
switch_store::object_create(route, attributes) {
  switch_store::verify(attributes);
  switch_store::augment_attributes(attributes);
  for (all triggers of "route"):
    switch_store::execute_trigger();
  oid = store::db_create("route");
  store::db_store_attributes(oid, attributes);
  factory::create_auto_objects_trigger(oid);
  return;
}

factory::create_auto_objects_trigger(oid, "route") {
  /* auto_type could be ipv4_fib or ipv6_fib
   * factory has the mapping from type to class
   * Create call invokes the constructor of the ipv4_fib class
   * where the bulk of the logic exists
   * Finally, the create_update() is invoked causing a hardware
   * update
   */
  for (auto_type : route):
    object = factory::create(auto_type);
    object->create_update();
}
```

## Sample Object

We will re-introduce the "route" object to walk through how a typical user/auto object is designed.

### User Object
```json
"route" : {
    "class" : "user",
    "attributes" : {
    	"device_handle" : {
       	    "type" : "OBJECT_ID"
    	},
        "ip_address" : {
          "type" : "IP_PREFIX"
    	},
    	"vrf_handle" : {
      	    "type" : "OBJECT_ID"
    	},
    	"nexthop_handle" : {
      	    "type" : "OBJECT_ID"
    	}
    }
}
```
The framework generates the following macros in the model.h header file.
```
SWITCH_OBJECT_TYPE_ROUTE
SWITCH_ROUTE_ATTR_DEVICE_HANDLE
SWITCH_ROUTE_ATTR_IP_ADDRESS
SWITCH_ROUTE_ATTR_VRF_HANDLE
SWITCH_ROUTE_ATTR_NEXTHOP_HANDLE
```

### Auto Object
```json
"ipv4_fib" : {
    "class" : "auto",
    "attributes" : {
        "parent_handle" : {
  	        "allowed_object" : [ "route" ],
            "type" : "OBJECT_ID"
        }
    }
}
```
Similar macros are also generated for auto objects.
```
SWITCH_OBJECT_TYPE_IPV4_FIB
SWITCH_IPV4_FIB_ATTR_PARENT_HANDLE
```

### P4 Code
Finally, the P4 code for which the auto object is defined.
```
   action fib_hit(switch_nexthop_t nexthop_index) {
       nexthop = nexthop_index;
       flags.routed = true;
   }
   action fib_miss() {
       flags.routed = false;
   }
   table fib {
       key = {
          vrf : exact;
          dst_addr : exact;
       }
       actions = {
          fib_miss;
          fib_hit;
       }
       size = host_table_size;
    }
```
This is a simple p4 table which has
- 2 match keys, vrf and dst_addr
- 2 actions, fib_hit and fib_miss
- Fib_hit takes one action parameter/data, nexthop_index

For brevity, we can assume the following table IDs are already obtained via BFRT API.
```
T_IPV4_FIB
F_IPV4_FIB_VRF
F_IPV4_FIB_DST_ADDR
A_IPV4_FIB_HIT
D_IPV4_FIB_HIT_NEXTHOP_INDEX
```

Note:
The auto object as it may seem obvious now clearly has no information about the P4 table. This declarative nature of the auto object is intentional. It leaves the implementation of this auto object entirely upon the developer. The following code is the actual implementation of the IPV4 FIB table.

In most of the API code, a REGISTER_OBJECT call is required which registers the class implementation for each auto object with the framework. This notifies the S3 framework to invoke ipv4_fib class for an "ipv4_fib" auto object.
```
REGISTER_OBJECT(SWITCH_OBJECT_TYPE_IPV4_FIB, ipv4_fib);
```

### Implementation
A class implementation is the most common piece of code a developer is expected to write other than the schema definition.
```cpp
Line  Code
1     class ipv4_fib : public p4_object_match_action {
        private:
        static const switch_object_type_t auto_ot = SWITCH_OBJECT_TYPE_IPV4_FIB;
        static const switch_attr_id_t parent_attr_id = SWITCH_IPV4_FIB_ATTR_PARENT_HANDLE;

2     public:
        ipv4_fib(const switch_object_id_t parent, switch_status_t &status)
            : p4_object_match_action(smi_id::T_IPV4_FIB,
                                     status_attr_id,
                                     auto_ot,
                                     parent_attr_id,
                                     parent) {
          switch_ip_prefix_t prefix = {};
          switch_object_id_t nexthop_handle = {}, vrf_handle = {};

          // Retrieve attributes from switch store
3         switch_store::v_get(parent, SWITCH_ROUTE_ATTR_IP_PREFIX, prefix);
4         switch_store::v_get(parent, SWITCH_ROUTE_ATTR_NEXTHOP_HANDLE, nexthop_handle);
5         switch_store::v_get(parent, SWITCH_ROUTE_ATTR_VRF_HANDLE, vrf_handle);

          // Set match keys
6         match_key.set_exact(smi_id::F_IPV4_FIB_VRF, parent, SWITCH_ROUTE_ATTR_VRF_HANDLE);
7         match_key.set_exact(smi_id::F_IPV4_FIB_DST_ADDR, parent, SWITCH_ROUTE_ATTR_IP_PREFIX);

          // Set action as fib hit
8         action_entry.init_action_data(smi_id::A_IPV4_FIB_HIT);
          // Set action parameters
9         action_entry.set_arg(smi_id::P_IPV4_FIB_HIT_NEXTHOP_INDEX, compute_nexthop_index(nexthop_handle));
        }
      };
```
We will now go through the above code line by line.

1. This section of code simply shows how the ipv4_fib class inherits from "p4_object_match_action". The definition of these helper classes are available in include/s3/bf_rt_backend.h.
2. The ipv4_fib initializes a set of auto object attributes on the parent class.

A note on v_set and v_get. Both of these are helper template functions defined in the switch_store namespace. These functions can be used to retrieve information about the object from the store without having to use the attr_w class which is generally prescribed for users. The reason these APIs exist is they make the code less verbose and easier to read. The cons of these APIs are the programmer needs to be explicit on what type is being passed as an argument to these APIs. The API will fail if say a uint32_t is passed when trying to retrieve an enum.

3. v_get is used to get the ip_prefix from the parent(route) and stored in the prefix local variable.
4. v_get is used to get the nexthop ID from the parent(route) and stored in the nexthop_handle local variable.
5. v_get is used to get the vrf_id from the parent(route) and stored in the vrf_handle local variable.

At this point, we have enough data to program the P4 table.

"p4_object_match_action" provides 2 helper classes which are in turn wrappers of BFRT APIs.
- "match_key" which is a wrapper for BfRtTableKey object
- "action_entry" which is a wrapper for BfRtTableData object

6. set_exact method of the match_key object sets the vrf ID.
7. set_exact method of the match_key object sets the IP prefix.
8. init_action_data indicates that the fib_hit action is being used for this match entry.
9. set_arg method of the action_entry objects set the nexthop_index action parameter.

At this point, we have the relevant data for both match and action. The framework now takes care of invoking the appropriate BFRT APIs to program the table.

## SAI
The SAI implementation is a layer above bf-switch implementation. The SAI API is itself an object driven model albeit using simple C header files. A lot of the objects and their attributes in switch are modelled based on the SAI object model.

Below is an example of a vlan_member SAI object compared with a BMAI schema object.

<table>
<tr><td> SAI </td><td> BMAI </td></tr>
<tr><td>

```cpp
typedef enum _sai_vlan_member_attr_t
{
    /**
     * @brief Start of attributes
     */
    SAI_VLAN_MEMBER_ATTR_START,

    /**
     * @brief VLAN ID
     *
     * @type sai_object_id_t
     * @flags MANDATORY_ON_CREATE | CREATE_ONLY
     * @objects SAI_OBJECT_TYPE_VLAN
     */
    SAI_VLAN_MEMBER_ATTR_VLAN_ID = SAI_VLAN_MEMBER_ATTR_START,

    /**
     * @brief Bridge port ID.
     *
     * Valid only for .1Q bridge ports.
     *
     * @type sai_object_id_t
     * @flags MANDATORY_ON_CREATE | CREATE_ONLY
     * @objects SAI_OBJECT_TYPE_BRIDGE_PORT
     */
    SAI_VLAN_MEMBER_ATTR_BRIDGE_PORT_ID,

    /**
     * @brief VLAN tagging mode
     *
     * @type sai_vlan_tagging_mode_t
     * @flags CREATE_AND_SET
     * @default SAI_VLAN_TAGGING_MODE_UNTAGGED
     */
    SAI_VLAN_MEMBER_ATTR_VLAN_TAGGING_MODE,

    /**
     * @brief End of attributes
     */
    SAI_VLAN_MEMBER_ATTR_END,

    /** Custom range base value */
    SAI_VLAN_MEMBER_ATTR_CUSTOM_RANGE_START = 0x10000000,

    /** End of custom range base */
    SAI_VLAN_MEMBER_ATTR_CUSTOM_RANGE_END

} sai_vlan_member_attr_t;
```
</td><td>

```json
"vlan_member" : {
    "class" : "user",
    "description" : "Create a vlan member",
    "attributes" : {
    "device" : {
        "description": "Device handle",
        "is_mandatory": true,
        "is_create_only" : true,
        "type_info" : {
            "type" : "SWITCH_TYPE_OBJECT_ID",
            "allowed_object_types" : [
                "device"
            ]
        }
    },
    "vlan_handle" : {
        "description": "VLAN handle",
        "is_mandatory": true,
        "is_create_only" : true,
        "type_info" : {
            "allowed_object_types" : [
                "vlan"
            ],
            "type" : "SWITCH_TYPE_OBJECT_ID"
        }
    },
    "port_lag_handle" : {
        "description": "Port or LAG handle",
        "is_mandatory": true,
        "is_create_only" : true,
        "type_info" : {
            "type" : "SWITCH_TYPE_OBJECT_ID",
            "allowed_object_types" : [
                "port", "lag"
            ]
        }
    },
    "tagging_mode" : {
        "description": "This attribute defines the ingress and egress tagging mode",
        "type_info" : {
            "default_value": "UNTAGGED",
            "enum" : [
                "UNTAGGED",
                "TAGGED"
            ],
            "type" : "SWITCH_TYPE_ENUM"
        }
    }
},
```
</td></tr></table>