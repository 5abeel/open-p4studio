L2 VXLAN HLD
============

# SONiC layer programming of L2 VXLAN

## 2 different SONiC approaches to programming L2 VXLAN

SONiC currently supports two different modes of operation for programming
L2 VXLAN:
1. The default mode that has been supported over many SONiC releases uses
   point-to-point VXLAN tunnels, one to each remote VTEP. A separate SAI bridge
   port is created for each P2P tunnel. FDB entries refer to that bridge port
   for forwarding. That bridge port is added to VLAN membership, driving
   flooding.
2. SONiC recently added support for L2 VXLAN using point-to-multipoint tunnels.
   While this simplifies tunnel management and unicast forwarding, this
   approach relies on L2 multicast functionality to drive flooding to tunnel
   endpoints. While SONiC always programs unknown unicast and broadcast to use
   the same L2 multicast group and does not support unknown multicast, at SAI
   layer different L2 multicast groups may be specified for unknown unicast,
   unknown multicast, and broadcast.

In order to simplify flooding and support existing SONiC versions, this design
uses the first mode of operation. However, this design will not actually
program any P2P tunnels. Instead, each P2P tunnel will trigger creation of a
corresponding tunnel nexthop that will be used for both (known) unicast
forwarding and flooding. This approach relies on the following assumptions:
- Mappings between VNIs and VLANs are global, with the same mappings being used
  for all tunnels. This assumption is already present in existing p4 and BMAI
  VXLAN code. This just extends the assumption to the P2P tunnels associated
  with the p2mp tunnels. SONiC EVPN functionality conforms with this assumption.
- Tunnel ttl_mode and qos_mode are the same for all P2P tunnels and the
  corresponding p2mp tunnel. It looks like SONiC supports both ttl_mode values,
  but does not support different qos_mode values for VXLAN. However, it does
  not look like SONiC sets ttl_mode for P2P tunnels (might be a bug).
  See the Open Issues section below for further discussion of ttl_mode and
  qos_mode.

## SAI commands generated by SONiC using P2P VXLAN tunnels

When using EVPN with P2P VXLAN tunnels, SONiC sends down the following
commands for L2-VXLAN:

```
2021-02-26.22:58:56.513196|c|
SAI_OBJECT_TYPE_TUNNEL:oid:0x2a00000000063e|
SAI_TUNNEL_ATTR_TYPE=SAI_TUNNEL_TYPE_VXLAN|
SAI_TUNNEL_ATTR_UNDERLAY_INTERFACE=oid:0x60000000005a7|
SAI_TUNNEL_ATTR_DECAP_MAPPERS=2:oid:0x29000000000634,oid:0x29000000000636|
SAI_TUNNEL_ATTR_ENCAP_MAPPERS=2:oid:0x29000000000635,oid:0x29000000000637|
SAI_TUNNEL_ATTR_ENCAP_SRC_IP=6.6.6.6|
SAI_TUNNEL_ATTR_PEER_MODE=SAI_TUNNEL_PEER_MODE_P2P|
SAI_TUNNEL_ATTR_ENCAP_DST_IP=7.7.7.7

2021-02-26.22:58:56.514100|c|
SAI_OBJECT_TYPE_BRIDGE_PORT:oid:0x3a00000000063f|
SAI_BRIDGE_PORT_ATTR_TYPE=SAI_BRIDGE_PORT_TYPE_TUNNEL|
SAI_BRIDGE_PORT_ATTR_TUNNEL_ID=oid:0x2a00000000063e|
SAI_BRIDGE_PORT_ATTR_BRIDGE_ID=oid:0x39000000000586|
SAI_BRIDGE_PORT_ATTR_ADMIN_STATE=true|
SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE=SAI_BRIDGE_PORT_FDB_LEARNING_MODE_DISABLE

2021-02-26.22:58:56.514977|c|
SAI_OBJECT_TYPE_VLAN_MEMBER:oid:0x27000000000640|
SAI_VLAN_MEMBER_ATTR_VLAN_ID=oid:0x26000000000633|
SAI_VLAN_MEMBER_ATTR_BRIDGE_PORT_ID=oid:0x3a00000000063f|
SAI_VLAN_MEMBER_ATTR_VLAN_TAGGING_MODE=SAI_VLAN_TAGGING_MODE_UNTAGGED

2022-02-26.22:58:56.515419|c|
SAI_OBJECT_TYPE_FDB_ENTRY:{
"bvid":"oid:0x26000000000633",
"mac":"40:A6:B7:22:AF:78",
"switch_id":"oid:0x21000000000000"}|
SAI_FDB_ENTRY_ATTR_TYPE=SAI_FDB_ENTRY_TYPE_STATIC|
SAI_FDB_ENTRY_ATTR_ALLOW_MAC_MOVE=true|
SAI_FDB_ENTRY_ATTR_BRIDGE_PORT_ID=oid:0x3a00000000063f|
SAI_FDB_ENTRY_ATTR_ENDPOINT_IP=7.7.7.7
```

# BMAI

## Changes to existing code to prepare for L2 VXLAN functionality

In order to allow nexthop_table entries to be created in response to different
types of BMAI objects, the p4 nexthop_index values will need to be sourced
from something other than the handle of the BMAI nexthop object. Depending on
whether nexthop resolution is enabled, the p4 nexthop_index values will be
assigned as follows:
  1. When nexthop resolution is disabled, the p4 nexthop_index values will
     continue to use the handle of the BMAI nexthop object.
  2. When nexthop resolution is enabled, the p4 nexthop_index values will use
     the handle of the corresponding nexthop_resolution object. Creation of
     nexthop entries can only be triggered by objects for which
     nexthop_resolution is an auto object.

For tunnel encap, a 4-bit eg_md.tunnel.index is used to drive TTL (and QoS)
programming for the outer header. Currently, this directly uses the handle
to the tunnel object. Once P2P tunnels are supported, this will no longer be
possible. A tunnel_index allocator will need to be introduced, which is only
called for P2MP tunnels. A new is_internal attribute will be added to the
tunnel object to store the tunnel_index. This affects tunnel_nexthop,
tunnel_src_addr_rewrite, tunnel_encap_ttl, and tunnel_encap_dscp (when pipe
mode is supported).

The tunnel_nexthop object is currently driven by the nexthop object as its
parent. This needs to be changed to nexthop_resolution object as its parent,
when nexthop resolution is enabled.

## Schema changes

### Bridge Port Object

The BMAI bridge_port object currently only supports "type" values "PORT"
(which also includes LAG) or "QINQ". This will need to be extended with
a new "TUNNEL" type, along with an additional attribute "tunnel_handle".

```
diff --git a/schema/appObj/bridge_port.json b/schema/appObj/bridge_port.json
index fb1ce8bae..e8c496108 100644
--- a/schema/appObj/bridge_port.json
+++ b/schema/appObj/bridge_port.json
@@ -23,6 +23,7 @@
                         "default_value" : "PORT",
                         "enum" : [
                             "PORT",
+                            "TUNNEL",
                             "QINQ"
                         ]
                     }
@@ -39,6 +40,17 @@
                         "type" : "SWITCH_TYPE_OBJECT_ID"
                     }
                 },
+                "tunnel_handle" : {
+                    "description": "Handle to the tunnel represented by this bridge port. Valid only if type is TUNNEL",
+                    "is_mandatory": true,
+                    "is_create_only" : true,
+                    "type_info" : {
+                        "allowed_object_types" : [
+                            "tunnel"
+                        ],
+                        "type" : "SWITCH_TYPE_OBJECT_ID"
+                    }
+                },
                 "bridge_handle" : {
                     "description": "Bridge handle.",
                     "is_create_only" : true,

```

In this design, the bridge_port object is only used as a cache for SAI to
resolve the tunnel. This aligns with the use of the bridge_port object for
physical ports.

### Tunnel Object

The BMAI tunnel object currently only supports P2MP mode. For forwarding of L2
packets into tunnels, both known unicast and flooding, we will need to add
support for P2P tunnels. An additional "tunnel" attribute "peer_mode" will
need to be introduced, along with a new attribute "dst_ip". Note that it will
still be assumed that the same encap_mappers and decap_mappers will be shared
amongst all tunnels used by this switch.

Whenever a P2P tunnel is created, the BMAI layer will automatically create a
corresponding nexthop_table entry, to be used for forwarding of both (known)
unicast and flooded packets into the P2P tunnel.

Creation of the tunnel_dest_ip object is currently driven only by the nexthop
object. This will need to be extended to the tunnel object as well, with the
addition of a tunnel_dest_ip_handle attribute in the tunnel object.

In the p4 code, TunnelNexthop, action l2_tunnel_encap should set
eg_md.flags.routed = true, with a comment that this control block
must be placed after all inner header operations are completed
(relying on eg_md.flags.routed = false), but before the EgressBD and
Neighbor control blocks. This change is required in order to set the
(outer) hdr.ethernet.src_addr and hdr.ethernet.dst_addr values.

### MAC Entry Object

No functional change is required to the BMAI mac_entry object, since it already
allows the (misnamed) "port_lag_handle" attribute to refer to a nexthop or
tunnel object. For a mac_entry object that directs traffic into a tunnel, when
nexthop resolution is enabled, the "port_lag_handle" will be populated with a
tunnel object. When nexthop resolution is disabled, the "port_lag_handle"
attribute will be populated with a nexthop object.

The attribute name will be changed from "port_lag_handle" to
"destination_handle" for clarification.

```
-            "port_lag_handle" : {
+            "destination_handle" : {
                 "description": "Egress destination object for this MAC entry",
                 "is_mandatory": true,
                 "type_info" : {
                     "allowed_object_types" : [
                         "port", "lag", "nexthop", "tunnel"
                     ],
                     "type" : "SWITCH_TYPE_OBJECT_ID"
                 }
             },
```

### VLAN Membership

The BMAI vlan_member object currently only supports physical ports and LAGs.
This needs to be extended to (P2P) tunnels. To refer to the tunnel, the
existing "port_lag_handle" needs to be generalized and renamed.

```
diff --git a/schema/appObj/vlan.json b/schema/appObj/vlan.json
index 26fcd6bfd..1736d4976 100644
--- a/schema/appObj/vlan.json
+++ b/schema/appObj/vlan.json
@@ -238,13 +238,13 @@
                     }
                 },
-                "port_lag_handle" : {
+                "member_handle" : {
-                    "description": "Port or LAG handle",
+                    "description": "Handle to the object that is a member of the VLAN",
                     "is_mandatory": true,
                     "is_create_only" : true,
                     "type_info" : {
                         "type" : "SWITCH_TYPE_OBJECT_ID",
                         "allowed_object_types" : [
-                            "port", "lag"
+                            "port", "lag", "tunnel"
                         ]
                     }
                 },
```

Note: The p4 code for L2 VXLAN does not currently support any VLAN membership
      check for packets arriving over tunnels. If a VNI to BD mapping exists
      for a VLAN, then any packet arriving over a tunnel with that VNI will be
      processed, regardless of the outer source IP address (source VTEP).
      VLAN membership of P2P tunnels will only be used to determine head-end
      replication for flooding.

## L2 VXLAN operation when nexthop resolution is disabled

Initially, the L2 VXLAN implementation will only support operation when
nexthop resolution is enabled, with SONiC support as the goal. Care should
be taken not to break any existing functionality when nexthop resolution is
disabled, as well as to minimize the need for future code rewrites.

At a high level, L2 VXLAN support could be extended to cases where nexthop
resolution is disabled (e.g. SAL) using the following approach:
  1. Identification of the remote VTEP's IP address is not sufficient for
     determining how to forward packets towards that remote VTEP. For this
     reason, the NOS must explicitly create at least one nexthop for
     forwarding of L2 traffic to each remote VTEP. Little if any code rework
     should be needed within the BMAI layer to support this, since the current
     implementation supports explicitly created nexthops.
  2. For known unicast forwarding into a VXLAN tunnel, the NOS must program
     the mac_entry object to refer to a nexthop as the destination_handle.
  3. For flooding, the BMAI schema will need to be extended with a method to
     associate a set of tunnel nexthops with a VLAN. No such method is
     proposed at this time, leaving this for the future. This may require
     significant implementation effort to program PRE and the
     TunnelReplication rid table.

## New BMAI code

### L2 Nexthop for P2P tunnels

When nexthop resolution is enabled and a P2P tunnel is created, the BMAI layer
needs to automatically create a corresponding nexthop_table entry for L2
forwarding of both (known) unicast and flooded packets into a tunnel. Along
with the nexthop_table, it will also be necessary to program other tables
associated with tunnel nexthops. All of this programming needs to be
re-evaluated upon various triggers, in the same way as explicitly created
nexthops for (L3) tunnels.

In order to drive all of this while reusing much of the existing code, this
design proposes to extend the existing nexthop_resolution object. In addition
to the nexthop_resolution object being an auto object for the nexthop object,
the nexthop_resolution object will also be an auto object for the tunnel
object (only for P2P tunnels).

      +--------+    +---------+    +----------+    +-----------+
      | tunnel |    | nexthop |    | neighbor |    | mac_entry |
      +--------+    +---------+    +----------+    +-----------+
           |  \        |     \              |          /
           |   \       |      +--------+    |         /
           |    +---------------------+ \   |        /
           |           |               \ \  |       /
         +----------------+           +--------------------+
         | tunnel_dest_ip |           | nexthop_resolution |
         +----------------+           +--------------------+
                 |                               |
                 |                               |
             outer_fib,          nexthop_table, outer_ecmp_selector,
      tunnel_dst_addr_rewrite     outer_nexthop, neighbor_rewrite,
                                    tunnel_nexthop, sid_rewrite

In addition to the changes in the nexthop_resolution class, this will require
additions to several children to retrieve values from the tunnel object rather
than the nexthop object, when the nexthop_resolution object is an auto object
for a tunnel. This includes nexthop_table and tunnel_nexthop.

In the tunnel_nexthop class, a tunnel_index is programmed as an action
parameter. This is used to drive TTL (and QoS) programming for the outer
header. Unless eg_md.tunnel.index is expanded, this needs to be the
tunnel_index associated with the corresponding P2MP tunnel. The key_group
for the tunnel object needs to be defined so that this P2MP tunnel can be
looked up using `switch_store::object_id_get_wkey`.

The logic to create and delete the tunnel_dest_ip object will need to be added
before tunnel creation and tunnel deletion, similar to the existing code
before nexthop creation and nexthop deletion. The resulting tunnel_dest_ip
object will drive programming of outer_fib and tunnel_dst_addr_rewrite in the
same way that it does for nexthop creation.

### VLAN-to-VNI mapping

The BMAI layer needs to program the bd_to_vni_mapping table whenever a
tunnel_mapper object with "type" value "VLAN_HANDLE_TO_VNI" is created.
A new BMAI object and class will be created to handle this, with the
tunnel_mapper_entry object as parent.

### DMAC entry for L2 forwarding into tunnels

When an FDB entry is created, a corresponding dmac entry needs to be created
with action dmac_redirect. The existing dmac code for the case of a
mac_entry's destination_handle referring to a tunnel needs to be replaced.
Instead of looking for a user nexthop object with the tunnel's dest IP
address, just look for the handle of the nexthop_resolution auto object
for the tunnel, which can be used as the nexthop_index.

### Tunnel Replication

#### PRE nodes, rids, and exclusion ids

SWI-4502 is combining flooding on physical ports and LAGs (i.e. non-tunnels)
into one PRE node per vlan (for all such vlan members), under the vlan's mgid.
This uses one rid per vlan and level2_exclusion_id for pruning of such ports.
The level1_exclusion_id will be programmed as not valid on the PRE node.

```
                      +------------------+
                      | mgid = vlan_1_id |
                      +------------------+
                        /        |     \
                       /         |      +-----------------+
                      /          |                         \
  +---------------------+    +---------------------+     +---------------------+
  | node_id = vlan_1_id |    | node_id = vtep_1_id |     | node_id = vtep_n_id |
  | rid = vlan_1_id     |    | rid = vtep_1_id     | ... | rid = vtep_n_id     |
  | l1_xid_valid = false|    | l1_xid = 1          |     | l1_xid = 1          |
  +---------------------+    +---------------------+     +---------------------+
         /         \
        /           \
  +--------+     +--------+
  | port_1 | ... | port_n |
  +--------+     +--------+
```

For tunnel vlan members, at least one PRE node needs to be created for each
tunnel vlan member. A different rid value needs to be programmed for each
tunnel vlan member belonging to the same vlan, driving the MAU to use a
different tunnel encapsulation and outer mac rewrite. The level1_exclusion_id
will be used for pruning, with the same value 1 used for all tunnel vlan
members. This prevents packets that arrive on a tunnel from being flooded back
out any tunnel vlan members.

There are two possible approaches for routing of flooded traffic over P2P
tunnels, with different approaches to handling ECMP and correspondingly
different levels of complexity:

  1. The simpler approach is to create one node for each tunnel vlan member,
     as shown above. With this approach, all flooded traffic over that P2P
     tunnel will use the same egress port, even when there are multiple ECMP
     routes to the remote VTEP. Only one of the ECMP nexthops is selected for
     use by flooding.

     In order to minimize complexity, the proposal is to allocate one rid
     value for each P2P tunnel, shared amongst all vlan members for
     that tunnel (on different vlans). This same rid value can be programmed
     in each of the nodes created for the corresponding vlan members (one node
     per vlan that has a vlan member using that P2P tunnel, under that vlan's
     mgid). With this approach, all flooded traffic over that P2P tunnel will
     use the same egress port, even flooded traffic for different vlans.

  2. The more complex approach utilizes PRE ECMPs to distribute traffic to a
     remote VTEP over multiple ECMP routes. There is one PRE ECMP for each
     tunnel vlan member, with one or more PRE nodes underneath that, one per
     outer ECMP member.

```
                      +------------------+
                      | mgid = vlan_1_id |
                      +------------------+
                        /        |     \
                       /         |      +-----------------+
                      /          |                         \
  +---------------------+    +---------------------+     +---------------------+
  | node_id = vlan_1_id |    | ecmp_id = vtep_1_id |     | ecmp_id = vtep_n_id |
  | rid = vlan_1_id     |    | l1_xid = 1          | ... | l1_xid = 1          |
  | l1_xid_valid = false|    +---------------------+     +---------------------+
  +---------------------+          |            \                           \
         /         \               |             +------+                    \
        /           \              |                     \                    \
       /             \        +------------------+     +------------------+
  +--------+     +--------+   | node_id = 1_1_id | ... | node_id = 1_m_id |
  | port_1 | ... | port_n |   | rid = 1_1_id     |     | rid = 1_m_id     |
  +--------+     +--------+   +------------------+     +------------------+
```

   Due to the bf_rt design that drives association of PRE ECMPs and PRE
   nodes from the mgid on top, it may be necessary to allocate a PRE ECMP
   even when the remote VTEP is reachable through a single (non-ECMP) route.
   When the mgid on top is programmed, the list of vlan members is easy to
   retrieve from the BMAI model's vlan object. However, it is difficult to
   determine whether each tunnel vlan member is reachable through a single
   nexthop or through ECMP. This may change due to various triggers, which
   are difficult to capture and drive in a consistent matter with the rest
   of PRE programming.

   Also note that the more complex approach requires a small p4 change to set
   ig_intr_md_for_tm.level1_mcast_hash.

#### Tunnel Replication resolution

In order to forward flooded traffic, it is necessary to resolve the egress
port(s) and corresponding (outer) nexthop(s) for each P2P tunnel. Consistent
programming is required for the egress port or lag in a PRE node, and the
corresponding nexthop in the TunnelReplication rid table.

                    +--------+          +---------+
                    | tunnel |          | nexthop |
                    +--------+          +---------+
                     //    \                /
                    //      \              /
                   //        \            /
        +-------------+    +----------------+
        | vlan_member |    | tunnel_dest_ip |
        +-------------+    +----------------+
               |                   |      \
               |                   |       +-----------+
               |                   |                    \
               |       +-----------------------+      +------------------+
               |       |        outer_fib      |      | tunnel_dst_addr_ |
               |       | .outer_nexthop_handle |      |     rewrite      |
               |       +-----------------------+      +------------------+
               |                   |
               |                   |
               |   +-------------------------------+
               |   | tunnel_replication_resolution |
               |   +-------------------------------+
               |          ::                \
               |          ::                 \
            +---------------------+      +------------+
            | mc_node_vlan_member |      | tunnel_rid |
            +---------------------+      +------------+

This design proposes creation of a tunnel_replication_resolution object, with
parent outer_fib, which is only applicable when nexthop_resolution is enabled.
While strictly speaking tunnel_replication_resolution is only needed when
there is a tunnel using the tunnel_dest_ip ancestor, for simplicity and
uniformity purposes it is proposed that tunnel_replication_resolution be
created for each outer_fib (and thus tunnel_dest_ip) regardless. While
a tunnel_dest_ip object might be created during creation of a nexthop user
object, it might later be used by a tunnel user object as well.

The outer_fib class is already responsible for resolving the route(s) that
can be used to reach each remote tunnel destination, resulting in an (outer)
nexthop handle. This is accomplished by calling the existing
`compute_outer_nexthop` function from utils.cpp.

This design proposes that outer_fib add an attribute to store the resulting
outer_nexthop_handle, so that it can be reused by
tunnel_replication_resolution. If it is preferred not to mix outer nexthop
resolution with table programming, then instead outer_fib could be split into
outer_nexthop_resolution (consisting of the call to `compute_outer_nexthop`
and the new outer_nexthop_handle attribute) and outer_fib (the table
programming part of the existing outer_fib class).

The tunnel_replication_resolution class retrieves the outer_nexthop_handle
from outer_fib (or outer_nexthop_resolution). There are two approaches,
corresponding to the simpler and more complex approaches to PRE programming
described above:

  1. In the simpler approach, if the outer_nexthop_handle has type ecmp, then
     tunnel_replication_resolution resolves that to one of the ecmp members,
     which it stores in a flood_nexthop_handle attribute. Otherwise, the
     outer_nexthop_handle value can be directly written as
     flood_nexthop_handle. Each tunnel_replication_resolution object requests
     one rid value that is also stored in an attribute.

     The tunnel_mc_node and tunnel_rid classes can use the
     flood_nexthop_handle and rid from tunnel_replication_resolution to
     program their tables in a consistent manner.

  2. In the more complex approach, tunnel_replication_resolution follows
     outer_nexthop_handle to the list of ecmp members. One rid value is
     requested for each ecmp member. The resulting list of rids is stored in
     an attribute. An additional attribute will probably be needed to keep the
     list of ecmp members so that child objects can manage creation, deletion,
     and update of multiple table entries. This adds significant complexity
     since the number of ecmp members can fluctuate.

#### Tunnel Replication rid table

A new BMAI tunnel_rid object and class will be defined for
programming of the rid table, with parent tunnel_replication_resolution.

There are two approaches, corresponding to the simpler and more complex
approaches to PRE programming described above:

  1. Using the simpler approach of PRE programming described above, the
     tunnel_rid object programs a single entry for each P2P
     tunnel. The rid and nexthop values are obtained directly from
     tunnel_replication_resolution's rid and flood_nexthop_handle attributes,
     respectively. The tunnel_nexthop value is obtained by walking back
     through successive parents to the tunnel. This will probably require
     a tunnel_members attribute to be added to the tunnel_dest_ip object,
     which will be one of the dependencies of tunnel_rid.

  2. Using the more complex approach of PRE programming described above, the
     tunnel_rid object programs multiple entries for each P2P
     tunnel, one for each (outer) nexthop ecmp member. The outer nexthop
     handle is retrieved from outer_fib (or outer_nexthop_resolution), leading
     to the list of ecmp members. The list of rid values is obtained from
     tunnel_replication_resolution. The tunnel_nexthop value is obtained by
     walking back through successive parents to the tunnel.

     Note that the more complex approach requires that tunnel_rid
     be an auto_object, with complex overrides of create_update and del to
     handle the varying number of table entries as the outer nexthop
     fluctuates with varying number of ecmp members. This is likely to require
     more state to be saved in attributes. There is also some concern about
     the order of updates when the outer nexthop fluctuates. The rid table
     entries should not be deleted until the corresponding PRE nodes are
     deleted.

#### Tunnel PRE programming

A new BMAI mc_node_vlan_member object and class will be defined for
programming of PRE nodes (and PRE ECMPs) for flooding to P2P tunnels, with
parent vlan_member. Whenever the vlan_member's port_lag_handle refers to an
object of type tunnel, an instance of the mc_node_vlan_member object needs
to be created.

In order to determine the rid(s) and egress port(s), it will be necessary to
first walk back to the tunnel by using the vlan_member's port_lag_handle
attribute, then follow object references, going from tunnel to tunnel_dest_ip
to outer_fib to tunnel_replication_resolution. The resulting
tunnel_replication_resolution handle should be saved as an attribute, so that
dependencies can be defined that trigger re-evaluation when there are changes
to the outer nexthop or its ecmp members.

**Open Issue**: What if there is no tunnel_replication_resolution object at
                the time when the vlan_member is first created?
                Under what conditions would this be re-evaluated?
                How would this re-evaluation be triggered?

There are two approaches, corresponding to the simpler and more complex
approaches to PRE programming described above:

  1. Using the simpler approach of PRE programming described above, a single
     PRE node is created by each mc_node_vlan_member object for flooding of
     one vlan to one P2P tunnel. The rid value is obtained directly from
     tunnel_replication_resolution's rid attribute. The flood_nexthop_handle
     can then be used to lookup a nexthop, then down to (the outer nexthop's)
     nexthop_resolution. The resulting mac_entry's port_lag_handle provides
     the egress port to be programmed in the PRE node.

  2. Using the more complex approach of PRE programming described above, each
     mc_node_vlan_member object programs one PRE ECMP and multiple PRE
     nodes, one for each (outer) nexthop ecmp member. The rid values are
     obtained directly from tunnel_replication_resolution's rid_list
     attribute. The outer nexthop handle is retrieved from outer_fib (or
     outer_nexthop_resolution), leading to the list of ecmp members. For each
     ecmp member, the nexthop_handle can be used to lookup a nexthop, then
     down to nexthop_resolution. The resulting mac_entry's port_lag_handle
     provides the egress port to be programmed in the PRE node.

     Note that the more complex approach requires that mc_node_vlan_member
     be an auto_object, with complex overrides of create_update and del to
     handle the varying number of PRE nodes as the outer nexthop fluctuates
     with varying number of ecmp members, as well as programming of two
     different tables. This is likely to require more state to be saved in
     attributes.

The mc_mgid class will also need additions to program a list of nodes (or 1
node and a list of ECMPs), with corresponding l1_xid_list and
l1_xid_valid_list. There is one node for all physical ports and LAGs (already
present in existing code), plus new code to add one node (or ECMP) for each
tunnel vlan member. The node_id (or ecmp_id) value should be derivable from
the vlan member or tunnel handle, so that mc_mgid programming can be carried
out in a straightforward manner without introducing any complex dependencies.

# SAI

## saibridgeport

Code needs to be added to support the new type value TUNNEL, mapping
SAI_BRIDGE_PORT_ATTR_TUNNEL_ID down to the new
SWITCH_BRIDGE_PORT_ATTR_TUNNEL_HANDLE.

## saitunnel

Code needs to be added to support SAI_TUNNEL_PEER_MODE_P2P, driving the
value down to the new SWITCH_TUNNEL_ATTR_PEER_MODE attribute, and to support
SAI_TUNNEL_ATTR_ENCAP_DST_IP which will be mapped down to the new
SWITCH_TUNNEL_ATTR_DST_IP attribute.

## saifdb

The check on bridge port type needs to be modified to allow the tunnel type
as well as the port type. When the bridge port type is tunnel, the action
needs to be mapped from FORWARD to REDIRECT.

## saivlan

It does not look like any changes are required to properly drive vlan_member
for tunnels. The current code makes a call to sai_get_port_from_bridge_port,
which looks like it will function properly even when the referenced port is a
tunnel.

# Open Issues

Open issues regarding ttl_mode and qos_mode for L2 forwarded packets.
  1. It seems like we need to add an entry in table encap_ttl for each
     eg_md.tunnel.index value, for hdr.inner_ipv4 and hdr.inner_ipv6 both not
     valid (i.e. non-IP packets), forcing it to pipe mode.
  2. If a packet is L2 forwarded into a tunnel and either hdr.inner_ipv4 or
     hdr.inner_ipv6 is valid, should we force it to ttl_mode pipe since the
     inner packet is not routed?
     How would we know not to copy or decrement the ttl upon decap?
     Answer: No, because of the latter questions.
  3. Should we force qos_mode pipe during encap of non-IP inner packets?
     Answer: No.

ARP/ND Suppression: Further investigation required.

The current p4 code does not support any tunnel stats. Note that SAI only
supports in and out octets and packets. SAI does not distinguish between
unicast, multicast, and broadcast tunnel traffic.
- For P2MP tunnel encap, counters could be placed at src_addr_rewrite or a new
  table with index eg_md.tunnel.index.
- For P2P tunnel encap, the counters would need to be placed at tunnel_nexthop
  or a new table with index eg_md.tunnel_nexthop. If the P2MP tunnel stats
  need to exclude P2P tunnel packets, some software logic would be required to
  either aggregate counters over many tunnel_nexthops, or to subtract P2P
  tunnel counts from P2MP tunnel counts.
- For P2MP tunnel decap, counters could be placed at dst_vtep and dst_vtepv6,
  or those tables could drive a new tunnel.index field that is matched in a
  later stats table.

SAL: How to program flooding when nexthop_resolution is disabled?
This is deferred to the future.

Closed: Should we change the mac_entry and vlan_member objects to use
bridge_port_handle rather than port, lag, or tunnel? No.
When nexthop resolution is disabled, the mac_entry needs to refer explicitly
to a nexthop rather than a tunnel. For this reason, the mac_entry should not
refer to a bridge_port.

# Work Item List

- Rework existing code
  - Change nexthop_index programming to use nexthop_resolution handle when
    nexthop resolution is enabled
  - Introduce id allocator for tunnel_index, changing tunnel_nexthop,
    tunnel_src_addr_rewrite, tunnel_encap_ttl programming
  - Change tunnel_nexthop parent to be nexthop_resolution (when enabled)
  - Introduce id allocator for rid, affecting multicast programming
  - p4 code: In tunnel_nexthop, action l2_tunnel_encap, set
    eg_md.flags.routed = true, add comments, check regression
  - p4 code: In tunnel_replication.rid, remove set of bd
- BMAI schema and SAI changes
  - tunnel: Add peer_mode and dst_ip.
    In tunnel_src_addr_rewrite and tunnel_encap_ttl classes, do not program
    anything if tunnel peer_mode is P2P.
  - bridge_port: Add type TUNNEL and tunnel_handle attribute
  - Run SONiC EVPN and capture SAI_FDB_ENTRY that SONiC creates.
    Verify that behavior matches the design.
  - SAI FDB handling when bridge_port has type tunnel
  - vlan_member: Rename port_lag_handle attribute and allow object type tunnel
- BMAI code
  - Create bd_to_vni_mapping object with parent tunnel_mapper_entry
  - Create tunnel_dest_ip object before_tunnel_create, similar to existing
    code before_nexthop_create. Delete tunnel_dest_ip before_tunnel_delete.
  - Add tunnel object as another parent of nexthop_resolution
    - Code additions in nexthop_resolution itself.
    - Modify code in all child objects to check whether nexthop_resolution
      represents a nexthop or a tunnel. In some cases, skip in the case of
      tunnel. In other cases, add code to retrieve relevant attributes from
      tunnel.
    - In tunnel_nexthop, add code to find corresponding P2MP tunnel
      (including definition of key_group for tunnel object) and retrieve its
      tunnel_index.
  - Rewrite dmac code for redirect into a tunnel
  - Add encap_ttl entries for non-IP packets, forcing it to pipe mode so that
    outer ttl is not zero
- Tests: L2 Known Unicast
  - Encap tests
  - Decap tests
  - Test for numerous dependencies, under various underlay and overlay changes
  - Egress interface is LAG
  - Remote VTEP reachable through ECMP
  - Coexistence with L3 VXLAN
  - Non-IP packets
- BMAI L2 VXLAN flooding code
  - Add outer_nexthop_handle attribute to outer_fib
  - Add tunnel_replication_resolution class with parent outer_fib, which picks
    one of the outer ecmp members as flood_nexthop_handle. Request one rid.
  - Add tunnel_members attribute to tunnel_dest_ip object.
  - Create tunnel_rid object with parent
    tunnel_replication_resolution, which programs the rid table.
  - Add code to compute_pre_node for the case of tunnels.
  - Add code to mc_mgid to associate one node per tunnel vlan member.
  - Create mc_node_vlan_member object with parent vlan_member, whenever the
    vlan_member refers to a P2P tunnel.
    - Add code to find the tunnel_replication_resolution object for that
      tunnel.
    - Add code to program a single PRE node for that tunnel vlan member,
      including finding the corresponding mac_entry to retrieve the
      port_lag_handle. Handle both port and lag cases.
- Tests: L2 Flooding
  - Encap tests for head-end replication
  - Remote VTEP reachable through ECMP
  - Test for numerous dependencies, under various underlay and overlay changes
- Tests: SONiC L2 EVPN
