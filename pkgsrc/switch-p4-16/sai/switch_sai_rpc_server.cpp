/*******************************************************************************
 *  Copyright (C) 2024 Intel Corporation
 *
 *  Licensed under the Apache License, Version 2.0 (the "License");
 *  you may not use this file except in compliance with the License.
 *  You may obtain a copy of the License at
 *
 *  http://www.apache.org/licenses/LICENSE-2.0
 *
 *  Unless required by applicable law or agreed to in writing,
 *  software distributed under the License is distributed on an "AS IS" BASIS,
 *  WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 *  See the License for the specific language governing permissions
 *  and limitations under the License.
 *
 *
 *  SPDX-License-Identifier: Apache-2.0
 ******************************************************************************/


// This autogenerated skeleton file illustrates how to build a server.
// You should copy it to another filename to avoid overwriting it.

#include <cstddef>
#include <cstdint>
#include <cstring>
#include <ctime>

#include <iostream>
#include <sstream>
#include <fstream>

#include <string>
#include <vector>

#include <iomanip>

#include <iostream>
#include <string>
#include "switch_sai_rpc.h"
#include <thrift/protocol/TBinaryProtocol.h>
#include <thrift/server/TSimpleServer.h>
#include <thrift/transport/TServerSocket.h>
#include <thrift/transport/TBufferTransports.h>
#include <arpa/inet.h>

#include <inttypes.h>

#ifdef __cplusplus
extern "C" {
#endif
#include <sai.h>
#ifdef __cplusplus
}
#endif

#include <saifdb.h>
#include <saivlan.h>
#include <saivirtualrouter.h>
#include <sairouterinterface.h>
#include <sairoute.h>
#include <saiswitch.h>
#include <saimirror.h>
#include <saistatus.h>

#include "arpa/inet.h"

#include "bf_switch/bf_switch.h"

#define SAI_THRIFT_LOG_DBG(msg, ...) \
  sai_thrift_timestamp_print();      \
  printf("SAI THRIFT DEBUG: %s(): " msg "\n", __FUNCTION__, ##__VA_ARGS__);

#define SAI_THRIFT_LOG_ERR(msg, ...) \
  sai_thrift_timestamp_print();      \
  printf("SAI THRIFT ERROR: %s(): " msg "\n", __FUNCTION__, ##__VA_ARGS__);

#define SAI_THRIFT_FUNC_LOG() SAI_THRIFT_LOG_DBG("Called.")

using namespace ::apache::thrift;
using namespace ::apache::thrift::protocol;
using namespace ::apache::thrift::transport;
using namespace ::apache::thrift::server;

using namespace ::switch_sai;

static pthread_mutex_t cookie_mutex;
static pthread_cond_t cookie_cv;
static void *cookie;
extern sai_object_id_t gSwitchId;

typedef std::vector<sai_thrift_attribute_t> std_sai_thrift_attr_vctr_t;

std::map<std::string, std::string> gProfileMap;
std::map<std::set<int>, std::string> gPortMap;
sai_object_id_t gSwitchId;

class switch_sai_rpcHandler : virtual public switch_sai_rpcIf {
 public:
  switch_sai_rpcHandler() noexcept {
    // Your initialization goes here
  }

  inline void sai_thrift_timestamp_print() const noexcept {
    const auto ltime = std::time(nullptr);
    const auto tm = std::localtime(&ltime);

    if (tm) {
      std::printf("%02d:%02d:%02d ", tm->tm_hour, tm->tm_min, tm->tm_sec);
    }
  }

  template <typename T>
  inline void sai_thrift_alloc_array(T *&arr, const std::size_t &size) const
      noexcept {
    arr = new (std::nothrow) T[size];
  }

  template <typename T>
  inline void sai_thrift_free_array(T *&arr) const noexcept {
    delete[] arr;
    arr = nullptr;
  }

  unsigned int sai_thrift_string_to_mac(const std::string s, unsigned char *m) {
    unsigned int i, j = 0;
    memset(m, 0, 6);
    for (i = 0; i < s.size(); i++) {
      char let = s.c_str()[i];
      if (let >= '0' && let <= '9') {
        m[j / 2] = (m[j / 2] << 4) + (let - '0');
        j++;
      } else if (let >= 'a' && let <= 'f') {
        m[j / 2] = (m[j / 2] << 4) + (let - 'a' + 10);
        j++;
      } else if (let >= 'A' && let <= 'F') {
        m[j / 2] = (m[j / 2] << 4) + (let - 'A' + 10);
        j++;
      }
    }
    return (j == 12);
  }

  void sai_thrift_string_to_v4_ip(const std::string s, unsigned int *m) {
    unsigned char r = 0;
    unsigned int i;
    *m = 0;
    for (i = 0; i < s.size(); i++) {
      char let = s.c_str()[i];
      if (let >= '0' && let <= '9') {
        r = (r * 10) + (let - '0');
      } else {
        *m = (*m << 8) | r;
        r = 0;
      }
    }
    *m = (*m << 8) | (r & 0xFF);
    *m = htonl(*m);
    return;
  }

  void sai_thrift_string_to_v6_ip(const std::string s, unsigned char *v6_ip) {
    const char *v6_str = s.c_str();
    inet_pton(AF_INET6, v6_str, v6_ip);
    return;
  }

  inline void sai_thrift_alloc_attr(sai_attribute_t *&attr,
                                    const sai_uint32_t &size) const noexcept {
    attr = new (std::nothrow) sai_attribute_t[size];
  }

  inline void sai_thrift_free_attr(sai_attribute_t *&attr) const noexcept {
    delete[] attr;
    attr = nullptr;
  }

  void sai_thrift_parse_object_id_list(
      const std::vector<sai_thrift_object_id_t> &thrift_object_id_list,
      sai_object_id_t *object_id_list) {
    std::vector<sai_thrift_object_id_t>::const_iterator it =
        thrift_object_id_list.begin();
    for (uint32_t i = 0; i < thrift_object_id_list.size(); i++, it++) {
      object_id_list[i] = (sai_object_id_t)*it;
    }
  }

  void sai_thrift_parse_ip_address(
      const sai_thrift_ip_address_t &thrift_ip_address,
      sai_ip_address_t *ip_address) {
    ip_address->addr_family =
        (sai_ip_addr_family_t)thrift_ip_address.addr_family;
    if ((sai_ip_addr_family_t)thrift_ip_address.addr_family ==
        SAI_IP_ADDR_FAMILY_IPV4) {
      sai_thrift_string_to_v4_ip(thrift_ip_address.addr.ip4,
                                 &ip_address->addr.ip4);
    } else {
      sai_thrift_string_to_v6_ip(thrift_ip_address.addr.ip6,
                                 ip_address->addr.ip6);
    }
  }

  void sai_thrift_parse_ip_prefix(
      const sai_thrift_ip_prefix_t &thrift_ip_prefix,
      sai_ip_prefix_t *ip_prefix) {
    ip_prefix->addr_family = (sai_ip_addr_family_t)thrift_ip_prefix.addr_family;
    if ((sai_ip_addr_family_t)thrift_ip_prefix.addr_family ==
        SAI_IP_ADDR_FAMILY_IPV4) {
      sai_thrift_string_to_v4_ip(thrift_ip_prefix.addr.ip4,
                                 &ip_prefix->addr.ip4);
      sai_thrift_string_to_v4_ip(thrift_ip_prefix.mask.ip4,
                                 &ip_prefix->mask.ip4);
    } else {
      sai_thrift_string_to_v6_ip(thrift_ip_prefix.addr.ip6,
                                 ip_prefix->addr.ip6);
      sai_thrift_string_to_v6_ip(thrift_ip_prefix.mask.ip6,
                                 ip_prefix->mask.ip6);
    }
  }

  void sai_thrift_parse_attribute_ids(
      const std::vector<int32_t> &thrift_attr_id_list,
      sai_attribute_t *attr_list) {
    std::vector<int32_t>::const_iterator it = thrift_attr_id_list.begin();
    for (uint32_t i = 0; i < thrift_attr_id_list.size(); i++, it++) {
      attr_list[i].id = (int32_t)*it;
    }
  }

  sai_attribute_t *sai_thrift_attribute_bridge_to_sai(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_attribute_t *sai_attrs;

    sai_attrs = (sai_attribute_t *)calloc(thrift_attr_list.size(),
                                          sizeof(sai_attribute_t));
    if (!sai_attrs) {
      SAI_THRIFT_LOG_ERR("failed to allocate sai attibutes list");
      return NULL;
    }

    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      sai_thrift_attribute_t &thrift_attr = (sai_thrift_attribute_t &)*it;
      switch (thrift_attr.id) {
        case SAI_BRIDGE_ATTR_TYPE:
          sai_attrs[i].id = thrift_attr.id;
          sai_attrs[i].value.s32 = thrift_attr.value.s32;
          break;
        case SAI_BRIDGE_ATTR_LEARN_DISABLE:
          sai_attrs[i].id = thrift_attr.id;
          sai_attrs[i].value.booldata = thrift_attr.value.booldata;
          break;
        default:
          sai_attrs[i].id = thrift_attr.id;
          sai_attrs[i].value.oid = thrift_attr.value.oid;
          break;
      }
    }

    return sai_attrs;
  }

  sai_attribute_t *sai_thrift_attribute_bridge_port_to_sai(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_attribute_t *sai_attrs;

    sai_attrs = (sai_attribute_t *)calloc(thrift_attr_list.size(),
                                          sizeof(sai_attribute_t));
    if (!sai_attrs) {
      SAI_THRIFT_LOG_ERR("failed to allocate sai attibutes list");
      return NULL;
    }

    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      sai_thrift_attribute_t &thrift_attr = (sai_thrift_attribute_t &)*it;
      switch (thrift_attr.id) {
        case SAI_BRIDGE_PORT_ATTR_TYPE:
          sai_attrs[i].id = thrift_attr.id;
          sai_attrs[i].value.s32 = thrift_attr.value.s32;
          break;
        case SAI_BRIDGE_PORT_ATTR_PORT_ID:
        case SAI_BRIDGE_PORT_ATTR_TUNNEL_ID:
        case SAI_BRIDGE_PORT_ATTR_BRIDGE_ID:
          sai_attrs[i].id = thrift_attr.id;
          sai_attrs[i].value.oid = thrift_attr.value.oid;
          break;
        case SAI_BRIDGE_PORT_ATTR_ADMIN_STATE:
          sai_attrs[i].id = thrift_attr.id;
          sai_attrs[i].value.booldata = thrift_attr.value.booldata;
          break;
        default:
          sai_attrs[i].id = thrift_attr.id;
          sai_attrs[i].value.oid = thrift_attr.value.oid;
          break;
      }
    }

    return sai_attrs;
  }

  void sai_attributes_to_sai_thrift_list(
      sai_attribute_t *sai_attrs,
      uint32_t count,
      std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    for (uint32_t i = 0; i < count; i++) {
      sai_thrift_attribute_t thrift_attr;

      thrift_attr.id = sai_attrs[i].id;
      thrift_attr.value.oid = sai_attrs[i].value.oid;

      thrift_attr_list.push_back(thrift_attr);
    }
  }

  void sai_thrift_parse_fdb_entry(
      const sai_thrift_fdb_entry_t &thrift_fdb_entry,
      sai_fdb_entry_t *fdb_entry) {
    sai_thrift_string_to_mac(thrift_fdb_entry.mac_address,
                             fdb_entry->mac_address);
    fdb_entry->bv_id = thrift_fdb_entry.bv_id;
  }

  void sai_thrift_parse_route_entry(
      const sai_thrift_route_entry_t &thrift_route_entry,
      sai_route_entry_t *route_entry) {
    route_entry->switch_id = gSwitchId;
    route_entry->vr_id = (sai_object_id_t)thrift_route_entry.vr_id;
    sai_thrift_parse_ip_prefix(thrift_route_entry.destination,
                               &route_entry->destination);
  }

  void sai_thrift_parse_neighbor_entry(
      const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
      sai_neighbor_entry_t *neighbor_entry) {
    neighbor_entry->switch_id = gSwitchId;
    neighbor_entry->rif_id = (sai_object_id_t)thrift_neighbor_entry.rif_id;
    sai_thrift_parse_ip_address(thrift_neighbor_entry.ip_address,
                                &neighbor_entry->ip_address);
  }

  void sai_thrift_parse_port_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_object_id_t **buffer_profile_list,
      sai_object_id_t **mirror_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;

    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_PORT_ATTR_ADMIN_STATE:
        case SAI_PORT_ATTR_UPDATE_DSCP:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_PORT_ATTR_PORT_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL:
        case SAI_PORT_ATTR_QOS_DEFAULT_TC:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_PORT_ATTR_QOS_INGRESS_BUFFER_PROFILE_LIST:
        case SAI_PORT_ATTR_QOS_EGRESS_BUFFER_PROFILE_LIST: {
          if (attribute.value.objlist.count > 0) {
            *buffer_profile_list = (sai_object_id_t *)malloc(
                sizeof(sai_object_id_t) * attribute.value.objlist.count);
            std::vector<sai_thrift_object_id_t>::const_iterator it2 =
                attribute.value.objlist.object_id_list.begin();
            for (uint32_t j = 0;
                 j < attribute.value.objlist.object_id_list.size();
                 j++, *it2++) {
              *buffer_profile_list[j] = (sai_object_id_t)*it2;
            }
            attr_list[i].value.objlist.count = attribute.value.objlist.count;
            attr_list[i].value.objlist.list = *buffer_profile_list;
          } else {
            *buffer_profile_list = NULL;
            attr_list[i].value.objlist.count = 0;
            attr_list[i].value.objlist.list = NULL;
          }
          break;
        }
        case SAI_PORT_ATTR_INGRESS_MIRROR_SESSION:
        case SAI_PORT_ATTR_EGRESS_MIRROR_SESSION: {
          if (attribute.value.objlist.count > 0) {
            *mirror_list = (sai_object_id_t *)malloc(
                sizeof(sai_object_id_t) * attribute.value.objlist.count);
            std::vector<sai_thrift_object_id_t>::const_iterator it2 =
                attribute.value.objlist.object_id_list.begin();
            for (uint32_t j = 0;
                 j < attribute.value.objlist.object_id_list.size();
                 j++, *it2++) {
              *mirror_list[j] = (sai_object_id_t)*it2;
            }
            attr_list[i].value.objlist.count = attribute.value.objlist.count;
            attr_list[i].value.objlist.list = *mirror_list;
          } else {
            *mirror_list = NULL;
            attr_list[i].value.objlist.count = 0;
            attr_list[i].value.objlist.list = NULL;
          }
        } break;
        case SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID:
        case SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID:
        case SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_PORT_ATTR_QOS_SCHEDULER_PROFILE_ID:
        case SAI_PORT_ATTR_QOS_DOT1P_TO_TC_MAP:
        case SAI_PORT_ATTR_QOS_DOT1P_TO_COLOR_MAP:
        case SAI_PORT_ATTR_QOS_DSCP_TO_TC_MAP:
        case SAI_PORT_ATTR_QOS_DSCP_TO_COLOR_MAP:
        case SAI_PORT_ATTR_QOS_TC_TO_QUEUE_MAP:
        case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DOT1P_MAP:
        case SAI_PORT_ATTR_QOS_TC_AND_COLOR_TO_DSCP_MAP:
        case SAI_PORT_ATTR_QOS_TC_TO_PRIORITY_GROUP_MAP:
        case SAI_PORT_ATTR_QOS_PFC_PRIORITY_TO_PRIORITY_GROUP_MAP:
        case SAI_PORT_ATTR_QOS_PFC_PRIORITY_TO_QUEUE_MAP:
        case SAI_PORT_ATTR_INGRESS_ACL:
        case SAI_PORT_ATTR_EGRESS_ACL:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_PORT_ATTR_SPEED:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_PORT_ATTR_DROP_TAGGED:
        case SAI_PORT_ATTR_DROP_UNTAGGED:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_lag_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_LAG_ATTR_PORT_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_LAG_ATTR_DROP_TAGGED:
        case SAI_LAG_ATTR_DROP_UNTAGGED:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_LAG_ATTR_INGRESS_ACL:
        case SAI_LAG_ATTR_EGRESS_ACL:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        default:
          SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
          break;
      }
    }
  }

  void sai_thrift_parse_fdb_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_FDB_ENTRY_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_FDB_ENTRY_ATTR_BRIDGE_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_FDB_ENTRY_ATTR_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_FDB_ENTRY_ATTR_ENDPOINT_IP:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_fdb_flush_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_FDB_FLUSH_ATTR_BRIDGE_PORT_ID:
          attr_list[i].value.oid = (sai_object_id_t)attribute.value.oid;
          break;
        case SAI_FDB_FLUSH_ATTR_BV_ID:
          attr_list[i].value.oid = (sai_object_id_t)attribute.value.oid;
          break;
        case SAI_FDB_FLUSH_ATTR_ENTRY_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
      }
    }
  }

  void sai_thrift_parse_vr_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V4_STATE:
        case SAI_VIRTUAL_ROUTER_ATTR_ADMIN_V6_STATE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_VIRTUAL_ROUTER_ATTR_SRC_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
      }
    }
  }

  void sai_thrift_parse_route_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ROUTE_ENTRY_ATTR_NEXT_HOP_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ROUTE_ENTRY_ATTR_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_router_interface_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ROUTER_INTERFACE_ATTR_VIRTUAL_ROUTER_ID:
        case SAI_ROUTER_INTERFACE_ATTR_PORT_ID:
        case SAI_ROUTER_INTERFACE_ATTR_VLAN_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_SRC_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
        case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V4_STATE:
        case SAI_ROUTER_INTERFACE_ATTR_ADMIN_V6_STATE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_MTU:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_INGRESS_ACL:
        case SAI_ROUTER_INTERFACE_ATTR_EGRESS_ACL:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_NEIGHBOR_MISS_PACKET_ACTION:
        case SAI_ROUTER_INTERFACE_ATTR_V4_MCAST_ENABLE:
        case SAI_ROUTER_INTERFACE_ATTR_V6_MCAST_ENABLE:
        case SAI_ROUTER_INTERFACE_ATTR_OUTER_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_INNER_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_ROUTER_INTERFACE_ATTR_NAT_ZONE_ID:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_next_hop_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_NEXT_HOP_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_NEXT_HOP_ATTR_IP:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;
        case SAI_NEXT_HOP_ATTR_ROUTER_INTERFACE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_NEXT_HOP_ATTR_TUNNEL_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_NEXT_HOP_ATTR_TUNNEL_VNI:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_NEXT_HOP_ATTR_TUNNEL_MAC:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
      }
    }
  }

  void sai_thrift_parse_lag_member_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_LAG_MEMBER_ATTR_LAG_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_LAG_MEMBER_ATTR_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_LAG_MEMBER_ATTR_EGRESS_DISABLE:
          break;
        case SAI_LAG_MEMBER_ATTR_INGRESS_DISABLE:
          break;
      }
    }
  }

  void sai_thrift_parse_stp_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_vlan_id_t **vlan_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_STP_ATTR_VLAN_LIST:
          if (attribute.value.vlanlist.vlan_count > 0) {
            *vlan_list = (sai_vlan_id_t *)malloc(
                sizeof(sai_vlan_id_t) * attribute.value.vlanlist.vlan_count);
            std::vector<sai_thrift_vlan_id_t>::const_iterator it2 =
                attribute.value.vlanlist.vlan_list.begin();
            for (uint32_t j = 0; j < attribute.value.vlanlist.vlan_list.size();
                 j++, *it2++) {
              *vlan_list[j] = (sai_vlan_id_t)*it2;
            }
            attr_list[i].value.vlanlist.count =
                attribute.value.vlanlist.vlan_count;
            attr_list[i].value.vlanlist.list = *vlan_list;
          } else {
            *vlan_list = NULL;
            attr_list[i].value.vlanlist.count = 0;
            attr_list[i].value.vlanlist.list = NULL;
          }
          break;
      }
    }
  }

  void sai_thrift_parse_neighbor_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_NEIGHBOR_ENTRY_ATTR_DST_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
      }
    }
  }

  void sai_thrift_parse_hostif_attributes(
      sai_attribute_t *attr_list,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const
      noexcept {
    if (attr_list == nullptr || thrift_attr_list.empty()) {
      SAI_THRIFT_LOG_ERR("Invalid input arguments.");
      return;
    }

    std::vector<sai_thrift_attribute_t>::const_iterator cit =
        thrift_attr_list.begin();
    for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++) {
      sai_thrift_attribute_t attribute = *cit;
      attr_list[i].id = attribute.id;

      switch (attribute.id) {
        case SAI_HOSTIF_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;

        case SAI_HOSTIF_ATTR_OBJ_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;

        case SAI_HOSTIF_ATTR_NAME:
          std::memcpy(attr_list[i].value.chardata,
                      attribute.value.chardata.c_str(),
                      SAI_HOSTIF_NAME_SIZE);
          break;

        case SAI_HOSTIF_ATTR_OPER_STATUS:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;

        case SAI_HOSTIF_ATTR_VLAN_TAG:
          attr_list[i].value.u32 = attribute.value.u32;
          break;

        default:
          SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
          break;
      }
    }
  }

  void sai_thrift_parse_hostif_trap_group_attributes(
      sai_attribute_t *attr_list,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const
      noexcept {
    if (attr_list == nullptr || thrift_attr_list.empty()) {
      SAI_THRIFT_LOG_ERR("Invalid input arguments.");
      return;
    }

    std::vector<sai_thrift_attribute_t>::const_iterator cit =
        thrift_attr_list.begin();

    for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++) {
      sai_thrift_attribute_t attribute = *cit;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_HOSTIF_TRAP_GROUP_ATTR_ADMIN_STATE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_HOSTIF_TRAP_GROUP_ATTR_QUEUE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_HOSTIF_TRAP_GROUP_ATTR_POLICER:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        default:
          SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
          break;
      }
    }
  }

  void sai_thrift_parse_hostif_trap_attributes(
      sai_attribute_t *attr_list,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const
      noexcept {
    if (attr_list == nullptr || thrift_attr_list.empty()) {
      SAI_THRIFT_LOG_ERR("Invalid input arguments.");
      return;
    }

    std::vector<sai_thrift_attribute_t>::const_iterator cit =
        thrift_attr_list.begin();

    for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++) {
      sai_thrift_attribute_t attribute = *cit;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_HOSTIF_TRAP_ATTR_TRAP_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_HOSTIF_TRAP_ATTR_EXCLUDE_PORT_LIST:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        default:
          SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
          break;
      }
    }
  }

  void sai_thrift_parse_hostif_trap_attribute(
      const sai_thrift_attribute_t &thrift_attr, sai_attribute_t *attr) {
    attr->id = thrift_attr.id;
    switch (thrift_attr.id) {
      case SAI_HOSTIF_TRAP_ATTR_PACKET_ACTION:
        attr->value.s32 = thrift_attr.value.s32;
        break;
      case SAI_HOSTIF_TRAP_ATTR_TRAP_PRIORITY:
        attr->value.u32 = thrift_attr.value.u32;
        break;
      case SAI_HOSTIF_TRAP_ATTR_TRAP_GROUP:
        attr->value.oid = thrift_attr.value.oid;
        break;
      default:
        break;
    }
  }

  sai_thrift_status_t sai_thrift_set_port_attribute(
      const sai_thrift_object_id_t port_id,
      const sai_thrift_attribute_t &thrift_attr) {
    printf("sai_thrift_set_port\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_object_id_t *buffer_profile_list = NULL;
    sai_object_id_t *mirror_list = NULL;
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;
    sai_thrift_parse_port_attributes(
        thrift_attr_list, &attr, &buffer_profile_list, &mirror_list);
    status = port_api->set_port_attribute((sai_object_id_t)port_id, &attr);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to set port attributes.");
    }
    if (buffer_profile_list) free(buffer_profile_list);
    if (mirror_list) free(mirror_list);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_router_interface_attribute(
      const sai_thrift_object_id_t rif_id,
      const sai_thrift_attribute_t &thrift_attr) {
    printf("sai_thrift_set_router_interface\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;
    sai_thrift_parse_router_interface_attributes(thrift_attr_list, &attr);
    status =
        rif_api->set_router_interface_attribute((sai_object_id_t)rif_id, &attr);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to set router interface attributes.");
    }
    return status;
  }

  sai_thrift_status_t sai_thrift_create_fdb_entry(
      const sai_thrift_fdb_entry_t &thrift_fdb_entry,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_fdb_entry\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;
    sai_fdb_entry_t fdb_entry;

    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_STATUS_INVALID_PARAMETER;
    }

    sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_fdb_attributes(thrift_attr_list, attr_list);
    status = fdb_api->create_fdb_entry(&fdb_entry, attr_count, attr_list);
    free(attr_list);
    return status;
  }

  sai_thrift_status_t sai_thrift_delete_fdb_entry(
      const sai_thrift_fdb_entry_t &thrift_fdb_entry) {
    printf("sai_thrift_delete_fdb_entry\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;
    sai_fdb_entry_t fdb_entry;
    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_fdb_entry(thrift_fdb_entry, &fdb_entry);
    status = fdb_api->remove_fdb_entry(&fdb_entry);
    return status;
  }

  sai_thrift_status_t sai_thrift_flush_fdb_entries(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_flush_fdb_entries\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_fdb_api_t *fdb_api;
    status = sai_api_query(SAI_API_FDB, (void **)&fdb_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_STATUS_INVALID_PARAMETER;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_fdb_flush_attributes(thrift_attr_list, attr_list);
    status = fdb_api->flush_fdb_entries(gSwitchId, attr_count, attr_list);
    free(attr_list);
    return status;
  }

  void sai_thrift_parse_vlan_attributes(
      const std_sai_thrift_attr_vctr_t &thrift_attr_list,
      sai_attribute_t *attr_list) {
    SAI_THRIFT_LOG_DBG("Called.");

    std_sai_thrift_attr_vctr_t::const_iterator cit = thrift_attr_list.begin();

    for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++) {
      sai_thrift_attribute_t attribute = *cit;
      attr_list[i].id = attribute.id;

      switch (attribute.id) {
        case SAI_VLAN_ATTR_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;

        default:
          SAI_THRIFT_LOG_ERR("Failed to parse VLAN attributes.");
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_vlan(
      const std_sai_thrift_attr_vctr_t &thrift_attr_list) {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_vlan_api_t *vlan_api = nullptr;
    auto status =
        sai_api_query(SAI_API_VLAN, reinterpret_cast<void **>(&vlan_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get VLAN API.");
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list = nullptr;
    sai_uint32_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_vlan_attributes(thrift_attr_list, attr_list);

    sai_object_id_t vlanObjId = 0;
    status = vlan_api->create_vlan(&vlanObjId, gSwitchId, attr_size, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      return vlanObjId;
    }

    SAI_THRIFT_LOG_ERR("Failed to create VLAN.");

    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_remove_vlan(
      const sai_thrift_object_id_t vlan_oid) {
    printf("sai_thrift_delete_vlan\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = vlan_api->remove_vlan(vlan_oid);
    return status;
  }

  void sai_thrift_get_vlan_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t vlan_id,
      const std::vector<sai_thrift_vlan_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_get_vlan_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    if (thrift_counter_ids.size() == 0) {
      return;
    }

    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = vlan_api->get_vlan_stats(
        (sai_object_id_t)vlan_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }

    free(counter_ids);
    free(counters);

    return;
  }

  sai_thrift_status_t sai_thrift_clear_vlan_stats(
      const sai_thrift_object_id_t vlan_id,
      const std::vector<sai_thrift_vlan_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_clear_vlan_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    if (thrift_counter_ids.size() == 0) {
      return SAI_STATUS_INVALID_PARAMETER;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = vlan_api->clear_vlan_stats(
        (sai_object_id_t)vlan_id, number_of_counters, counter_ids);

    free(counter_ids);
    return status;
  }

  void sai_thrift_parse_vlan_attribute(
      const sai_thrift_attribute_t &thrift_attr, sai_attribute_t *attr) {
    attr->id = thrift_attr.id;
    switch (thrift_attr.id) {
      case SAI_VLAN_ATTR_INGRESS_ACL:
      case SAI_VLAN_ATTR_EGRESS_ACL:
      case SAI_VLAN_ATTR_STP_INSTANCE:
        attr->value.oid = thrift_attr.value.oid;
        break;
      case SAI_VLAN_ATTR_LEARN_DISABLE:
        attr->value.booldata = thrift_attr.value.booldata;
        break;
      default:
        attr->value.u32 = thrift_attr.value.u32;
        break;
    }
  }
  sai_thrift_status_t sai_thrift_set_vlan_attribute(
      const sai_thrift_object_id_t vlan_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api = NULL;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr;
    memset(&attr, 0, sizeof(attr));
    sai_thrift_parse_vlan_attribute(thrift_attr, &attr);
    status = vlan_api->set_vlan_attribute((sai_object_id_t)vlan_id, &attr);
    return status;
  }

  void sai_thrift_get_vlan_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t vlan_id) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    sai_attribute_t vlan_member_list_object_attribute;
    sai_thrift_attribute_t thrift_vlan_member_list_attribute;
    sai_object_list_t *vlan_member_list_object;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    vlan_member_list_object_attribute.id = SAI_VLAN_ATTR_MEMBER_LIST;
    vlan_member_list_object_attribute.value.objlist.list =
        (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * 256);
    vlan_member_list_object_attribute.value.objlist.count = 256;
    vlan_api->get_vlan_attribute(
        vlan_id, 1, &vlan_member_list_object_attribute);

    thrift_attr_list.attr_count = 1;
    std::vector<sai_thrift_attribute_t> &attr_list = thrift_attr_list.attr_list;
    thrift_vlan_member_list_attribute.id = SAI_VLAN_ATTR_MEMBER_LIST;
    thrift_vlan_member_list_attribute.value.objlist.count =
        vlan_member_list_object_attribute.value.objlist.count;
    std::vector<sai_thrift_object_id_t> &vlan_member_list =
        thrift_vlan_member_list_attribute.value.objlist.object_id_list;
    vlan_member_list_object = &vlan_member_list_object_attribute.value.objlist;
    for (uint32_t index = 0;
         index < vlan_member_list_object_attribute.value.objlist.count;
         index++) {
      vlan_member_list.push_back(
          (sai_thrift_object_id_t)vlan_member_list_object->list[index]);
    }
    attr_list.push_back(thrift_vlan_member_list_attribute);
    free(vlan_member_list_object_attribute.value.objlist.list);
  }

  sai_thrift_object_id_t sai_thrift_create_vlan_member(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_vlan_member\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    sai_object_id_t vlan_member_id = 0;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_STATUS_INVALID_PARAMETER;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_vlan_member_attributes(thrift_attr_list, attr_list);
    vlan_api->create_vlan_member(
        &vlan_member_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return vlan_member_id;
  }

  void sai_thrift_parse_vlan_member_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_VLAN_MEMBER_ATTR_VLAN_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_VLAN_MEMBER_ATTR_BRIDGE_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_VLAN_MEMBER_ATTR_VLAN_TAGGING_MODE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
      }
    }
  }

  void sai_thrift_get_vlan_member_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t vlan_member_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    sai_attribute_t attr[3];

    SAI_THRIFT_FUNC_LOG();

    thrift_attr_list.attr_count = 0;

    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain vlan_api, status:%d", status);
      return;
    }

    attr[0].id = SAI_VLAN_MEMBER_ATTR_VLAN_ID;
    attr[1].id = SAI_VLAN_MEMBER_ATTR_BRIDGE_PORT_ID;
    attr[2].id = SAI_VLAN_MEMBER_ATTR_VLAN_TAGGING_MODE;

    status = vlan_api->get_vlan_member_attribute(vlan_member_id, 3, attr);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain vlan member attributes, status:%d",
                         status);
      return;
    }

    sai_attributes_to_sai_thrift_list(attr, 3, thrift_attr_list.attr_list);
  }

  // Hash
  void sai_thrift_parse_hash_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      int32_t **hash_attr_list) {
    sai_thrift_attribute_t attribute;
    std::vector<sai_thrift_attribute_t>::const_iterator it1;
    it1 = thrift_attr_list.begin();
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      auto &hash_list = attribute.value.s32list;
      switch (attribute.id) {
        case SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST:
          if (hash_list.count > 0) {
            std::vector<int32_t>::iterator it2 = hash_list.s32list.begin();
            (*hash_attr_list) =
                (int32_t *)calloc(hash_list.count, sizeof(int32_t));
            uint32_t j = 0;
            for (; it2 != hash_list.s32list.end(); ++it2, ++j) {
              (*hash_attr_list)[j] = static_cast<int32_t>(*it2);
            }
            attr_list[i].value.s32list.count = hash_list.count;
            attr_list[i].value.s32list.list = (*hash_attr_list);
          } else {
            (*hash_attr_list) = NULL;
            attr_list[i].value.s32list.count = 0;
            attr_list[i].value.s32list.list = NULL;
          }
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_hash(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_hash\n");

    sai_object_id_t hash_id = 0;
    int32_t *hash_attr_list = nullptr;
    sai_hash_api_t *hash_api = nullptr;
    sai_status_t status = SAI_STATUS_SUCCESS;

    // Getting the API function pointer
    status = sai_api_query(SAI_API_HASH, reinterpret_cast<void **>(&hash_api));
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get HASH API.");
      return SAI_NULL_OBJECT_ID;
    }

    // Setting number of attribute present
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)calloc(attr_count, sizeof(sai_attribute_t));
    sai_thrift_parse_hash_attributes(
        thrift_attr_list, attr_list, &hash_attr_list);
    status = hash_api->create_hash(&hash_id, gSwitchId, attr_count, attr_list);
    if (hash_attr_list) free(hash_attr_list);
    free(attr_list);
    return hash_id;
  }

  // Remove Hash Object
  sai_thrift_status_t sai_thrift_remove_hash(
      const sai_thrift_object_id_t hash_id) {
    printf("sai_thrift_remove_hash\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;
    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = hash_api->remove_hash((sai_object_id_t)hash_id);
    return status;
  }

  // Setting the hash attributes
  sai_thrift_status_t sai_thrift_set_hash_attribute(
      const sai_thrift_object_id_t hash_id,
      const sai_thrift_attribute_t &thrift_attr) {
    printf("sai_thrift_set_hash_attributes\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;
    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    int32_t *hash_attr_list = nullptr;

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t));
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_thrift_parse_hash_attributes(
        thrift_attr_list, attr_list, &hash_attr_list);

    status = hash_api->set_hash_attribute((sai_object_id_t)hash_id, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to set lag attributes.");
    }

    if (hash_attr_list) free(hash_attr_list);
    free(attr_list);
    return status;
  }

  // Getting the Hash attributes
  void sai_thrift_get_hash_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t hash_id) {
    printf("sai_thrift_get_hash_attributes\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_hash_api_t *hash_api;
    sai_attribute_t hash_sai_attr;
    sai_thrift_attribute_t hash_thrift_attr;

    status = sai_api_query(SAI_API_HASH, (void **)&hash_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain hash_api, status:%d", status);
      return;
    }

    // Get the hash attribute from SAI
    hash_sai_attr.id = SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST;
    hash_sai_attr.value.s32list.list = (int32_t *)malloc(sizeof(int32_t) * 256);
    hash_sai_attr.value.s32list.count = 256;
    hash_api->get_hash_attribute((sai_object_id_t)hash_id, 1, &hash_sai_attr);

    // Packing the out list
    hash_thrift_attr.id = SAI_HASH_ATTR_NATIVE_HASH_FIELD_LIST;
    hash_thrift_attr.value.s32list.count = hash_sai_attr.value.s32list.count;
    std::vector<int32_t> &hash_fields_list =
        hash_thrift_attr.value.s32list.s32list;

    thrift_attr_list.attr_count = 1;
    std::vector<sai_thrift_attribute_t> &attr_list = thrift_attr_list.attr_list;
    for (uint32_t idx = 0; idx < hash_sai_attr.value.s32list.count; ++idx) {
      hash_fields_list.push_back(hash_sai_attr.value.s32list.list[idx]);
    }
    attr_list.push_back(hash_thrift_attr);
    free(hash_sai_attr.value.s32list.list);
  }
  // End of Hash

  int32_t sai_thrift_clear_port_stats(
      const sai_thrift_object_id_t port_id,
      const std::vector<sai_thrift_port_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    if (thrift_counter_ids.size() == 0) {
      return SAI_STATUS_INVALID_PARAMETER;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());

    status =
        port_api->clear_port_stats(port_id, number_of_counters, counter_ids);

    free(counter_ids);
    return status;
  }

  int32_t sai_thrift_clear_port_all_stats(
      const sai_thrift_object_id_t port_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    status = port_api->clear_port_all_stats(port_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_remove_vlan_member(
      const sai_thrift_object_id_t vlan_member_id) {
    printf("sai_thrift_remove_vlan_member\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_vlan_api_t *vlan_api;
    status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = vlan_api->remove_vlan_member((sai_object_id_t)vlan_member_id);
    return status;
  }

  void sai_thrift_get_vlan_id(sai_thrift_result_t &ret,
                              sai_thrift_object_id_t vlan_id) {
    sai_attribute_t vlan_attr;
    sai_vlan_api_t *vlan_api;

    SAI_THRIFT_FUNC_LOG();

    ret.status = sai_api_query(SAI_API_VLAN, (void **)&vlan_api);
    if (ret.status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain vlan_api, status:%d", ret.status);
      return;
    }

    vlan_attr.id = SAI_VLAN_ATTR_VLAN_ID;
    ret.status =
        vlan_api->get_vlan_attribute((sai_object_id_t)vlan_id, 1, &vlan_attr);
    if (ret.status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to get vlan ID, status:%d", ret.status);
      return;
    }

    ret.data.u16 = vlan_attr.value.u16;
  }

  sai_thrift_object_id_t sai_thrift_create_virtual_router(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_virtual_router\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_virtual_router_api_t *vr_api;
    sai_object_id_t vr_id = 0;
    status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&vr_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_vr_attributes(thrift_attr_list, attr_list);
    vr_api->create_virtual_router(&vr_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return vr_id;
  }

  sai_thrift_status_t sai_thrift_remove_virtual_router(
      const sai_thrift_object_id_t vr_id) {
    printf("sai_thrift_remove_virtual_router\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_virtual_router_api_t *vr_api;
    status = sai_api_query(SAI_API_VIRTUAL_ROUTER, (void **)&vr_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = vr_api->remove_virtual_router((sai_object_id_t)vr_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_create_route(
      const sai_thrift_route_entry_t &thrift_route_entry,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_route\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_api_t *route_api;
    sai_route_entry_t route_entry;
    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_STATUS_INVALID_PARAMETER;
    }
    sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_route_attributes(thrift_attr_list, attr_list);
    status = route_api->create_route_entry(&route_entry, attr_count, attr_list);
    free(attr_list);
    SAI_THRIFT_LOG_DBG("Exit.");
    return status;
  }

  sai_thrift_status_t sai_thrift_remove_route(
      const sai_thrift_route_entry_t &thrift_route_entry) {
    printf("sai_thrift_remove_route\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_route_api_t *route_api;
    sai_route_entry_t route_entry;
    status = sai_api_query(SAI_API_ROUTE, (void **)&route_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_route_entry(thrift_route_entry, &route_entry);
    status = route_api->remove_route_entry(&route_entry);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_router_interface(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_router_interface\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    sai_object_id_t rif_id = 0;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_router_interface_attributes(thrift_attr_list, attr_list);
    status = rif_api->create_router_interface(
        &rif_id, gSwitchId, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      printf("Failed to create router interface\n");
    }
    free(attr_list);
    return rif_id;
  }

  sai_thrift_status_t sai_thrift_remove_router_interface(
      const sai_thrift_object_id_t rif_id) {
    printf("sai_thrift_remove_router_interface\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = rif_api->remove_router_interface((sai_object_id_t)rif_id);
    return status;
  }

  void sai_thrift_get_router_interface_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t rif_id,
      const std::vector<sai_thrift_router_interface_stat_counter_t>
          &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_get_router_interface_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    if (thrift_counter_ids.size() == 0) {
      return;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)calloc(thrift_counter_ids.size(), sizeof(uint64_t));
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = rif_api->get_router_interface_stats(
        (sai_object_id_t)rif_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }
    free(counter_ids);
    free(counters);
    return;
  }

  sai_thrift_status_t sai_thrift_clear_router_interface_stats(
      const sai_thrift_object_id_t rif_id,
      const std::vector<sai_thrift_router_interface_stat_counter_t>
          &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_clear_router_interface_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_router_interface_api_t *rif_api;
    status = sai_api_query(SAI_API_ROUTER_INTERFACE, (void **)&rif_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    if (thrift_counter_ids.size() == 0) {
      return SAI_STATUS_INVALID_PARAMETER;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = rif_api->clear_router_interface_stats(
        (sai_object_id_t)rif_id, number_of_counters, counter_ids);

    free(counter_ids);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_next_hop\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *nhop_api;
    sai_object_id_t nhop_id = 0;
    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&nhop_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_next_hop_attributes(thrift_attr_list, attr_list);
    status =
        nhop_api->create_next_hop(&nhop_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return nhop_id;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop(
      const sai_thrift_object_id_t next_hop_id) {
    printf("sai_thrift_remove_next_hop\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_next_hop_api_t *nhop_api;
    status = sai_api_query(SAI_API_NEXT_HOP, (void **)&nhop_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = nhop_api->remove_next_hop((sai_object_id_t)next_hop_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_lag(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_lag\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    sai_object_id_t lag_id = 0;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    status = lag_api->create_lag(&lag_id, gSwitchId, 0, nullptr);
    return lag_id;
  }

  sai_thrift_status_t sai_thrift_remove_lag(
      const sai_thrift_object_id_t lag_id) {
    printf("sai_thrift_remove_lag\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = lag_api->remove_lag((sai_object_id_t)lag_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_lag_member(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_lag_member\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    sai_object_id_t lag_member_id;
    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_lag_member_attributes(thrift_attr_list, attr_list);
    status = lag_api->create_lag_member(
        &lag_member_id, gSwitchId, attr_count, attr_list);
    return lag_member_id;
  }

  sai_thrift_status_t sai_thrift_remove_lag_member(
      const sai_thrift_object_id_t lag_member_id) {
    printf("sai_thrift_remove_lag_member\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = lag_api->remove_lag_member(lag_member_id);
    return status;
  }

  void sai_thrift_get_lag_member_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t lag_member_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t sai_attrs[2];
    sai_lag_api_t *lag_api;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain lag_api, status:%d", status);
      return;
    }

    SAI_THRIFT_FUNC_LOG();

    sai_attrs[0].id = SAI_LAG_MEMBER_ATTR_LAG_ID;
    sai_attrs[1].id = SAI_LAG_MEMBER_ATTR_PORT_ID;

    status = lag_api->get_lag_member_attribute(lag_member_id, 2, sai_attrs);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain lag member attributes, status:%d",
                         status);
      return;
    }

    sai_attributes_to_sai_thrift_list(sai_attrs, 2, thrift_attr_list.attr_list);
  }

  sai_thrift_object_id_t sai_thrift_create_stp_entry(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_stp\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    sai_vlan_id_t *vlan_list;
    sai_object_id_t stp_id;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_stp_attributes(thrift_attr_list, attr_list, &vlan_list);
    status = (sai_object_id_t)stp_api->create_stp(
        &stp_id, gSwitchId, attr_count, attr_list);
    if (vlan_list) free(vlan_list);
    free(attr_list);
    return stp_id;
  }

  sai_thrift_status_t sai_thrift_remove_stp_entry(
      const sai_thrift_object_id_t stp_id) {
    printf("sai_thrift_remove_stp\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = (sai_thrift_status_t)stp_api->remove_stp(stp_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_stp_port_state(
      const sai_thrift_object_id_t stp_id,
      const sai_thrift_object_id_t port_id,
      const sai_thrift_port_stp_port_state_t stp_port_state) {
    printf("sai_thrift_set_stp_port_state\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr[1];
    std::memset(attr, '\0', sizeof(attr));
    attr[0].id = SAI_STP_PORT_ATTR_STATE;
    attr[0].value.s32 = stp_port_state;
    status = stp_api->set_stp_port_attribute(port_id, attr);
    return status;
  }

  sai_thrift_port_stp_port_state_t sai_thrift_get_stp_port_state(
      const sai_thrift_object_id_t stp_id,
      const sai_thrift_object_id_t port_id) {
    printf("sai_thrift_get_stp_port_state\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_stp_api_t *stp_api;
    status = sai_api_query(SAI_API_STP, (void **)&stp_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr[1];
    std::memset(attr, '\0', sizeof(attr));
    attr[0].id = SAI_STP_PORT_ATTR_STATE;
    status = stp_api->get_stp_port_attribute(port_id, 1, attr);
    return (sai_thrift_port_stp_port_state_t)attr[0].value.s32;
  }

  sai_thrift_status_t sai_thrift_create_neighbor_entry(
      const sai_thrift_neighbor_entry_t &thrift_neighbor_entry,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_neighbor_entry\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_api_t *neighbor_api;
    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    sai_neighbor_entry_t neighbor_entry;
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return status;
    }
    sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_neighbor_attributes(thrift_attr_list, attr_list);
    status = neighbor_api->create_neighbor_entry(
        &neighbor_entry, attr_count, attr_list);
    free(attr_list);
    return status;
  }

  sai_thrift_status_t sai_thrift_remove_neighbor_entry(
      const sai_thrift_neighbor_entry_t &thrift_neighbor_entry) {
    printf("sai_thrift_remove_neighbor_entry\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_neighbor_api_t *neighbor_api;
    sai_neighbor_entry_t neighbor_entry;
    status = sai_api_query(SAI_API_NEIGHBOR, (void **)&neighbor_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_thrift_parse_neighbor_entry(thrift_neighbor_entry, &neighbor_entry);
    status = neighbor_api->remove_neighbor_entry(&neighbor_entry);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_get_cpu_port_id() {
    sai_status_t status;
    sai_attribute_t attr;
    sai_switch_api_t *switch_api;
    sai_thrift_object_id_t cpu_port_id;
    const char *f_name = __FUNCTION__;
    printf("%s\n", f_name);
    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("%s failed to obtain switch_api, status:%d\n", f_name, status);
      return SAI_NULL_OBJECT_ID;
    }
    attr.id = SAI_SWITCH_ATTR_CPU_PORT;
    status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
    if (status != SAI_STATUS_SUCCESS) {
      printf("%s failed, status:%d\n", f_name, status);
      return SAI_NULL_OBJECT_ID;
    }
    cpu_port_id = (sai_thrift_object_id_t)attr.value.oid;
    return cpu_port_id;
  }

  sai_thrift_object_id_t sai_thrift_get_default_router_id() {
    sai_status_t status;
    sai_attribute_t attr;
    sai_switch_api_t *switch_api;
    sai_thrift_object_id_t default_router_id;
    const char *f_name = __FUNCTION__;
    printf("%s\n", f_name);
    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("%s failed to obtain switch_api, status:%d\n", f_name, status);
      return SAI_NULL_OBJECT_ID;
    }
    attr.id = SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID;
    status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
    if (status != SAI_STATUS_SUCCESS) {
      printf("%s. Failed to get switch virtual router ID, status %d",
             f_name,
             status);
      return SAI_NULL_OBJECT_ID;
    }
    default_router_id = (sai_thrift_object_id_t)attr.value.oid;
    return default_router_id;
  }

  sai_thrift_object_id_t sai_thrift_get_default_1q_bridge_id() {
    sai_switch_api_t *switch_api;
    sai_attribute_t attr;
    sai_status_t status;

    SAI_THRIFT_FUNC_LOG();

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain switch_api, status:%d\n", status);
      return SAI_NULL_OBJECT_ID;
    }

    attr.id = SAI_SWITCH_ATTR_DEFAULT_1Q_BRIDGE_ID;
    status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get switch virtual router ID, status %d",
                         status);
      return SAI_NULL_OBJECT_ID;
    }

    return (sai_thrift_object_id_t)attr.value.oid;
  }

  void sai_thrift_get_default_vlan_id(sai_thrift_result_t &ret) {
    sai_switch_api_t *switch_api;
    sai_attribute_t attr;

    SAI_THRIFT_FUNC_LOG();

    ret.status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (ret.status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain switch_api, status:%d", ret.status);
      return;
    }

    attr.id = SAI_SWITCH_ATTR_DEFAULT_VLAN_ID;
    ret.status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
    if (ret.status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to get switch default vlan ID, status:%d",
                         ret.status);
      return;
    }

    ret.data.oid = (sai_thrift_object_id_t)attr.value.oid;
  }

  sai_thrift_object_id_t sai_thrift_get_default_trap_group() {
    sai_status_t status;
    sai_attribute_t attr;
    sai_switch_api_t *switch_api;
    sai_thrift_object_id_t default_trap_group;
    const char *f_name = __FUNCTION__;
    printf("%s\n", f_name);
    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("%s failed to obtain switch_api, status:%d\n", f_name, status);
      return SAI_NULL_OBJECT_ID;
    }
    attr.id = SAI_SWITCH_ATTR_DEFAULT_TRAP_GROUP;
    status = switch_api->get_switch_attribute(gSwitchId, 1, &attr);
    if (status != SAI_STATUS_SUCCESS) {
      printf("%s. Failed to get switch default trap group, status %d",
             f_name,
             status);
      return SAI_NULL_OBJECT_ID;
    }
    default_trap_group = (sai_thrift_object_id_t)attr.value.oid;
    return default_trap_group;
  }

  void sai_thrift_get_acl_table_attribute_by_id(
      sai_thrift_attribute_t &_return,
      const int32_t id,
      sai_thrift_object_id_t table_id) {
    printf("sai_thrift_get_acl_table_attribute_by_id\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t attr = {};
    sai_acl_api_t *acl_api;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("sai_api_query failed!!!\n");
      return;
    }

    switch (id) {
      case SAI_ACL_TABLE_ATTR_AVAILABLE_ACL_ENTRY:
      case SAI_ACL_TABLE_ATTR_AVAILABLE_ACL_COUNTER:
        attr.id = id;
        status = acl_api->get_acl_table_attribute(
            (sai_object_id_t)table_id, 1, &attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = id;
        _return.value.u32 = attr.value.u32;
        break;
    }
  }

  void sai_thrift_get_switch_attribute_by_id(sai_thrift_attribute_t &_return,
                                             const int32_t id) {
    printf("sai_thrift_get_switch_attribute_by_id\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;
    sai_attribute_t switch_attr = {};
    sai_thrift_acl_resource_t thrift_acl;
    uint32_t aclresource_size;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("sai_api_query failed!!!\n");
      return;
    }
    switch (id) {
      case SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_SEED:
        switch_attr.id = SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_SEED;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_SEED;
        _return.value.u32 = switch_attr.value.u32;
        break;
      case SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_SEED:
        switch_attr.id = SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_SEED;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_SEED;
        _return.value.u32 = switch_attr.value.u32;
        break;
      /* SONiC CRM */
      case SAI_SWITCH_ATTR_AVAILABLE_IPV4_ROUTE_ENTRY:
      case SAI_SWITCH_ATTR_AVAILABLE_IPV6_ROUTE_ENTRY:
      case SAI_SWITCH_ATTR_AVAILABLE_IPV4_NEXTHOP_ENTRY:
      case SAI_SWITCH_ATTR_AVAILABLE_IPV6_NEXTHOP_ENTRY:
      case SAI_SWITCH_ATTR_AVAILABLE_IPV4_NEIGHBOR_ENTRY:
      case SAI_SWITCH_ATTR_AVAILABLE_IPV6_NEIGHBOR_ENTRY:
      case SAI_SWITCH_ATTR_AVAILABLE_NEXT_HOP_GROUP_MEMBER_ENTRY:
      case SAI_SWITCH_ATTR_AVAILABLE_NEXT_HOP_GROUP_ENTRY:
      case SAI_SWITCH_ATTR_AVAILABLE_FDB_ENTRY:
        switch_attr.id = id;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = id;
        _return.value.u32 = switch_attr.value.u32;
        break;
      /* SONiC CRM: available ACL tables and groups */
      case SAI_SWITCH_ATTR_AVAILABLE_ACL_TABLE:
      case SAI_SWITCH_ATTR_AVAILABLE_ACL_TABLE_GROUP:
        switch_attr.id = id;
        switch_attr.value.aclresource.count = 0;
        switch_attr.value.aclresource.list = NULL;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = id;
        _return.value.aclresource.count = 0;
        if (switch_attr.value.aclresource.count == 0) break;
        aclresource_size =
            sizeof(sai_acl_resource_t) * switch_attr.value.aclresource.count;
        switch_attr.value.aclresource.list =
            (sai_acl_resource_t *)malloc(aclresource_size);
        memset(switch_attr.value.aclresource.list, 0, aclresource_size);
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          free(switch_attr.value.aclresource.list);
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        for (uint32_t i = 0; i < switch_attr.value.aclresource.count; i++) {
          memset((void *)&thrift_acl, 0, sizeof(sai_thrift_acl_resource_t));
          thrift_acl.stage = switch_attr.value.aclresource.list[i].stage;
          thrift_acl.bind_point =
              switch_attr.value.aclresource.list[i].bind_point;
          thrift_acl.avail_num =
              switch_attr.value.aclresource.list[i].avail_num;
          _return.value.aclresource.aclresourcelist.push_back(thrift_acl);
        }
        _return.value.aclresource.count = switch_attr.value.aclresource.count;
        free(switch_attr.value.aclresource.list);
        break;
      case SAI_SWITCH_ATTR_ACL_USER_META_DATA_RANGE:
        switch_attr.id = SAI_SWITCH_ATTR_ACL_USER_META_DATA_RANGE;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = SAI_SWITCH_ATTR_ACL_USER_META_DATA_RANGE;
        _return.value.u32range.min = switch_attr.value.u32range.min;
        _return.value.u32range.max = switch_attr.value.u32range.max;
        break;
      case SAI_SWITCH_ATTR_FDB_AGING_TIME:
        switch_attr.id = id;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = id;
        _return.value.u32 = switch_attr.value.u32;
        break;
      case SAI_SWITCH_ATTR_LAG_HASH:
      case SAI_SWITCH_ATTR_LAG_HASH_IPV4:
      case SAI_SWITCH_ATTR_LAG_HASH_IPV6:
      case SAI_SWITCH_ATTR_ECMP_HASH_IPV4:
      case SAI_SWITCH_ATTR_ECMP_HASH_IPV6: {
        switch_attr.id = id;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = id;
        _return.value.oid = switch_attr.value.oid;
        break;
      }
      case SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_OFFSET:
        switch_attr.id = SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_OFFSET;
        status = switch_api->get_switch_attribute(gSwitchId, 1, &switch_attr);
        if (status != SAI_STATUS_SUCCESS) {
          printf("%s. Failed to get switch attribute %d, status %d",
                 __FUNCTION__,
                 id,
                 status);
          return;
        }
        _return.id = SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_OFFSET;
        _return.value.u8 = switch_attr.value.u8;
        break;

      default:
        status = SAI_STATUS_NOT_SUPPORTED;
        SAI_THRIFT_LOG_DBG("Thrift code to fetch id %d not implemented", id);
        break;
    }
  }

  void sai_thrift_get_switch_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list) {
    printf("sai_thrift_get_switch_attribute\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;
    sai_attribute_t max_port_attribute;
    sai_attribute_t port_list_object_attribute;
    sai_thrift_attribute_t thrift_port_list_attribute;
    sai_object_list_t *port_list_object;
    int max_ports = 0;
    int thrift_attr_count = 0;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("sai_api_query failed!!!\n");
      return;
    }

    std::vector<sai_thrift_attribute_t> &attr_list = thrift_attr_list.attr_list;

    max_port_attribute.id = SAI_SWITCH_ATTR_PORT_NUMBER;
    switch_api->get_switch_attribute(gSwitchId, 1, &max_port_attribute);
    max_ports = max_port_attribute.value.u32;

    if (max_ports > 0) {
      port_list_object_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
      port_list_object_attribute.value.objlist.list =
          (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * max_ports);
      port_list_object_attribute.value.objlist.count = max_ports;
      switch_api->get_switch_attribute(
          gSwitchId, 1, &port_list_object_attribute);

      thrift_attr_list.attr_count = ++thrift_attr_count;
      thrift_port_list_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
      thrift_port_list_attribute.value.objlist.count = max_ports;
      std::vector<sai_thrift_object_id_t> &port_list =
          thrift_port_list_attribute.value.objlist.object_id_list;
      port_list_object = &port_list_object_attribute.value.objlist;
      for (int index = 0; index < max_ports; index++) {
        port_list.push_back(
            (sai_thrift_object_id_t)port_list_object->list[index]);
      }
      attr_list.push_back(thrift_port_list_attribute);
      free(port_list_object_attribute.value.objlist.list);
    }

    sai_attribute_t vr_id_attr;
    sai_thrift_attribute_t thrift_vr_id_attr;
    thrift_attr_list.attr_count = ++thrift_attr_count;
    vr_id_attr.id = SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID;
    switch_api->get_switch_attribute(gSwitchId, 1, &vr_id_attr);
    thrift_vr_id_attr.id = SAI_SWITCH_ATTR_DEFAULT_VIRTUAL_ROUTER_ID;
    thrift_vr_id_attr.value.oid = vr_id_attr.value.oid;
    attr_list.push_back(thrift_vr_id_attr);
  }

  sai_thrift_status_t sai_thrift_set_switch_attribute(
      const sai_thrift_attribute_t &thrift_attr) {
    printf("sai_thrift_set_switch_attribute\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;
    sai_attribute_t attr;
    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("sai_api_query failed!!!\n");
      return status;
    }

    sai_thrift_parse_switch_attribute(thrift_attr, &attr);
    status = switch_api->set_switch_attribute(gSwitchId, &attr);
    return status;
  }

  void sai_thrift_parse_switch_attribute(
      const sai_thrift_attribute_t &thrift_attr, sai_attribute_t *attr) {
    attr->id = thrift_attr.id;

    switch (thrift_attr.id) {
      case SAI_SWITCH_ATTR_SRC_MAC_ADDRESS:
      case SAI_SWITCH_ATTR_VXLAN_DEFAULT_ROUTER_MAC:
        sai_thrift_string_to_mac(thrift_attr.value.mac, attr->value.mac);
        break;

      case SAI_SWITCH_ATTR_FDB_UNICAST_MISS_PACKET_ACTION:
      case SAI_SWITCH_ATTR_FDB_BROADCAST_MISS_PACKET_ACTION:
      case SAI_SWITCH_ATTR_FDB_MULTICAST_MISS_PACKET_ACTION:
      case SAI_SWITCH_ATTR_SWITCHING_MODE:
        attr->value.s32 = thrift_attr.value.s32;
        break;
      case SAI_SWITCH_ATTR_COUNTER_REFRESH_INTERVAL:
        attr->value.u32 = thrift_attr.value.u32;
        break;
      case SAI_SWITCH_ATTR_FDB_AGING_TIME:
        attr->value.u32 = thrift_attr.value.u32;
        break;
      case SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_SEED:
        attr->value.u32 = thrift_attr.value.u32;
        break;
      case SAI_SWITCH_ATTR_LAG_DEFAULT_HASH_SEED:
        attr->value.u32 = thrift_attr.value.u32;
        break;
      case SAI_SWITCH_ATTR_LAG_HASH:
      case SAI_SWITCH_ATTR_ECMP_HASH_IPV4:
      case SAI_SWITCH_ATTR_ECMP_HASH_IPV6:
      case SAI_SWITCH_ATTR_ECMP_HASH:
      case SAI_SWITCH_ATTR_LAG_HASH_IPV4:
      case SAI_SWITCH_ATTR_LAG_HASH_IPV6:
        attr->value.oid = thrift_attr.value.oid;
        break;
      case SAI_SWITCH_ATTR_ECMP_DEFAULT_HASH_OFFSET:
        attr->value.u8 = thrift_attr.value.u8;
        break;
    }
  }

  void sai_thrift_get_port_list_by_front_port(
      sai_thrift_attribute_t &thrift_attr) {
    printf("sai_thrift_get_port_list_by_front_port\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;
    sai_port_api_t *port_api;
    sai_attribute_t max_port_attribute;
    sai_attribute_t port_list_object_attribute;
    sai_attribute_t port_lane_list_attribute;
    sai_thrift_attribute_t thrift_port_list_attribute;
    int max_ports = 0;
    extern std::map<std::set<int>, std::string> gPortMap;
    std::map<std::set<int>, std::string>::iterator gPortMapIt;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("sai_api_query failed!!!\n");
      return;
    }

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("sai_api_query failed!!!\n");
      return;
    }

    max_port_attribute.id = SAI_SWITCH_ATTR_PORT_NUMBER;
    switch_api->get_switch_attribute(gSwitchId, 1, &max_port_attribute);
    max_ports = max_port_attribute.value.u32;
    if (max_ports == 0) {
      printf("SAI_SWITCH_ATTR_PORT_NUMBER = 0\n");
      return;
    }

    port_list_object_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
    port_list_object_attribute.value.objlist.list =
        (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * max_ports);
    port_list_object_attribute.value.objlist.count = max_ports;
    switch_api->get_switch_attribute(gSwitchId, 1, &port_list_object_attribute);
    std::map<int, sai_object_id_t> front_to_sai_map;

    for (int i = 0; i < max_ports; i++) {
      port_lane_list_attribute.id = SAI_PORT_ATTR_HW_LANE_LIST;
      port_lane_list_attribute.value.u32list.list =
          (uint32_t *)malloc(sizeof(uint32_t) * 4);
      port_lane_list_attribute.value.u32list.count = 4;
      port_api->get_port_attribute(
          port_list_object_attribute.value.objlist.list[i],
          1,
          &port_lane_list_attribute);

      std::set<int> port_lanes;
      uint32_t laneCnt = port_lane_list_attribute.value.u32list.count;
      for (uint32_t j = 0; j < laneCnt; j++) {
        port_lanes.insert(port_lane_list_attribute.value.u32list.list[j]);
      }

      gPortMapIt = gPortMap.find(port_lanes);
      if (gPortMapIt != gPortMap.end()) {
        std::string front_port_alias = gPortMapIt->second.c_str();
        std::string front_port_number;
        int front_num_to_sort = 0;
        for (uint32_t k = 0; k < front_port_alias.length(); k++) {
          if (front_port_alias[k] >= '0' && front_port_alias[k] <= '9') {
            front_port_number.push_back(front_port_alias[k]);
          }
        }
        front_num_to_sort = std::stoi(front_port_number);
        front_to_sai_map.insert(std::pair<int, sai_object_id_t>(
            front_num_to_sort,
            port_list_object_attribute.value.objlist.list[i]));
      } else {
        printf("DIDN'T FOUND FRONT PORT FOR LANE SET\n");
      }
      free(port_lane_list_attribute.value.u32list.list);
    }

    sai_thrift_attribute_t &attr = thrift_attr;
    thrift_port_list_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
    thrift_port_list_attribute.value.objlist.count = max_ports;
    std::vector<sai_thrift_object_id_t> &port_list =
        thrift_port_list_attribute.value.objlist.object_id_list;
    for (std::map<int, sai_object_id_t>::iterator it = front_to_sai_map.begin();
         it != front_to_sai_map.end();
         it++) {
      port_list.push_back((sai_thrift_object_id_t)it->second);
    }
    attr = thrift_port_list_attribute;
    free(port_list_object_attribute.value.objlist.list);
  }

  sai_thrift_object_id_t sai_thrift_get_port_id_by_front_port(
      const std::string &port_name) {
    printf("sai_thrift_get_port_id_by_front_port\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_switch_api_t *switch_api;
    sai_port_api_t *port_api;
    sai_attribute_t max_port_attribute;
    sai_attribute_t port_list_object_attribute;
    sai_attribute_t port_lane_list_attribute;
    int max_ports = 0;
    sai_thrift_object_id_t port_id;
    extern std::map<std::set<int>, std::string> gPortMap;
    std::map<std::set<int>, std::string>::iterator gPortMapIt;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("sai_api_query failed!!!\n");
      return SAI_NULL_OBJECT_ID;
    }
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      printf("sai_api_query failed!!!\n");
      return SAI_NULL_OBJECT_ID;
    }
    for (gPortMapIt = gPortMap.begin(); gPortMapIt != gPortMap.end();
         gPortMapIt++) {
      if (gPortMapIt->second == port_name) {
        break;
      }
    }

    std::set<int> lane_set;
    if (gPortMapIt != gPortMap.end()) {
      lane_set = gPortMapIt->first;
    } else {
      printf("Didn't find matching port to received name!\n");
      return SAI_NULL_OBJECT_ID;
    }
    max_port_attribute.id = SAI_SWITCH_ATTR_PORT_NUMBER;
    switch_api->get_switch_attribute(gSwitchId, 1, &max_port_attribute);
    max_ports = max_port_attribute.value.u32;

    if (max_ports == 0) {
      printf("SAI_SWITCH_ATTR_PORT_NUMBER = 0\n");
      return SAI_NULL_OBJECT_ID;
    }

    port_list_object_attribute.id = SAI_SWITCH_ATTR_PORT_LIST;
    port_list_object_attribute.value.objlist.list =
        (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * max_ports);
    port_list_object_attribute.value.objlist.count = max_ports;
    switch_api->get_switch_attribute(gSwitchId, 1, &port_list_object_attribute);

    for (int i = 0; i < max_ports; i++) {
      port_lane_list_attribute.id = SAI_PORT_ATTR_HW_LANE_LIST;
      port_lane_list_attribute.value.u32list.list =
          (uint32_t *)malloc(sizeof(uint32_t) * 4);
      port_lane_list_attribute.value.u32list.count = 4;
      port_api->get_port_attribute(
          port_list_object_attribute.value.objlist.list[i],
          1,
          &port_lane_list_attribute);

      std::set<int> port_lanes;
      uint32_t laneCnt = port_lane_list_attribute.value.u32list.count;
      for (uint32_t j = 0; j < laneCnt; j++) {
        port_lanes.insert(port_lane_list_attribute.value.u32list.list[j]);
      }

      if (port_lanes == lane_set) {
        port_id = (sai_thrift_object_id_t)
                      port_list_object_attribute.value.objlist.list[i];
        free(port_list_object_attribute.value.objlist.list);
        free(port_lane_list_attribute.value.u32list.list);
        return port_id;
      }
      free(port_lane_list_attribute.value.u32list.list);
    }
    printf("Didn't find port\n");
    free(port_list_object_attribute.value.objlist.list);
    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_object_id_t sai_thrift_create_bridge(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;
    sai_attribute_t *sai_attrs;
    sai_object_id_t bridge_id = 0;

    SAI_THRIFT_FUNC_LOG();

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
      return status;
    }

    sai_attrs = sai_thrift_attribute_bridge_to_sai(thrift_attr_list);
    if (!sai_attrs) {
      status = SAI_STATUS_NO_MEMORY;
      return status;
    }

    status = bridge_api->create_bridge(
        &bridge_id, gSwitchId, thrift_attr_list.size(), sai_attrs);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to create bridge, status:%d", status);
    }
    free(sai_attrs);
    return bridge_id;
  }

  sai_thrift_status_t sai_thrift_remove_bridge(
      const sai_thrift_object_id_t bridge_id) {
    sai_bridge_api_t *bridge_api;
    sai_status_t status;

    SAI_THRIFT_FUNC_LOG();

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
      return status;
    }

    return bridge_api->remove_bridge((sai_object_id_t)bridge_id);
  }

  void sai_thrift_get_bridge_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t bridge_id,
      const std::vector<sai_thrift_bridge_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_get_bridge_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api = NULL;
    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);

    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    if (thrift_counter_ids.size() == 0) {
      return;
    }

    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = bridge_api->get_bridge_stats(
        bridge_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }

    free(counter_ids);
    free(counters);

    return;
  }

  void sai_thrift_create_bridge_port(
      sai_thrift_result_t &ret,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_bridge_api_t *bridge_api;
    sai_attribute_t *sai_attrs;

    SAI_THRIFT_FUNC_LOG();

    ret.status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (ret.status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", ret.status);
      return;
    }

    sai_attrs = sai_thrift_attribute_bridge_port_to_sai(thrift_attr_list);
    if (!sai_attrs) {
      ret.status = SAI_STATUS_NO_MEMORY;
      return;
    }

    ret.status =
        bridge_api->create_bridge_port((sai_object_id_t *)&ret.data.oid,
                                       gSwitchId,
                                       thrift_attr_list.size(),
                                       sai_attrs);
    if (ret.status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to create bridge port, status:%d", ret.status);
    }
    free(sai_attrs);
  }

  sai_thrift_status_t sai_thrift_remove_bridge_port(
      const sai_thrift_object_id_t bridge_port_id) {
    sai_bridge_api_t *bridge_api;
    sai_status_t status;

    SAI_THRIFT_FUNC_LOG();

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
      return status;
    }

    return bridge_api->remove_bridge_port((sai_object_id_t)bridge_port_id);
  }

  void sai_thrift_get_bridge_port_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t bridge_port_id,
      const std::vector<sai_thrift_bridge_port_stat_counter_t>
          &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_get_bridge_port_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api = NULL;
    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);

    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    if (thrift_counter_ids.size() == 0) {
      return;
    }

    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = bridge_api->get_bridge_port_stats(
        bridge_port_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }

    free(counter_ids);
    free(counters);

    return;
  }
  void sai_thrift_get_bridge_port_list(sai_thrift_result_t &ret,
                                       sai_thrift_object_id_t bridge_id) {
    std::vector<sai_thrift_object_id_t> &port_list =
        ret.data.objlist.object_id_list;
    sai_bridge_api_t *bridge_api;
    uint32_t max_ports = 512;
    sai_attribute_t attr;

    SAI_THRIFT_FUNC_LOG();

    ret.status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (ret.status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", ret.status);
      return;
    }

    attr.id = SAI_BRIDGE_ATTR_PORT_LIST;
    attr.value.objlist.list =
        (sai_object_id_t *)calloc(max_ports, sizeof(sai_object_id_t));
    attr.value.objlist.count = max_ports;

    ret.status = bridge_api->get_bridge_attribute(bridge_id, 1, &attr);
    if (attr.value.objlist.count > max_ports) {
      /* retry one more time with a bigger list */
      max_ports = attr.value.objlist.count;
      attr.value.objlist.list = (sai_object_id_t *)realloc(
          attr.value.objlist.list, max_ports * sizeof(sai_object_id_t));

      if (ret.status != SAI_STATUS_SUCCESS) {
        ret.status = bridge_api->get_bridge_attribute(bridge_id, 1, &attr);
      }
    }

    if (ret.status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to obtain bridge ports list, status:%d",
                         ret.status);
      free(attr.value.objlist.list);
      return;
    }

    for (uint32_t index = 0; index < attr.value.objlist.count; index++) {
      port_list.push_back(
          (sai_thrift_object_id_t)attr.value.objlist.list[index]);
    }
    free(attr.value.objlist.list);
  }

  sai_thrift_status_t sai_thrift_set_bridge_port_attribute(
      const sai_thrift_object_id_t bridge_port_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;
    sai_attribute_t attr;

    SAI_THRIFT_FUNC_LOG();

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
      return status;
    }

    attr.id = thrift_attr.id;

    switch (attr.id) {
      case SAI_BRIDGE_PORT_ATTR_ADMIN_STATE:
        attr.value.booldata = thrift_attr.value.booldata;
        break;
      case SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE:
        attr.value.s32 = thrift_attr.value.s32;
        break;

      default:
        attr.value.oid = thrift_attr.value.oid;
        break;
    }

    return bridge_api->set_bridge_port_attribute(bridge_port_id, &attr);
  }

  void sai_thrift_get_bridge_port_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t bridge_port_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_bridge_api_t *bridge_api;
    uint32_t attr_count = 0;
    sai_attribute_t attr[3];

    // SAI_THRIFT_FUNC_LOG();

    thrift_attr_list.attr_count = 0;

    status = sai_api_query(SAI_API_BRIDGE, (void **)&bridge_api);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge_api, status:%d", status);
      return;
    }

    attr[0].id = SAI_BRIDGE_PORT_ATTR_TYPE;
    attr[1].id = SAI_BRIDGE_PORT_ATTR_BRIDGE_ID;
    attr_count = 2;

    status =
        bridge_api->get_bridge_port_attribute(bridge_port_id, attr_count, attr);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge port type, status:%d",
                         status);
      return;
    }

    sai_attributes_to_sai_thrift_list(
        attr, attr_count, thrift_attr_list.attr_list);

    switch (attr[0].value.s32) {
      case SAI_BRIDGE_PORT_TYPE_PORT:
        attr[0].id = SAI_BRIDGE_PORT_ATTR_FDB_LEARNING_MODE;
        attr[1].id = SAI_BRIDGE_PORT_ATTR_PORT_ID;
        attr_count = 2;
        break;

      case SAI_BRIDGE_PORT_TYPE_TUNNEL:
        attr[0].id = SAI_BRIDGE_PORT_ATTR_TUNNEL_ID;
        attr_count = 1;
        break;

      default:
        return;
    }

    status =
        bridge_api->get_bridge_port_attribute(bridge_port_id, attr_count, attr);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("failed to obtain bridge port attributes, status:%d",
                         status);
      return;
    }

    sai_attributes_to_sai_thrift_list(
        attr, attr_count, thrift_attr_list.attr_list);
  }

  sai_thrift_object_id_t sai_thrift_create_hostif(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_hostif_attributes(attr_list, thrift_attr_list);

    sai_object_id_t hif_oid = 0;
    status =
        hostif_api->create_hostif(&hif_oid, gSwitchId, attr_size, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return hif_oid;
    }

    SAI_THRIFT_LOG_ERR("Failed to create OID.");

    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_remove_hostif(
      const sai_thrift_object_id_t thrift_hif_id) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    status = hostif_api->remove_hostif(thrift_hif_id);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to remove OID.");
    return SAI_STATUS_FAILURE;
  }

  sai_thrift_status_t sai_thrift_set_hostif_attribute(
      const sai_thrift_object_id_t thrift_hif_id,
      const sai_thrift_attribute_t &thrift_attr) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    const std::vector<sai_thrift_attribute_t> thrift_attr_list = {thrift_attr};

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_hostif_trap_group_attributes(attr_list, thrift_attr_list);

    status = hostif_api->set_hostif_attribute(thrift_hif_id, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to set attribute.");

    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap_group(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_hostif_trap_group_attributes(attr_list, thrift_attr_list);

    sai_object_id_t hostif_trap_group_oid = 0;
    status = hostif_api->create_hostif_trap_group(
        &hostif_trap_group_oid, gSwitchId, attr_size, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return hostif_trap_group_oid;
    }

    SAI_THRIFT_LOG_ERR("Failed to create OID.");

    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_remove_hostif_trap_group(
      const sai_thrift_object_id_t thrift_hostif_trap_group_id) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    status = hostif_api->remove_hostif_trap_group(thrift_hostif_trap_group_id);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to remove OID.");

    return status;
  }

  sai_thrift_status_t sai_thrift_set_hostif_trap_group_attribute(
      const sai_thrift_object_id_t thrift_hostif_trap_group_id,
      const sai_thrift_attribute_t &thrift_attr) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    const std::vector<sai_thrift_attribute_t> thrift_attr_list = {thrift_attr};

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_hostif_trap_group_attributes(attr_list, thrift_attr_list);

    status = hostif_api->set_hostif_trap_group_attribute(
        thrift_hostif_trap_group_id, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to set attribute.");

    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_trap(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_hostif_trap_attributes(attr_list, thrift_attr_list);

    sai_object_id_t hostif_trap_oid = 0;
    status = hostif_api->create_hostif_trap(
        &hostif_trap_oid, gSwitchId, attr_size, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return hostif_trap_oid;
    }

    SAI_THRIFT_LOG_ERR("Failed to create OID.");

    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_remove_hostif_trap(
      const sai_thrift_object_id_t thrift_hostif_trap_id) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    status = hostif_api->remove_hostif_trap(thrift_hostif_trap_id);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to remove OID.");

    return status;
  }

  sai_thrift_status_t sai_thrift_set_hostif_trap_attribute(
      const sai_thrift_object_id_t thrift_hostif_trap_id,
      const sai_thrift_attribute_t &thrift_attr) {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    const std::vector<sai_thrift_attribute_t> thrift_attr_list = {thrift_attr};

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_hostif_trap_attributes(attr_list, thrift_attr_list);

    status =
        hostif_api->set_hostif_trap_attribute(thrift_hostif_trap_id, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to set attribute.");

    return status;
  }

  void sai_thrift_parse_hostif_table_entry_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it1 =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it1++) {
      attribute = (sai_thrift_attribute_t)*it1;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_CHANNEL_TYPE:
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_TYPE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_OBJ_ID:
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_HOST_IF:
        case SAI_HOSTIF_TABLE_ENTRY_ATTR_TRAP_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_hostif_table_entry(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_hostif_table_entry_attributes(thrift_attr_list, attr_list);

    sai_object_id_t hostif_table_entry_oid = 0;
    status = hostif_api->create_hostif_table_entry(
        &hostif_table_entry_oid, gSwitchId, attr_size, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return hostif_table_entry_oid;
    }

    SAI_THRIFT_LOG_ERR("Failed to create OID.");

    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_remove_hostif_table_entry(
      const sai_thrift_object_id_t thrift_hostif_table_entry_id) {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_hostif_api_t *hostif_api = nullptr;
    auto status =
        sai_api_query(SAI_API_HOSTIF, reinterpret_cast<void **>(&hostif_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    status =
        hostif_api->remove_hostif_table_entry(thrift_hostif_table_entry_id);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to remove OID.");

    return status;
  }

  void sai_thrift_parse_acl_table_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_TABLE_ATTR_ACL_STAGE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_ACL_TABLE_ATTR_ACL_BIND_POINT_TYPE_LIST: {
          int count = attribute.value.s32list.s32list.size();
          sai_int32_t *aclbp_list = NULL;
          if (count > 0) {
            std::vector<sai_int32_t>::const_iterator it2 =
                attribute.value.s32list.s32list.begin();
            aclbp_list = (sai_int32_t *)malloc(sizeof(sai_int32_t) * count);
            for (int j = 0; j < count; j++, it2++)
              *(aclbp_list + j) = (sai_int32_t)*it2;
          }
          attr_list[i].value.s32list.list = aclbp_list;
          attr_list[i].value.s32list.count = count;
        } break;
        case SAI_ACL_TABLE_ATTR_FIELD_SRC_IPV6:
        case SAI_ACL_TABLE_ATTR_FIELD_DST_IPV6:
        case SAI_ACL_TABLE_ATTR_FIELD_SRC_MAC:
        case SAI_ACL_TABLE_ATTR_FIELD_DST_MAC:
        case SAI_ACL_TABLE_ATTR_FIELD_SRC_IP:
        case SAI_ACL_TABLE_ATTR_FIELD_DST_IP:
        case SAI_ACL_TABLE_ATTR_FIELD_IN_PORTS:
        case SAI_ACL_TABLE_ATTR_FIELD_OUT_PORTS:
        case SAI_ACL_TABLE_ATTR_FIELD_IN_PORT:
        case SAI_ACL_TABLE_ATTR_FIELD_OUT_PORT:
        case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_ID:
        case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_PRI:
        case SAI_ACL_TABLE_ATTR_FIELD_OUTER_VLAN_CFI:
        case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_ID:
        case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_PRI:
        case SAI_ACL_TABLE_ATTR_FIELD_INNER_VLAN_CFI:
        case SAI_ACL_TABLE_ATTR_FIELD_L4_SRC_PORT:
        case SAI_ACL_TABLE_ATTR_FIELD_L4_DST_PORT:
        case SAI_ACL_TABLE_ATTR_FIELD_ETHER_TYPE:
        case SAI_ACL_TABLE_ATTR_FIELD_IP_PROTOCOL:
        case SAI_ACL_TABLE_ATTR_FIELD_DSCP:
        case SAI_ACL_TABLE_ATTR_FIELD_ECN:
        case SAI_ACL_TABLE_ATTR_FIELD_TTL:
        case SAI_ACL_TABLE_ATTR_FIELD_TOS:
        case SAI_ACL_TABLE_ATTR_FIELD_IP_FLAGS:
        case SAI_ACL_TABLE_ATTR_FIELD_TCP_FLAGS:
        case SAI_ACL_TABLE_ATTR_FIELD_ACL_IP_TYPE:
        case SAI_ACL_TABLE_ATTR_FIELD_ACL_IP_FRAG:
        case SAI_ACL_TABLE_ATTR_FIELD_IPV6_FLOW_LABEL:
        case SAI_ACL_TABLE_ATTR_FIELD_TC:
        case SAI_ACL_TABLE_ATTR_FIELD_ACL_RANGE_TYPE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_TABLE_ATTR_ACL_ACTION_TYPE_LIST: {
          int count = attribute.value.s32list.s32list.size();
          int32_t *action_type_list = NULL;
          if (count > 0) {
            std::vector<int32_t>::const_iterator it2 =
                attribute.value.s32list.s32list.begin();
            action_type_list = (int32_t *)malloc(sizeof(int32_t) * count);
            for (int j = 0; j < count; j++, it2++)
              *(action_type_list + j) = (int32_t)*it2;
          }
          attr_list[i].value.s32list.list = action_type_list;
          attr_list[i].value.s32list.count = count;
        } break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_acl_entry_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_ENTRY_ATTR_TABLE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_PRIORITY:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_ACL_ENTRY_ATTR_ADMIN_STATE:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IPV6:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_IPV6:
          sai_thrift_string_to_v6_ip(attribute.value.aclfield.data.ip6,
                                     attr_list[i].value.aclfield.data.ip6);
          sai_thrift_string_to_v6_ip(attribute.value.aclfield.mask.ip6,
                                     attr_list[i].value.aclfield.mask.ip6);
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_MAC:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_MAC:
          sai_thrift_string_to_mac(attribute.value.aclfield.data.mac,
                                   attr_list[i].value.aclfield.data.mac);
          sai_thrift_string_to_mac(attribute.value.aclfield.mask.mac,
                                   attr_list[i].value.aclfield.mask.mac);
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_SRC_IP:
        case SAI_ACL_ENTRY_ATTR_FIELD_DST_IP:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_SRC_IP:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_DST_IP:
          sai_thrift_string_to_v4_ip(attribute.value.aclfield.data.ip4,
                                     &attr_list[i].value.aclfield.data.ip4);
          sai_thrift_string_to_v4_ip(attribute.value.aclfield.mask.ip4,
                                     &attr_list[i].value.aclfield.mask.ip4);
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORT:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_IN_PORTS: {
          int count =
              attribute.value.aclfield.data.objlist.object_id_list.size();
          sai_object_id_t *oid_list = NULL;
          if (count > 0) {
            std::vector<sai_thrift_object_id_t>::const_iterator it2 =
                attribute.value.aclfield.data.objlist.object_id_list.begin();
            oid_list =
                (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * count);
            for (int j = 0; j < count; j++, it2++)
              *(oid_list + j) = (sai_object_id_t)*it2;
          }
          attr_list[i].value.aclfield.data.objlist.list = oid_list;
          attr_list[i].value.aclfield.data.objlist.count = count;
        } break;
        case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORT:
          attr_list[i].value.aclfield.data.oid =
              attribute.value.aclfield.data.oid;
          break;
        /*
        case SAI_ACL_ENTRY_ATTR_FIELD_OUT_PORTS:
        */
        case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_PRI:
        case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_CFI:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_PRI:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_CFI:
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_OUTER_VLAN_ID:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_VLAN_ID:
        case SAI_ACL_ENTRY_ATTR_FIELD_L4_SRC_PORT:
        case SAI_ACL_ENTRY_ATTR_FIELD_L4_DST_PORT:
        case SAI_ACL_ENTRY_ATTR_FIELD_ETHER_TYPE:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_L4_SRC_PORT:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_L4_DST_PORT:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_ETHER_TYPE:
          attr_list[i].value.aclfield.data.u16 =
              attribute.value.aclfield.data.u16;
          attr_list[i].value.aclfield.mask.u16 =
              attribute.value.aclfield.mask.u16;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_IP_PROTOCOL:
        case SAI_ACL_ENTRY_ATTR_FIELD_IPV6_NEXT_HEADER:
        case SAI_ACL_ENTRY_ATTR_FIELD_INNER_IP_PROTOCOL:
        case SAI_ACL_ENTRY_ATTR_FIELD_DSCP:
        case SAI_ACL_ENTRY_ATTR_FIELD_ECN:
        case SAI_ACL_ENTRY_ATTR_FIELD_TTL:
        case SAI_ACL_ENTRY_ATTR_FIELD_TOS:
        case SAI_ACL_ENTRY_ATTR_FIELD_IP_FLAGS:
        case SAI_ACL_ENTRY_ATTR_FIELD_TCP_FLAGS:
        case SAI_ACL_ENTRY_ATTR_FIELD_ACL_IP_TYPE:
        case SAI_ACL_ENTRY_ATTR_FIELD_TC:
          attr_list[i].value.aclfield.data.u8 =
              attribute.value.aclfield.data.u8;
          attr_list[i].value.aclfield.mask.u8 =
              attribute.value.aclfield.mask.u8;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_ACL_IP_FRAG:
          attr_list[i].value.aclfield.data.s32 =
              attribute.value.aclfield.data.s32;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_IPV6_FLOW_LABEL:
          attr_list[i].value.aclfield.data.u16 =
              attribute.value.aclfield.data.u16;
          attr_list[i].value.aclfield.mask.u16 =
              attribute.value.aclfield.mask.u16;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_EGRESS:
        case SAI_ACL_ENTRY_ATTR_ACTION_MIRROR_INGRESS: {
          sai_object_id_t *oid_list = NULL;
          oid_list = (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * 1);
          oid_list[0] = attribute.value.aclaction.parameter.oid;
          attr_list[i].value.aclaction.parameter.objlist.count = 1;
          attr_list[i].value.aclaction.parameter.objlist.list = oid_list;
        } break;
        case SAI_ACL_ENTRY_ATTR_ACTION_REDIRECT:
          attr_list[i].value.aclaction.parameter.oid =
              attribute.value.aclaction.parameter.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_SET_POLICER:
          attr_list[i].value.aclaction.parameter.oid =
              attribute.value.aclaction.parameter.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_PACKET_ACTION:
          attr_list[i].value.aclaction.enable =
              attribute.value.aclaction.enable;
          attr_list[i].value.aclaction.parameter.u32 =
              attribute.value.aclaction.parameter.u32;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_SET_PACKET_COLOR:
          attr_list[i].value.aclaction.enable =
              attribute.value.aclaction.enable;
          attr_list[i].value.aclaction.parameter.s32 =
              attribute.value.aclaction.parameter.s32;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_SET_TC:
          attr_list[i].value.aclaction.enable =
              attribute.value.aclaction.enable;
          attr_list[i].value.aclaction.parameter.u8 =
              attribute.value.aclaction.parameter.u8;
          break;

        case SAI_ACL_ENTRY_ATTR_FIELD_TUNNEL_VNI:
          attr_list[i].value.aclfield.data.u32 =
              attribute.value.aclfield.data.u32;
          attr_list[i].value.aclfield.mask.u32 =
              attribute.value.aclfield.mask.u32;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_DTEL_INT_SESSION:
        case SAI_ACL_ENTRY_ATTR_ACTION_INGRESS_SAMPLEPACKET_ENABLE:
          attr_list[i].value.aclaction.enable =
              attribute.value.aclaction.enable;
          attr_list[i].value.aclaction.parameter.oid =
              attribute.value.aclaction.parameter.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_DTEL_DROP_REPORT_ENABLE:
        case SAI_ACL_ENTRY_ATTR_ACTION_DTEL_TAIL_DROP_REPORT_ENABLE:
        case SAI_ACL_ENTRY_ATTR_ACTION_DTEL_REPORT_ALL_PACKETS:
          attr_list[i].value.aclaction.enable =
              attribute.value.aclaction.enable;
          attr_list[i].value.aclaction.parameter.booldata =
              attribute.value.aclaction.parameter.booldata;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_ACL_DTEL_FLOW_OP:
          attr_list[i].value.aclaction.enable =
              attribute.value.aclaction.enable;
          attr_list[i].value.aclaction.parameter.s32 =
              attribute.value.aclaction.parameter.s32;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_DTEL_FLOW_SAMPLE_PERCENT:
          attr_list[i].value.aclaction.enable =
              attribute.value.aclaction.enable;
          attr_list[i].value.aclaction.parameter.u8 =
              attribute.value.aclaction.parameter.u8;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_ACL_RANGE_TYPE: {
          int count =
              attribute.value.aclfield.data.objlist.object_id_list.size();
          sai_object_id_t *oid_list = NULL;
          if (count > 0) {
            std::vector<sai_thrift_object_id_t>::const_iterator it2 =
                attribute.value.aclfield.data.objlist.object_id_list.begin();
            oid_list =
                (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * count);
            for (int j = 0; j < count; j++, it2++)
              *(oid_list + j) = (sai_object_id_t)*it2;
          }
          attr_list[i].value.aclfield.data.objlist.list = oid_list;
          attr_list[i].value.aclfield.data.objlist.count = count;
        } break;
        case SAI_ACL_ENTRY_ATTR_ACTION_COUNTER:
          attr_list[i].value.aclaction.parameter.oid =
              attribute.value.aclaction.parameter.oid;
          break;
        case SAI_ACL_ENTRY_ATTR_FIELD_ACL_USER_META:
          attr_list[i].value.aclfield.data.u32 =
              attribute.value.aclfield.data.u32;
          attr_list[i].value.aclfield.mask.u32 =
              attribute.value.aclfield.mask.u32;
          break;
        case SAI_ACL_ENTRY_ATTR_ACTION_SET_ACL_META_DATA:
          attr_list[i].value.aclaction.enable =
              attribute.value.aclaction.enable;
          attr_list[i].value.aclaction.parameter.u32 =
              attribute.value.aclaction.parameter.u32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_acl_table_group_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_TABLE_GROUP_ATTR_ACL_STAGE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_ACL_TABLE_GROUP_ATTR_ACL_BIND_POINT_TYPE_LIST: {
          int count = attribute.value.s32list.s32list.size();
          sai_int32_t *s32_list = NULL;
          if (count > 0) {
            std::vector<sai_int32_t>::const_iterator it2 =
                attribute.value.s32list.s32list.begin();
            s32_list = (sai_int32_t *)malloc(sizeof(sai_int32_t) * count);
            for (int j = 0; j < count; j++, it2++)
              *(s32_list + j) = (sai_int32_t)*it2;
          }
          attr_list[i].value.s32list.list = s32_list;
          attr_list[i].value.s32list.count = count;
        } break;
        case SAI_ACL_TABLE_GROUP_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_acl_table_group_member_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_TABLE_GROUP_MEMBER_ATTR_ACL_TABLE_GROUP_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ACL_TABLE_GROUP_MEMBER_ATTR_ACL_TABLE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ACL_TABLE_GROUP_MEMBER_ATTR_PRIORITY:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_convert_to_acl_counter_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_COUNTER_ATTR_TABLE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_COUNTER_ATTR_PACKETS:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_ACL_COUNTER_ATTR_BYTES:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
      }
    }
  }

  void sai_thrift_convert_to_acl_thrift_counter_attributes(
      sai_attribute_t *attr_list,
      uint32_t attr_count,
      std::vector<sai_thrift_attribute_value_t> &thrift_attr_value_list) {
    sai_attribute_t attribute;
    sai_thrift_attribute_value_t thrift_attribute_value;
    for (uint32_t i = 0; i < attr_count; i++) {
      attribute = attr_list[i];
      switch (attribute.id) {
        case SAI_ACL_COUNTER_ATTR_TABLE_ID:
          thrift_attribute_value.oid = attribute.value.oid;
          break;
        case SAI_ACL_COUNTER_ATTR_ENABLE_PACKET_COUNT:
          thrift_attribute_value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_COUNTER_ATTR_ENABLE_BYTE_COUNT:
          thrift_attribute_value.booldata = attribute.value.booldata;
          break;
        case SAI_ACL_COUNTER_ATTR_PACKETS:
          thrift_attribute_value.u64 = attribute.value.u64;
          break;
        case SAI_ACL_COUNTER_ATTR_BYTES:
          thrift_attribute_value.u64 = attribute.value.u64;
          break;
      }
      thrift_attr_value_list.push_back(thrift_attribute_value);
    }
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_table = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_acl_table_attributes(thrift_attr_list, attr_list);
    status =
        acl_api->create_acl_table(&acl_table, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return acl_table;
  }

  sai_thrift_status_t sai_thrift_remove_acl_table(
      const sai_thrift_object_id_t acl_table_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_table(acl_table_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_entry(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_entry = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_acl_entry_attributes(thrift_attr_list, attr_list);
    status =
        acl_api->create_acl_entry(&acl_entry, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return acl_entry;
  }

  sai_thrift_status_t sai_thrift_set_acl_entry_attribute(
      const sai_thrift_object_id_t acl_entry_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_attribute_t attr;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);

    sai_thrift_parse_acl_entry_attributes(thrift_attr_list, &attr);
    status = acl_api->set_acl_entry_attribute(acl_entry_id, &attr);
    return status;
  }

  sai_thrift_status_t sai_thrift_remove_acl_entry(
      const sai_thrift_object_id_t acl_entry) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_entry(acl_entry);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_group(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_table_group_id = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_acl_table_group_attributes(thrift_attr_list, attr_list);
    status = acl_api->create_acl_table_group(
        &acl_table_group_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return acl_table_group_id;
  }

  sai_thrift_status_t sai_thrift_remove_acl_table_group(
      const sai_thrift_object_id_t acl_table_group_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_table_group(acl_table_group_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_table_group_member(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_table_group_member_id = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_acl_table_group_member_attributes(thrift_attr_list,
                                                       attr_list);
    status = acl_api->create_acl_table_group_member(
        &acl_table_group_member_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return acl_table_group_member_id;
  }

  sai_thrift_status_t sai_thrift_remove_acl_table_group_member(
      const sai_thrift_object_id_t acl_table_group_member_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_acl_api_t *acl_api;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_table_group_member(acl_table_group_member_id);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_acl_counter(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_counter_id = 0ULL;
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;

    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_convert_to_acl_counter_attributes(thrift_attr_list, attr_list);
    status = acl_api->create_acl_counter(
        &acl_counter_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return acl_counter_id;
  }

  sai_thrift_status_t sai_thrift_remove_acl_counter(
      const sai_thrift_object_id_t acl_counter_id) {
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_counter(acl_counter_id);
    return status;
  }

  void sai_thrift_get_acl_counter_attribute(
      std::vector<sai_thrift_attribute_value_t> &thrift_attr_values,
      const sai_thrift_object_id_t acl_counter_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_acl_api_t *acl_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    uint32_t attr_count = thrift_attr_ids.size();

    if (attr_count == 0) {
      return;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    memset(attr_list,
           0x0,
           sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
    status = acl_api->get_acl_counter_attribute(
        acl_counter_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      free(attr_list);
      return;
    }

    sai_thrift_convert_to_acl_thrift_counter_attributes(
        attr_list, attr_count, thrift_attr_values);
    free(attr_list);
    return;
  }

  void sai_thrift_convert_to_acl_range_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_ACL_RANGE_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_ACL_RANGE_ATTR_LIMIT:
          attr_list[i].value.u32range.min = attribute.value.u32range.min;
          attr_list[i].value.u32range.max = attribute.value.u32range.max;
          break;
        default:
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_acl_range(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_object_id_t acl_range_id = 0ULL;
    sai_acl_api_t *acl_api = NULL;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_convert_to_acl_range_attributes(thrift_attr_list, attr_list);
    status = acl_api->create_acl_range(&acl_range_id, 0, attr_count, attr_list);
    free(attr_list);
    return acl_range_id;
  }

  sai_thrift_status_t sai_thrift_delete_acl_range(
      const sai_thrift_object_id_t acl_range_id) {
    sai_acl_api_t *acl_api = NULL;
    sai_status_t status = SAI_STATUS_SUCCESS;
    status = sai_api_query(SAI_API_ACL, (void **)&acl_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = acl_api->remove_acl_range(acl_range_id);
    return status;
  }

  void sai_thrift_parse_mirror_session_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_MIRROR_SESSION_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_MIRROR_SESSION_ATTR_MONITOR_PORT:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_MIRROR_SESSION_ATTR_TC:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_MIRROR_SESSION_ATTR_VLAN_TPID:
          attr_list[i].value.u16 = attribute.value.u32;
          break;
        case SAI_MIRROR_SESSION_ATTR_VLAN_ID:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_MIRROR_SESSION_ATTR_VLAN_PRI:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_MIRROR_SESSION_ATTR_VLAN_HEADER_VALID:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_MIRROR_SESSION_ATTR_ERSPAN_ENCAPSULATION_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_MIRROR_SESSION_ATTR_IPHDR_VERSION:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_MIRROR_SESSION_ATTR_TOS:
          attr_list[i].value.u8 = attribute.value.u16;
          break;
        case SAI_MIRROR_SESSION_ATTR_TTL:
          attr_list[i].value.u8 = attribute.value.u16;
          break;
        case SAI_MIRROR_SESSION_ATTR_SRC_IP_ADDRESS:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;
        case SAI_MIRROR_SESSION_ATTR_DST_IP_ADDRESS:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;
        case SAI_MIRROR_SESSION_ATTR_SRC_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
        case SAI_MIRROR_SESSION_ATTR_DST_MAC_ADDRESS:
          sai_thrift_string_to_mac(attribute.value.mac, attr_list[i].value.mac);
          break;
        case SAI_MIRROR_SESSION_ATTR_GRE_PROTOCOL_TYPE:
          attr_list[i].value.u16 = attribute.value.u32;
          break;
        case SAI_MIRROR_SESSION_ATTR_TRUNCATE_SIZE:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        default:
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_mirror_session(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_mirror_session\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;
    sai_object_id_t session_id = 0;

    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_mirror_session_attributes(thrift_attr_list, attr_list);
    mirror_api->create_mirror_session(
        &session_id, gSwitchId, attr_count, attr_list);
    return session_id;
  }

  sai_thrift_status_t sai_thrift_remove_mirror_session(
      const sai_thrift_object_id_t session_id) {
    printf("sai_thrift_remove_mirror_session\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_mirror_api_t *mirror_api;
    status = sai_api_query(SAI_API_MIRROR, (void **)&mirror_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = mirror_api->remove_mirror_session((sai_object_id_t)session_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_mirror_attribute(
      const sai_thrift_object_id_t thrift_mirror_id,
      const sai_thrift_attribute_t &thrift_attr) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_mirror_api_t *mirror_api = nullptr;
    auto status =
        sai_api_query(SAI_API_MIRROR, reinterpret_cast<void **>(&mirror_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    const std::vector<sai_thrift_attribute_t> thrift_attr_list = {thrift_attr};

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_mirror_session_attributes(thrift_attr_list, attr_list);

    status =
        mirror_api->set_mirror_session_attribute(thrift_mirror_id, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to set attribute.");

    return status;
  }
  void sai_thrift_parse_policer_attributes(
      sai_attribute_t *attr_list,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) const
      noexcept {
    if (attr_list == nullptr || thrift_attr_list.empty()) {
      SAI_THRIFT_LOG_ERR("Invalid input arguments.");
      return;
    }

    std::vector<sai_thrift_attribute_t>::const_iterator cit =
        thrift_attr_list.begin();

    for (sai_size_t i = 0; i < thrift_attr_list.size(); i++, cit++) {
      sai_thrift_attribute_t attribute = *cit;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_POLICER_ATTR_METER_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_MODE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_COLOR_SOURCE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_CBS:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_POLICER_ATTR_CIR:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_POLICER_ATTR_PBS:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_POLICER_ATTR_PIR:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_POLICER_ATTR_GREEN_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_YELLOW_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_RED_PACKET_ACTION:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_POLICER_ATTR_ENABLE_COUNTER_PACKET_ACTION_LIST:
          for (sai_size_t j = 0; j < attribute.value.s32list.s32list.size();
               j++) {
            attr_list[i].value.s32list.list[j] =
                attribute.value.s32list.s32list[j];
          }
          attr_list[i].value.s32list.count =
              attribute.value.s32list.s32list.size();
          break;
        default:
          SAI_THRIFT_LOG_ERR("Failed to parse attribute.");
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_policer(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_policer_api_t *policer_api = nullptr;
    auto status =
        sai_api_query(SAI_API_POLICER, reinterpret_cast<void **>(&policer_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();

    sai_thrift_alloc_array(attr_list, attr_size);
    sai_thrift_parse_policer_attributes(attr_list, thrift_attr_list);

    sai_object_id_t policer_oid = 0;
    status = policer_api->create_policer(
        &policer_oid, gSwitchId, attr_size, attr_list);
    sai_thrift_free_array(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return policer_oid;
    }

    SAI_THRIFT_LOG_ERR("Failed to create OID.");

    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_remove_policer(
      const sai_thrift_object_id_t thrift_policer_id) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_policer_api_t *policer_api = nullptr;
    auto status =
        sai_api_query(SAI_API_POLICER, reinterpret_cast<void **>(&policer_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    status = policer_api->remove_policer(thrift_policer_id);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to remove OID.");

    return status;
  }

  sai_thrift_status_t sai_thrift_set_policer_attribute(
      const sai_thrift_object_id_t thrift_policer_id,
      const sai_thrift_attribute_t &thrift_attr) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_policer_api_t *policer_api = nullptr;
    auto status =
        sai_api_query(SAI_API_POLICER, reinterpret_cast<void **>(&policer_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    const std::vector<sai_thrift_attribute_t> thrift_attr_list = {thrift_attr};

    sai_attribute_t *attr_list = nullptr;
    sai_size_t attr_size = thrift_attr_list.size();

    sai_thrift_alloc_array(attr_list, attr_size);
    sai_thrift_parse_policer_attributes(attr_list, thrift_attr_list);

    status = policer_api->set_policer_attribute(thrift_policer_id, attr_list);
    sai_thrift_free_array(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to set attribute.");

    return status;
  }

  void sai_thrift_get_policer_stats(
      std::vector<sai_thrift_uint64_t> &_return,
      const sai_thrift_object_id_t thrift_policer_id,
      const std::vector<sai_thrift_policer_stat_t>
          &thrift_counter_ids) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_policer_api_t *policer_api = nullptr;
    auto status =
        sai_api_query(SAI_API_POLICER, reinterpret_cast<void **>(&policer_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return;
    }

    auto counter_ids =
        reinterpret_cast<const sai_stat_id_t *>(thrift_counter_ids.data());
    sai_size_t number_of_counters = thrift_counter_ids.size();
    sai_uint64_t *counters = nullptr;

    sai_thrift_alloc_array(counters, number_of_counters);

    status = policer_api->get_policer_stats(
        thrift_policer_id, number_of_counters, counter_ids, counters);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      _return.assign(counters, counters + number_of_counters);
      sai_thrift_free_array(counters);
      return;
    }

    SAI_THRIFT_LOG_ERR("Failed to get statistics.");
    sai_thrift_free_array(counters);
  }

  sai_thrift_status_t sai_thrift_clear_policer_stats(
      const sai_thrift_object_id_t thrift_policer_id,
      const std::vector<sai_thrift_policer_stat_t>
          &thrift_counter_ids) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_policer_api_t *policer_api = nullptr;
    auto status =
        sai_api_query(SAI_API_POLICER, reinterpret_cast<void **>(&policer_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    auto counter_ids =
        reinterpret_cast<const sai_stat_id_t *>(thrift_counter_ids.data());
    sai_size_t number_of_counters = thrift_counter_ids.size();

    status = policer_api->clear_policer_stats(
        thrift_policer_id, number_of_counters, counter_ids);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return status;
    }

    SAI_THRIFT_LOG_ERR("Failed to clear statistics.");

    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_profile(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_scheduler_profile\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;
    sai_object_id_t scheduler_id = 0;
    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_scheduler_attributes(thrift_attr_list, attr_list);
    scheduler_api->create_scheduler(
        &scheduler_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return scheduler_id;
  }

  sai_thrift_status_t sai_thrift_remove_scheduler_profile(
      const sai_thrift_object_id_t scheduler_id) {
    printf("sai_thrift_remove_scheduler\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;
    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = scheduler_api->remove_scheduler((sai_object_id_t)scheduler_id);
    return status;
  }

  void sai_thrift_parse_scheduler_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_METER_TYPE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_SCHEDULER_ATTR_SCHEDULING_TYPE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
      }
    }
  }

  void sai_thrift_get_port_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t port_id,
      const std::vector<sai_thrift_port_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    if (thrift_counter_ids.size() == 0) {
      return;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (port_api->get_port_stats) {
      status = port_api->get_port_stats(
          (sai_object_id_t)port_id, number_of_counters, counter_ids, counters);
    } else {
      free(counter_ids);
      free(counters);
      return;
    }

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }
    free(counter_ids);
    free(counters);
    return;
  }

  void sai_thrift_get_port_stats_ext(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t port_id,
      const std::vector<sai_thrift_port_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    if (thrift_counter_ids.size() == 0) {
      return;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    if (port_api->get_port_stats_ext) {
      status = port_api->get_port_stats_ext((sai_object_id_t)port_id,
                                            number_of_counters,
                                            counter_ids,
                                            SAI_STATS_MODE_READ_AND_CLEAR,
                                            counters);
    } else {
      free(counter_ids);
      free(counters);
      return;
    }

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }
    free(counter_ids);
    free(counters);
    return;
  }

  void sai_thrift_get_port_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t port_id) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *port_api;
    sai_attribute_t max_queue_attribute;
    sai_attribute_t queue_list_object_attribute;
    sai_thrift_attribute_t thrift_queue_list_attribute;
    sai_object_list_t *queue_list_object;
    int max_queues = 0;
    int thrift_attr_count = 0;

    status = sai_api_query(SAI_API_PORT, (void **)&port_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    std::vector<sai_thrift_attribute_t> &attr_list = thrift_attr_list.attr_list;

    max_queue_attribute.id = SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES;
    port_api->get_port_attribute(port_id, 1, &max_queue_attribute);
    max_queues = max_queue_attribute.value.u32;

    if (max_queues > 0) {
      queue_list_object_attribute.id = SAI_PORT_ATTR_QOS_QUEUE_LIST;
      queue_list_object_attribute.value.objlist.list =
          (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * max_queues);
      queue_list_object_attribute.value.objlist.count = max_queues;
      port_api->get_port_attribute(port_id, 1, &queue_list_object_attribute);

      thrift_attr_list.attr_count = ++thrift_attr_count;
      thrift_queue_list_attribute.id = SAI_PORT_ATTR_QOS_QUEUE_LIST;
      thrift_queue_list_attribute.value.objlist.count = max_queues;
      std::vector<sai_thrift_object_id_t> &queue_list =
          thrift_queue_list_attribute.value.objlist.object_id_list;
      queue_list_object = &queue_list_object_attribute.value.objlist;
      for (int index = 0; index < max_queues; index++) {
        queue_list.push_back(
            (sai_thrift_object_id_t)queue_list_object->list[index]);
      }
      attr_list.push_back(thrift_queue_list_attribute);
      free(queue_list_object_attribute.value.objlist.list);
    }

    sai_attribute_t max_pg_attribute;
    sai_attribute_t pg_list_object_attribute;
    sai_thrift_attribute_t thrift_pg_list_attribute;
    sai_object_list_t *pg_list_object;
    int max_pg = 0;

    max_pg_attribute.id = SAI_PORT_ATTR_NUMBER_OF_INGRESS_PRIORITY_GROUPS;
    port_api->get_port_attribute(port_id, 1, &max_pg_attribute);
    max_pg = max_pg_attribute.value.u32;

    if (max_pg > 0) {
      pg_list_object_attribute.id = SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST;
      pg_list_object_attribute.value.objlist.list =
          (sai_object_id_t *)malloc(sizeof(sai_object_id_t) * max_pg);
      pg_list_object_attribute.value.objlist.count = max_pg;
      port_api->get_port_attribute(port_id, 1, &pg_list_object_attribute);

      thrift_attr_list.attr_count = ++thrift_attr_count;
      thrift_pg_list_attribute.id = SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST;
      thrift_pg_list_attribute.value.objlist.count = max_pg;
      std::vector<sai_thrift_object_id_t> &pg_list =
          thrift_pg_list_attribute.value.objlist.object_id_list;
      pg_list_object = &pg_list_object_attribute.value.objlist;
      for (int index = 0; index < max_pg; index++) {
        pg_list.push_back((sai_thrift_object_id_t)pg_list_object->list[index]);
      }
      attr_list.push_back(thrift_pg_list_attribute);
      free(pg_list_object_attribute.value.objlist.list);
    }

    sai_attribute_t port_hw_lane;
    sai_thrift_attribute_t thrift_port_hw_lane;
    sai_u32_list_t *lane_list_num;

    port_hw_lane.id = SAI_PORT_ATTR_HW_LANE_LIST;
    port_hw_lane.value.u32list.list = (uint32_t *)malloc(sizeof(uint32_t) * 4);
    port_hw_lane.value.u32list.count = 4;
    port_api->get_port_attribute(port_id, 1, &port_hw_lane);

    thrift_attr_list.attr_count = ++thrift_attr_count;
    thrift_port_hw_lane.id = SAI_PORT_ATTR_HW_LANE_LIST;
    thrift_port_hw_lane.value.u32list.count = port_hw_lane.value.u32list.count;
    std::vector<int32_t> &lane_list = thrift_port_hw_lane.value.u32list.u32list;
    lane_list_num = &port_hw_lane.value.u32list;
    for (uint32_t index = 0; index < port_hw_lane.value.u32list.count;
         index++) {
      lane_list.push_back((uint32_t)lane_list_num->list[index]);
    }
    attr_list.push_back(thrift_port_hw_lane);
    free(port_hw_lane.value.u32list.list);

    sai_attribute_t port_oper_status_attribute;
    sai_thrift_attribute_t thrift_port_status;
    port_oper_status_attribute.id = SAI_PORT_ATTR_OPER_STATUS;
    port_api->get_port_attribute(port_id, 1, &port_oper_status_attribute);

    thrift_attr_list.attr_count = ++thrift_attr_count;
    thrift_port_status.id = SAI_PORT_ATTR_OPER_STATUS;
    thrift_port_status.value.s32 = port_oper_status_attribute.value.s32;
    attr_list.push_back(thrift_port_status);

    /* get SAI_PORT_ATTR_DROP_UNTAGGED attribute */
    sai_attribute_t drop_untagged_packet_attribute;
    sai_thrift_attribute_t thrift_drop_untagged;
    thrift_attr_list.attr_count = ++thrift_attr_count;
    drop_untagged_packet_attribute.id = SAI_PORT_ATTR_DROP_UNTAGGED;
    port_api->get_port_attribute(port_id, 1, &drop_untagged_packet_attribute);
    thrift_drop_untagged.id = SAI_PORT_ATTR_DROP_UNTAGGED;
    thrift_drop_untagged.value.booldata =
        drop_untagged_packet_attribute.value.booldata;
    attr_list.push_back(thrift_drop_untagged);

    /* get SAI_PORT_ATTR_DROP_TAGGED attribute */
    sai_attribute_t drop_tagged_packet_attribute;
    sai_thrift_attribute_t thrift_drop_tagged;
    thrift_attr_list.attr_count = ++thrift_attr_count;
    drop_tagged_packet_attribute.id = SAI_PORT_ATTR_DROP_TAGGED;
    port_api->get_port_attribute(port_id, 1, &drop_tagged_packet_attribute);
    thrift_drop_tagged.id = SAI_PORT_ATTR_DROP_TAGGED;
    thrift_drop_tagged.value.booldata =
        drop_tagged_packet_attribute.value.booldata;
    attr_list.push_back(thrift_drop_tagged);

    /* get SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL attribute */
    sai_attribute_t port_pfc_attribute;
    sai_thrift_attribute_t thrift_port_pfc;
    thrift_attr_list.attr_count = ++thrift_attr_count;
    port_pfc_attribute.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL;
    port_api->get_port_attribute(port_id, 1, &port_pfc_attribute);
    thrift_port_pfc.id = SAI_PORT_ATTR_PRIORITY_FLOW_CONTROL;
    thrift_port_pfc.value.u8 = port_pfc_attribute.value.u8;
    attr_list.push_back(thrift_port_pfc);

    /* get SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID attribute */
    sai_attribute_t port_flood_sc_attribute;
    sai_thrift_attribute_t thrift_port_flood_sc;
    thrift_attr_list.attr_count = ++thrift_attr_count;
    port_flood_sc_attribute.id = SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID;
    port_api->get_port_attribute(port_id, 1, &port_flood_sc_attribute);
    thrift_port_flood_sc.id = SAI_PORT_ATTR_FLOOD_STORM_CONTROL_POLICER_ID;
    thrift_port_flood_sc.value.oid = port_flood_sc_attribute.value.oid;
    attr_list.push_back(thrift_port_flood_sc);

    /* get SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID attribute */
    sai_attribute_t port_mc_sc_attribute;
    sai_thrift_attribute_t thrift_port_mc_sc;
    thrift_attr_list.attr_count = ++thrift_attr_count;
    port_mc_sc_attribute.id = SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID;
    port_api->get_port_attribute(port_id, 1, &port_mc_sc_attribute);
    thrift_port_mc_sc.id = SAI_PORT_ATTR_MULTICAST_STORM_CONTROL_POLICER_ID;
    thrift_port_mc_sc.value.oid = port_mc_sc_attribute.value.oid;
    attr_list.push_back(thrift_port_mc_sc);

    /* get SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID attribute */
    sai_attribute_t port_bc_sc_attribute;
    sai_thrift_attribute_t thrift_port_bc_sc;
    thrift_attr_list.attr_count = ++thrift_attr_count;
    port_bc_sc_attribute.id = SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID;
    port_api->get_port_attribute(port_id, 1, &port_bc_sc_attribute);
    thrift_port_bc_sc.id = SAI_PORT_ATTR_BROADCAST_STORM_CONTROL_POLICER_ID;
    thrift_port_bc_sc.value.oid = port_bc_sc_attribute.value.oid;
    attr_list.push_back(thrift_port_bc_sc);
  }

  void sai_thrift_get_port_handles_attribute(
      sai_thrift_attribute_t &thrift_attr,
      sai_thrift_object_id_t port_id,
      const sai_thrift_attribute_t &attr) {
    sai_port_api_t *port_api;
    uint32_t num_ppgs = 0;

    sai_api_query(SAI_API_PORT, (void **)&port_api);
    sai_attribute_t port_attr;
    switch (attr.id) {
      case SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST: {
        port_attr.id = SAI_PORT_ATTR_NUMBER_OF_INGRESS_PRIORITY_GROUPS;
        port_api->get_port_attribute(port_id, 1, &port_attr);
        num_ppgs = port_attr.value.u32;

        if (num_ppgs > 0) {
          port_attr.value.objlist.list =
              (sai_object_id_t *)malloc(num_ppgs * sizeof(sai_object_id_t));
          port_attr.id = SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST;
          port_api->get_port_attribute(port_id, 1, &port_attr);

          thrift_attr.id = SAI_PORT_ATTR_INGRESS_PRIORITY_GROUP_LIST;
          thrift_attr.value.objlist.count = num_ppgs;
          std::vector<sai_thrift_object_id_t> &ppg_list =
              thrift_attr.value.objlist.object_id_list;

          for (uint32_t index = 0; index < num_ppgs; index++) {
            ppg_list.push_back(
                (sai_thrift_object_id_t)port_attr.value.objlist.list[index]);
          }

          free(port_attr.value.objlist.list);
        }
      } break;
      case SAI_PORT_ATTR_QOS_SCHEDULER_GROUP_LIST: {
        port_attr.id = SAI_PORT_ATTR_QOS_NUMBER_OF_SCHEDULER_GROUPS;
        port_api->get_port_attribute(port_id, 1, &port_attr);
        int num_sch_groups = port_attr.value.u32;

        if (num_sch_groups > 0) {
          port_attr.id = SAI_PORT_ATTR_QOS_SCHEDULER_GROUP_LIST;
          port_attr.value.objlist.list = (sai_object_id_t *)malloc(
              num_sch_groups * sizeof(sai_object_id_t));
          memset(port_attr.value.objlist.list,
                 0,
                 num_sch_groups * sizeof(sai_object_id_t));
          port_api->get_port_attribute(port_id, 1, &port_attr);

          thrift_attr.value.objlist.count = num_sch_groups;
          std::vector<sai_thrift_object_id_t> &group_list =
              thrift_attr.value.objlist.object_id_list;

          for (int index = 0; index < num_sch_groups; index++) {
            group_list.push_back(port_attr.value.objlist.list[index]);
          }
          free(port_attr.value.objlist.list);
        }
      } break;

      case SAI_PORT_ATTR_QOS_QUEUE_LIST: {
        port_attr.id = SAI_PORT_ATTR_QOS_NUMBER_OF_QUEUES;
        port_api->get_port_attribute(port_id, 1, &port_attr);
        int num_queues = port_attr.value.u32;

        if (num_queues > 0) {
          port_attr.id = SAI_PORT_ATTR_QOS_QUEUE_LIST;
          port_attr.value.objlist.list =
              (sai_object_id_t *)malloc(num_queues * sizeof(sai_object_id_t));
          memset(port_attr.value.objlist.list,
                 0,
                 num_queues * sizeof(sai_object_id_t));
          port_api->get_port_attribute(port_id, 1, &port_attr);

          thrift_attr.value.objlist.count = num_queues;
          std::vector<sai_thrift_object_id_t> &group_list =
              thrift_attr.value.objlist.object_id_list;

          for (int index = 0; index < num_queues; index++) {
            group_list.push_back(port_attr.value.objlist.list[index]);
          }
          free(port_attr.value.objlist.list);
        }
      } break;
      case SAI_PORT_ATTR_QOS_SCHEDULER_PROFILE_ID: {
        port_attr.id = SAI_PORT_ATTR_QOS_SCHEDULER_PROFILE_ID;
        port_api->get_port_attribute(port_id, 1, &port_attr);
        thrift_attr.value.oid = port_attr.value.oid;
      } break;
    }

    return;
  }

  void sai_thrift_get_queue_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t queue_id,
      const std::vector<sai_thrift_queue_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_get_queue_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;
    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    if (thrift_counter_ids.size() == 0) {
      return;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = queue_api->get_queue_stats(
        (sai_object_id_t)queue_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }
    free(counter_ids);
    free(counters);
    return;
  }

  sai_thrift_status_t sai_thrift_set_queue_attribute(
      const sai_thrift_object_id_t queue_id,
      const sai_thrift_attribute_t &thrift_attr) {
    printf("sai_thrift_set_queue_attribute\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;
    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr;
    attr.id = thrift_attr.id;
    attr.value.oid = thrift_attr.value.oid;
    status = queue_api->set_queue_attribute((sai_object_id_t)queue_id, &attr);
    return status;
  }

  sai_thrift_status_t sai_thrift_clear_queue_stats(
      const sai_thrift_object_id_t queue_id,
      const std::vector<sai_thrift_queue_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_clear_queue_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_queue_api_t *queue_api;
    status = sai_api_query(SAI_API_QUEUE, (void **)&queue_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    if (thrift_counter_ids.size() == 0) {
      return SAI_STATUS_INVALID_PARAMETER;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = queue_api->clear_queue_stats(
        (sai_object_id_t)queue_id, number_of_counters, counter_ids);

    free(counter_ids);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_ppg(
      const sai_thrift_object_id_t port_handle, const int32_t ppg_index) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    sai_object_id_t ppg_handle = 0;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr_list[2];
    attr_list[0].id = SAI_INGRESS_PRIORITY_GROUP_ATTR_PORT;
    attr_list[0].value.oid = port_handle;

    attr_list[1].id = SAI_INGRESS_PRIORITY_GROUP_ATTR_INDEX;
    attr_list[1].value.u8 = ppg_index;

    buffer_api->create_ingress_priority_group(
        &ppg_handle, gSwitchId, 2, attr_list);
    return ppg_handle;
  }

  sai_thrift_status_t sai_thrift_set_ppg_profile(
      const sai_thrift_object_id_t ppg_handle,
      const sai_thrift_object_id_t profile_handle) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr;
    attr.id = SAI_INGRESS_PRIORITY_GROUP_ATTR_BUFFER_PROFILE;
    attr.value.oid = profile_handle;

    status = buffer_api->set_ingress_priority_group_attribute(
        (sai_object_id_t)ppg_handle, &attr);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_get_ppg_profile(
      const sai_thrift_object_id_t ppg_handle) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t attr;
    attr.id = SAI_INGRESS_PRIORITY_GROUP_ATTR_BUFFER_PROFILE;

    status = buffer_api->get_ingress_priority_group_attribute(
        (sai_object_id_t)ppg_handle, 1, &attr);
    return (sai_thrift_object_id_t)attr.value.oid;
  }

  sai_thrift_status_t sai_thrift_remove_ppg(
      const sai_thrift_object_id_t ppg_handle) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    return buffer_api->remove_ingress_priority_group(ppg_handle);
  }

  sai_thrift_object_id_t sai_thrift_create_buffer_profile(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_buffer_profile\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    sai_object_id_t buffer_id = 0;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_buffer_attributes(thrift_attr_list, attr_list);
    buffer_api->create_buffer_profile(
        &buffer_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return buffer_id;
  }

  void sai_thrift_parse_buffer_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_BUFFER_PROFILE_ATTR_POOL_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_BUFFER_PROFILE_ATTR_BUFFER_SIZE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_PROFILE_ATTR_THRESHOLD_MODE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_PROFILE_ATTR_SHARED_DYNAMIC_TH:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_BUFFER_PROFILE_ATTR_SHARED_STATIC_TH:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_BUFFER_PROFILE_ATTR_XOFF_TH:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_PROFILE_ATTR_XON_TH:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_pool_profile(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_pool\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    sai_object_id_t pool_id = 0;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_pool_attributes(thrift_attr_list, attr_list);
    buffer_api->create_buffer_pool(&pool_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return pool_id;
  }

  sai_thrift_status_t sai_thrift_remove_buffer_pool(
      const sai_thrift_object_id_t pool_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = buffer_api->remove_buffer_pool(pool_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_remove_buffer_profile(
      const sai_thrift_object_id_t profile_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = buffer_api->remove_buffer_profile(profile_id);
    return status;
  }

  void sai_thrift_parse_pool_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_BUFFER_POOL_ATTR_TYPE:
          attr_list[i].value.u32 = attribute.value.s32;
          break;
        case SAI_BUFFER_POOL_ATTR_SIZE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_BUFFER_POOL_ATTR_THRESHOLD_MODE:
          attr_list[i].value.u32 = attribute.value.s32;
          break;
      }
    }
  }

  void sai_thrift_convert_to_pool_thrift_attribute(
      sai_attribute_t *attr, sai_thrift_attribute_t *thrift_attr) {
    switch (attr->id) {
      case SAI_BUFFER_POOL_ATTR_TYPE:
      case SAI_BUFFER_POOL_ATTR_SIZE:
      case SAI_BUFFER_POOL_ATTR_THRESHOLD_MODE:
        thrift_attr->value.u32 = attr->value.u32;
        break;

      default:
        break;
    }
  }

  void sai_thrift_get_buffer_pool_attribute(
      sai_thrift_attribute_t &ret_thrift_attr,
      const sai_thrift_object_id_t pool_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_buffer_api_t *buffer_api;
    sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);

    sai_attribute_t attr;
    memset(&attr, 0, sizeof(sai_attribute_t));
    attr.id = thrift_attr.id;
    buffer_api->get_buffer_pool_attribute(pool_id, 1, &attr);
    sai_thrift_convert_to_pool_thrift_attribute(&attr, &ret_thrift_attr);
  }

  sai_thrift_status_t sai_thrift_set_priority_group_attribute(
      const sai_thrift_object_id_t pg_id,
      const sai_thrift_attribute_t &thrift_attr) {
    printf("sai_thrift_set_priority_group_attribute\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    sai_attribute_t attr;
    attr.id = thrift_attr.id;
    attr.value.oid = thrift_attr.value.oid;
    status = buffer_api->set_ingress_priority_group_attribute(
        (sai_object_id_t)pg_id, &attr);
    return status;
  }

  void sai_thrift_get_pg_stats(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t pg_id,
      const std::vector<sai_thrift_pg_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_get_pg_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    if (thrift_counter_ids.size() == 0) {
      return;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = buffer_api->get_ingress_priority_group_stats(
        (sai_object_id_t)pg_id, number_of_counters, counter_ids, counters);

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }
    free(counter_ids);
    free(counters);
    return;
  }

  sai_thrift_status_t sai_thrift_clear_pg_stats(
      const sai_thrift_object_id_t pg_id,
      const std::vector<sai_thrift_pg_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    printf("sai_thrift_clear_pg_stats\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_buffer_api_t *buffer_api;
    status = sai_api_query(SAI_API_BUFFER, (void **)&buffer_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    if (thrift_counter_ids.size() == 0) {
      return status;
    }
    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    status = buffer_api->clear_ingress_priority_group_stats(
        (sai_object_id_t)pg_id, number_of_counters, counter_ids);

    free(counter_ids);
    return status;
  }

  void sai_thrift_parse_scheduler_profile_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_SCHEDULER_ATTR_SCHEDULING_TYPE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_SCHEDULER_ATTR_METER_TYPE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE:
          attr_list[i].value.u64 = attribute.value.u64;
          break;
        default:
          break;
      }
    }
  }

  sai_thrift_status_t sai_thrift_set_scheduler_profile(
      const sai_thrift_object_id_t scheduler_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_attribute_t attr;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_api_t *scheduler_api;
    status = sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    attr.id = thrift_attr.id;
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_thrift_parse_scheduler_profile_attributes(thrift_attr_list, &attr);
    return scheduler_api->set_scheduler_attribute(scheduler_id, &attr);
  }

  void sai_thrift_convert_to_scheduler_thrift_attribute(
      sai_attribute_t &sai_attr, sai_thrift_attribute_t &thrift_attr) {
    switch (sai_attr.id) {
      case SAI_SCHEDULER_ATTR_SCHEDULING_TYPE:
      case SAI_SCHEDULER_ATTR_METER_TYPE:
        thrift_attr.value.u32 = sai_attr.value.u32;
        break;

      case SAI_SCHEDULER_ATTR_SCHEDULING_WEIGHT:
        thrift_attr.value.u8 = sai_attr.value.u8;
        break;
      case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_RATE:
      case SAI_SCHEDULER_ATTR_MIN_BANDWIDTH_BURST_RATE:
      case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_RATE:
      case SAI_SCHEDULER_ATTR_MAX_BANDWIDTH_BURST_RATE:
        thrift_attr.value.u64 = sai_attr.value.u64;
      default:
        break;
    }
  }

  void sai_thrift_get_scheduler_profile(
      sai_thrift_attribute_t &thrift_attr,
      const sai_thrift_object_id_t scheduler_id,
      const sai_thrift_attribute_t &attr) {
    sai_scheduler_api_t *scheduler_api;
    sai_api_query(SAI_API_SCHEDULER, (void **)&scheduler_api);
    sai_attribute_t sai_attr;
    sai_attr.id = attr.id;
    scheduler_api->get_scheduler_attribute(scheduler_id, 1, &sai_attr);

    thrift_attr.id = sai_attr.id;
    sai_thrift_convert_to_scheduler_thrift_attribute(sai_attr, thrift_attr);
  }

  void sai_thrift_parse_scheduler_group_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_SCHEDULER_GROUP_ATTR_CHILD_COUNT:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST:
          break;
        case SAI_SCHEDULER_GROUP_ATTR_PORT_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_SCHEDULER_GROUP_ATTR_LEVEL:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_SCHEDULER_GROUP_ATTR_SCHEDULER_PROFILE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_scheduler_group(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;
    sai_object_id_t scheduler_group_id = 0;
    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_scheduler_group_attributes(thrift_attr_list, attr_list);
    scheduler_group_api->create_scheduler_group(
        &scheduler_group_id, 0, attr_count, attr_list);
    free(attr_list);
    return scheduler_group_id;
  }

  void sai_thrift_get_scheduler_group_attribute(
      sai_thrift_attribute_t &thrift_attr,
      sai_thrift_object_id_t group_id,
      const sai_thrift_attribute_t &attr) {
    sai_scheduler_group_api_t *scheduler_group_api;
    sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    sai_attribute_t sai_attr;
    if (attr.id == SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST) {
      sai_attr.id = SAI_SCHEDULER_GROUP_ATTR_CHILD_COUNT;
      scheduler_group_api->get_scheduler_group_attribute(
          group_id, 1, &sai_attr);
      int num_groups = sai_attr.value.u32;

      if (num_groups > 0) {
        sai_attr.value.objlist.list =
            (sai_object_id_t *)malloc(num_groups * sizeof(sai_object_id_t));
        sai_attr.id = SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST;
        sai_attr.value.objlist.count = num_groups;
        scheduler_group_api->get_scheduler_group_attribute(
            group_id, 1, &sai_attr);

        thrift_attr.id = SAI_SCHEDULER_GROUP_ATTR_CHILD_LIST;
        thrift_attr.value.objlist.count = num_groups;
        std::vector<sai_thrift_object_id_t> &child_list =
            thrift_attr.value.objlist.object_id_list;

        for (int index = 0; index < num_groups; index++) {
          child_list.push_back(
              (sai_thrift_object_id_t)sai_attr.value.objlist.list[index]);
        }
        free(sai_attr.value.objlist.list);
      }
    }
  }

  sai_thrift_status_t sai_thrift_remove_scheduler_group(
      const sai_thrift_object_id_t scheduler_group_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;
    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = scheduler_group_api->remove_scheduler_group(scheduler_group_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_scheduler_group(
      const sai_thrift_object_id_t scheduler_group_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_attribute_t attr;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_scheduler_group_api_t *scheduler_group_api;
    status =
        sai_api_query(SAI_API_SCHEDULER_GROUP, (void **)&scheduler_group_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    attr.id = thrift_attr.id;
    if (attr.id == SAI_SCHEDULER_GROUP_ATTR_SCHEDULER_PROFILE_ID) {
      attr.value.oid = thrift_attr.value.oid;
    }
    return scheduler_group_api->set_scheduler_group_attribute(
        scheduler_group_id, &attr);
  }

  sai_thrift_object_id_t sai_thrift_create_wred_profile(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_wred_profile\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_wred_api_t *wred_api;
    sai_object_id_t wred_id = 0;
    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_wred_attributes(thrift_attr_list, attr_list);
    wred_api->create_wred(&wred_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    return wred_id;
  }

  void sai_thrift_parse_wred_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_WRED_ATTR_GREEN_ENABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_WRED_ATTR_GREEN_MIN_THRESHOLD:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_GREEN_MAX_THRESHOLD:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_GREEN_DROP_PROBABILITY:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_YELLOW_ENABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_WRED_ATTR_YELLOW_MIN_THRESHOLD:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_YELLOW_MAX_THRESHOLD:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_YELLOW_DROP_PROBABILITY:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_RED_ENABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_WRED_ATTR_RED_MIN_THRESHOLD:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_RED_MAX_THRESHOLD:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_RED_DROP_PROBABILITY:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_WRED_ATTR_WEIGHT:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_WRED_ATTR_ECN_MARK_MODE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
      }
    }
  }

  sai_thrift_status_t sai_thrift_remove_wred_profile(
      const sai_thrift_object_id_t wred_id) {
    printf("sai_thrift_remove_wred_profile\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_wred_api_t *wred_api;
    status = sai_api_query(SAI_API_WRED, (void **)&wred_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = wred_api->remove_wred((sai_object_id_t)wred_id);
    return status;
  }

  void sai_thrift_parse_qos_map_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_qos_map_t **qos_map_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    sai_qos_map_type_t qos_map_type = (sai_qos_map_type_t)0;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_QOS_MAP_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          qos_map_type = (sai_qos_map_type_t)attribute.value.s32;
          break;
        case SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST:
          if (attribute.value.qosmap.key.size() == 0) {
            attr_list[i].value.qosmap.list = NULL;
            attr_list[i].value.qosmap.count = 0;
            break;
          }
          attr_list[i].value.qosmap.list = (sai_qos_map_t *)malloc(
              attribute.value.qosmap.key.size() * sizeof(sai_qos_map_t));
          attr_list[i].value.qosmap.count = attribute.value.qosmap.key.size();
          *qos_map_list = attr_list[i].value.qosmap.list;
          memset(attr_list[i].value.qosmap.list,
                 0x0,
                 attribute.value.qosmap.key.size() * sizeof(sai_qos_map_t));
          std::vector<sai_thrift_qos_map_params_t>::const_iterator it1 =
              attribute.value.qosmap.key.begin();
          std::vector<sai_thrift_qos_map_params_t>::const_iterator it2 =
              attribute.value.qosmap.data.begin();
          for (uint32_t j = 0; j < attribute.value.qosmap.key.size();
               j++, it1++, it2++) {
            sai_qos_map_params_t *key = &attr_list[i].value.qosmap.list[j].key;
            sai_qos_map_params_t *data =
                &attr_list[i].value.qosmap.list[j].value;
            const sai_thrift_qos_map_params_t thrift_key =
                (sai_thrift_qos_map_params_t)*it1;
            const sai_thrift_qos_map_params_t thrift_data =
                (sai_thrift_qos_map_params_t)*it2;

            switch (qos_map_type) {
              case SAI_QOS_MAP_TYPE_DOT1P_TO_TC:
                key->dot1p = thrift_key.dot1p;
                data->tc = thrift_data.tc;
                break;
              case SAI_QOS_MAP_TYPE_DOT1P_TO_COLOR:
                key->dot1p = thrift_key.dot1p;
                data->color = (sai_packet_color_t)thrift_data.color;
                break;
              case SAI_QOS_MAP_TYPE_DSCP_TO_TC:
                key->dscp = thrift_key.dscp;
                data->tc = thrift_data.tc;
                break;
              case SAI_QOS_MAP_TYPE_DSCP_TO_COLOR:
                key->dscp = thrift_key.dscp;
                data->color = (sai_packet_color_t)thrift_data.color;
                break;
              case SAI_QOS_MAP_TYPE_TC_TO_QUEUE:
                key->tc = thrift_key.tc;
                data->queue_index = thrift_data.queue_index;
                break;
              case SAI_QOS_MAP_TYPE_TC_TO_PRIORITY_GROUP:
                key->tc = thrift_key.tc;
                data->pg = thrift_data.pg;
                break;
              case SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DSCP:
                key->tc = thrift_key.tc;
                key->color = (sai_packet_color_t)thrift_key.color;
                data->dscp = thrift_data.dscp;
                break;
              case SAI_QOS_MAP_TYPE_TC_AND_COLOR_TO_DOT1P:
                key->tc = thrift_key.tc;
                key->color = (sai_packet_color_t)thrift_key.color;
                data->dot1p = thrift_data.dot1p;
                break;
              case SAI_QOS_MAP_TYPE_PFC_PRIORITY_TO_PRIORITY_GROUP:
                key->prio = thrift_key.prio;
                data->pg = thrift_data.pg;
                break;
              case SAI_QOS_MAP_TYPE_PFC_PRIORITY_TO_QUEUE:
                key->prio = thrift_key.prio;
                data->queue_index = thrift_data.queue_index;
                break;
              default:
                break;
            }
          }
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_qos_map(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_api;
    sai_object_id_t qos_map_id = 0;
    sai_qos_map_t *qos_map_list = NULL;
    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_qos_map_attributes(
        thrift_attr_list, attr_list, &qos_map_list);
    qos_api->create_qos_map(&qos_map_id, 0, attr_count, attr_list);
    if (qos_map_list) {
      free(qos_map_list);
    }
    free(attr_list);
    return qos_map_id;
  }

  sai_thrift_status_t sai_thrift_set_qos_map(
      const sai_thrift_object_id_t qos_map_id,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_api;
    sai_qos_map_t *qos_map_list = NULL;
    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    if (thrift_attr_list.size() == 0) {
      return status;
    }
    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());

    sai_thrift_parse_qos_map_attributes(
        thrift_attr_list, attr_list, &qos_map_list);
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++) {
      if (attr_list[i].id == SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST) {
        qos_api->set_qos_map_attribute(qos_map_id, &(attr_list[i]));
      }
    }
    if (qos_map_list) {
      free(qos_map_list);
    }
    free(attr_list);
    return status;
  }

  void sai_thrift_get_qos_map(sai_thrift_attribute_t &ret_thrift_attr,
                              const sai_thrift_object_id_t qos_map_id,
                              const int32_t map_count,
                              const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_api;
    sai_attribute_t sai_attr;
    memset(&sai_attr, 0, sizeof(sai_attribute_t));
    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    sai_attr.id = thrift_attr.id;
    if (sai_attr.id == SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST) {
      assert(map_count != 0);
      sai_attr.value.qosmap.list =
          (sai_qos_map_t *)calloc(map_count, sizeof(sai_qos_map_t));
      sai_attr.value.qosmap.count = map_count;
    }

    status = qos_api->get_qos_map_attribute(qos_map_id, 1, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    ret_thrift_attr.id = thrift_attr.id;
    sai_thrift_qos_map_params_t thrift_key;
    sai_thrift_qos_map_params_t thrift_data;
    if (sai_attr.id != SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST) {
      ret_thrift_attr.value.u32 = sai_attr.value.u32;
    } else {
      for (int i = 0; i < map_count; i++) {
        memset((void *)&thrift_key, 0, sizeof(sai_thrift_qos_map_params_t));
        memset((void *)&thrift_data, 0, sizeof(sai_thrift_qos_map_params_t));
        thrift_key.dot1p = sai_attr.value.qosmap.list[i].key.dot1p;
        thrift_key.tc = sai_attr.value.qosmap.list[i].key.tc;
        thrift_key.dscp = sai_attr.value.qosmap.list[i].key.dscp;
        thrift_key.color = sai_attr.value.qosmap.list[i].key.color;
        thrift_key.prio = sai_attr.value.qosmap.list[i].key.prio;

        thrift_data.dot1p = sai_attr.value.qosmap.list[i].value.dot1p;
        thrift_data.tc = sai_attr.value.qosmap.list[i].value.tc;
        thrift_data.dscp = sai_attr.value.qosmap.list[i].value.dscp;
        thrift_data.color = sai_attr.value.qosmap.list[i].value.color;
        thrift_data.queue_index =
            sai_attr.value.qosmap.list[i].value.queue_index;
        thrift_data.pg = sai_attr.value.qosmap.list[i].value.pg;

        ret_thrift_attr.value.qosmap.key.push_back(thrift_key);
        ret_thrift_attr.value.qosmap.data.push_back(thrift_data);
      }
    }
    if (sai_attr.id == SAI_QOS_MAP_ATTR_MAP_TO_VALUE_LIST) {
      free(sai_attr.value.qosmap.list);
    }
  }

  void sai_thrift_parse_qos_map_params(
      const sai_thrift_qos_map_params_t *thrift_qos_params,
      sai_qos_map_params_t *qos_params) {
    qos_params->tc = thrift_qos_params->tc;
    qos_params->dscp = thrift_qos_params->dscp;
    qos_params->dot1p = thrift_qos_params->dot1p;
    qos_params->prio = thrift_qos_params->prio;
    qos_params->pg = thrift_qos_params->pg;
    qos_params->queue_index = thrift_qos_params->queue_index;
    qos_params->color = (sai_packet_color_t)thrift_qos_params->color;
  }

  sai_thrift_status_t sai_thrift_remove_qos_map(
      const sai_thrift_object_id_t qos_map_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_qos_map_api_t *qos_map_api;

    printf("sai_thrift_remove_qos_map\n");

    status = sai_api_query(SAI_API_QOS_MAP, (void **)&qos_map_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    status = qos_map_api->remove_qos_map((sai_object_id_t)qos_map_id);
    return status;
  }

  void sai_thrift_get_switch_stats_ext(
      std::vector<int64_t> &thrift_counters,
      const sai_thrift_object_id_t switch_id,
      const std::vector<sai_thrift_port_stat_counter_t> &thrift_counter_ids,
      const int32_t number_of_counters) {
    sai_switch_api_t *switch_api;
    sai_status_t status = SAI_STATUS_SUCCESS;

    status = sai_api_query(SAI_API_SWITCH, (void **)&switch_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    sai_stat_id_t *counter_ids = (sai_stat_id_t *)malloc(
        sizeof(sai_stat_id_t) * thrift_counter_ids.size());
    if (!counter_ids) {
      return;
    }
    std::vector<int32_t>::const_iterator it = thrift_counter_ids.begin();
    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++, it++) {
      counter_ids[i] = (sai_stat_id_t)*it;
    }

    uint64_t *counters =
        (uint64_t *)malloc(sizeof(uint64_t) * thrift_counter_ids.size());
    if (!counters) {
      free(counter_ids);
      return;
    }

    if (switch_api->get_switch_stats_ext) {
      status =
          switch_api->get_switch_stats_ext((sai_object_id_t)switch_id,
                                           number_of_counters,
                                           (const sai_stat_id_t *)counter_ids,
                                           SAI_STATS_MODE_READ_AND_CLEAR,
                                           counters);
    } else {
      free(counter_ids);
      free(counters);
      return;
    }

    for (uint32_t i = 0; i < thrift_counter_ids.size(); i++) {
      thrift_counters.push_back(counters[i]);
    }

    free(counter_ids);
    free(counters);
    return;
  }

  void sai_thrift_query_attribute_enum_values_capability(
      std::vector<int32_t> &thrift_enum_caps,
      const int32_t object_type,
      const int32_t attr_id,
      const int32_t caps_count) {
    const sai_thrift_object_id_t switch_id = 0;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_s32_list_t enum_values_capability;
    int32_t *caps_list = NULL;

    printf("sai_thrift_query_attribute_enum_values_capability \n");
    if (!caps_count) {
      return;
    }
    caps_list = (int32_t *)malloc(sizeof(int32_t) * caps_count);
    if (!caps_list) {
      return;
    }
    enum_values_capability.list = caps_list;
    enum_values_capability.count = caps_count;
    status = sai_query_attribute_enum_values_capability(
        (sai_object_id_t)switch_id,
        (sai_object_type_t)object_type,
        (sai_attr_id_t)attr_id,
        &enum_values_capability);
    if (SAI_STATUS_SUCCESS != status) {
      free(caps_list);
      return;
    }

    for (uint32_t i = 0; i < enum_values_capability.count; ++i) {
      thrift_enum_caps.push_back(enum_values_capability.list[i]);
    }
    free(caps_list);
  }

  // applies to port debug counters only
  // Debug counter types : SAI_DEBUG_COUNTER_TYPE_PORT_IN_DROP_REASONS and
  // SAI_DEBUG_COUNTER_TYPE_PORT_OUT_DROP_REASONS
  int64_t sai_thrift_get_debug_counter_port_stats_by_oid(
      sai_thrift_object_id_t port_id,
      sai_thrift_object_id_t thrift_counter_id) {
    printf("sai_thrift_get_debug_counter_port_stats_by_oid\n");

    sai_debug_counter_api_t *debug_counter_api;
    std::vector<sai_thrift_stat_id_t> thrift_counter_ids;
    std::vector<int64_t> thrift_counters;
    std::vector<sai_thrift_stat_id_t> dc_id;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t attr = {};
    int32_t index_base = 0;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (SAI_STATUS_SUCCESS != status) {
      return 0;
    }

    attr.id = SAI_DEBUG_COUNTER_ATTR_TYPE;
    status = debug_counter_api->get_debug_counter_attribute(
        (sai_object_id_t)thrift_counter_id, 1, &attr);
    if (SAI_STATUS_SUCCESS != status) {
      return 0;
    }

    switch (attr.value.s32) {
      case SAI_DEBUG_COUNTER_TYPE_PORT_IN_DROP_REASONS:
        index_base = SAI_PORT_STAT_IN_DROP_REASON_RANGE_BASE;
        break;

      case SAI_DEBUG_COUNTER_TYPE_PORT_OUT_DROP_REASONS:
        index_base = SAI_PORT_STAT_OUT_DROP_REASON_RANGE_BASE;
        break;

      default:
        printf("Unsupported debug counter type '%d'\n", attr.value.s32);
        return 0;
    }

    attr.id = SAI_DEBUG_COUNTER_ATTR_INDEX;
    status = debug_counter_api->get_debug_counter_attribute(
        (sai_object_id_t)thrift_counter_id, 1, &attr);
    if (SAI_STATUS_SUCCESS != status) {
      return 0;
    }

    thrift_counter_ids.push_back(
        (sai_thrift_stat_id_t)(index_base + attr.value.u32));
    sai_thrift_get_port_stats_ext(thrift_counters,
                                  port_id,
                                  thrift_counter_ids,
                                  thrift_counter_ids.size());

    return thrift_counters[0];
  }

  int64_t sai_thrift_sai_get_debug_counter_type_availability(
      const int32_t dc_type) {
    printf("sai_thrift_sai_get_debug_counter_type_availability\n");

    const sai_thrift_object_id_t switch_id = 0;
    sai_attribute_t attr = {};
    attr.id = SAI_DEBUG_COUNTER_ATTR_TYPE;
    attr.value.s32 = dc_type;
    uint64_t count = 0;

    sai_object_type_get_availability(
        switch_id, SAI_OBJECT_TYPE_DEBUG_COUNTER, 1, &attr, &count);
    return count;
  }

  // applies to switch debug counters only
  // Debug counter types : SAI_DEBUG_COUNTER_TYPE_SWITCH_IN_DROP_REASONS and
  // SAI_DEBUG_COUNTER_TYPE_SWITCH_OUT_DROP_REASONS
  int64_t sai_thrift_get_debug_counter_switch_stats_by_oid(
      const sai_thrift_object_id_t thrift_counter_id) {
    printf("sai_thrift_get_debug_counter_switch_stats_by_oid\n");

    sai_debug_counter_api_t *debug_counter_api;
    std::vector<sai_thrift_stat_id_t> thrift_counter_ids;
    std::vector<int64_t> thrift_counters;
    std::vector<sai_thrift_stat_id_t> dc_id;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_attribute_t attr = {};
    int32_t index_base = 0;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (SAI_STATUS_SUCCESS != status) {
      return 0;
    }

    attr.id = SAI_DEBUG_COUNTER_ATTR_TYPE;
    status = debug_counter_api->get_debug_counter_attribute(
        (sai_object_id_t)thrift_counter_id, 1, &attr);
    if (SAI_STATUS_SUCCESS != status) {
      return 0;
    }

    switch (attr.value.s32) {
      case SAI_DEBUG_COUNTER_TYPE_SWITCH_IN_DROP_REASONS:
        index_base = SAI_SWITCH_STAT_IN_DROP_REASON_RANGE_BASE;
        break;

      case SAI_DEBUG_COUNTER_TYPE_SWITCH_OUT_DROP_REASONS:
        index_base = SAI_SWITCH_STAT_OUT_DROP_REASON_RANGE_BASE;
        break;

      default:
        printf("Unsupported debug counter type '%d'\n", attr.value.s32);
        return 0;
    }

    attr.id = SAI_DEBUG_COUNTER_ATTR_INDEX;
    status = debug_counter_api->get_debug_counter_attribute(
        (sai_object_id_t)thrift_counter_id, 1, &attr);
    if (SAI_STATUS_SUCCESS != status) {
      return 0;
    }

    thrift_counter_ids.push_back(
        (sai_thrift_stat_id_t)(index_base + attr.value.u32));
    sai_thrift_get_switch_stats_ext(thrift_counters,
                                    gSwitchId,
                                    thrift_counter_ids,
                                    thrift_counter_ids.size());

    return thrift_counters[0];
  }

  void sai_thrift_parse_debug_counter_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      int32_t **in_debug_counter_ids_list,
      int32_t **out_debug_counter_ids_list) {
    printf("sai_thrift_parse_debug_counter_attributes\n");

    sai_thrift_attribute_t attribute;
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();

    if (!in_debug_counter_ids_list || !out_debug_counter_ids_list) {
      SAI_THRIFT_LOG_ERR("Null pointer arguments passed.");
      return;
    }

    for (uint32_t i = 0; i < thrift_attr_list.size(); ++i, ++it) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_DEBUG_COUNTER_ATTR_IN_DROP_REASON_LIST: {
          *in_debug_counter_ids_list = (int32_t *)malloc(
              sizeof(int32_t) * attribute.value.s32list.count);
          if (!in_debug_counter_ids_list) {
            return;
          }
          for (uint32_t reason_idx = 0;
               reason_idx < attribute.value.s32list.s32list.size();
               ++reason_idx) {
            (*in_debug_counter_ids_list)[reason_idx] =
                attribute.value.s32list.s32list[reason_idx];
          }
          attr_list[i].value.s32list.count = attribute.value.s32list.count;
          attr_list[i].value.s32list.list = *in_debug_counter_ids_list;
          break;
        }
        case SAI_DEBUG_COUNTER_ATTR_OUT_DROP_REASON_LIST: {
          *out_debug_counter_ids_list = (int32_t *)malloc(
              sizeof(int32_t) * attribute.value.s32list.count);
          if (!out_debug_counter_ids_list) {
            return;
          }
          for (uint32_t reason_idx = 0;
               reason_idx < attribute.value.s32list.s32list.size();
               ++reason_idx) {
            (*out_debug_counter_ids_list)[reason_idx] =
                attribute.value.s32list.s32list[reason_idx];
          }
          attr_list[i].value.s32list.count = attribute.value.s32list.count;
          attr_list[i].value.s32list.list = *out_debug_counter_ids_list;
          break;
        }
        case SAI_DEBUG_COUNTER_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        default:
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_debug_counter(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    printf("sai_thrift_create_debug_counter\n");

    sai_debug_counter_api_t *debug_counter_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_object_id_t debug_counter_id = {};
    int32_t *in_debug_counter_ids_list = NULL;
    int32_t *out_debug_counter_ids_list = NULL;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      return debug_counter_id;
    }

    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_list.size());
    sai_thrift_parse_debug_counter_attributes(thrift_attr_list,
                                              attr_list,
                                              &in_debug_counter_ids_list,
                                              &out_debug_counter_ids_list);
    uint32_t list_count = thrift_attr_list.size();

    status = debug_counter_api->create_debug_counter(
        &debug_counter_id, gSwitchId, list_count, attr_list);

    free(attr_list);
    free(in_debug_counter_ids_list);
    free(out_debug_counter_ids_list);

    return debug_counter_id;
  }

  sai_thrift_status_t sai_thrift_remove_debug_counter(
      const sai_thrift_object_id_t thrift_debug_counter_id) {
    printf("sai_thrift_remove_debug_counter\n");

    sai_debug_counter_api_t *debug_counter_api;
    sai_status_t status = SAI_STATUS_SUCCESS;

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    status = debug_counter_api->remove_debug_counter(
        (sai_object_id_t)thrift_debug_counter_id);

    return status;
  }

  sai_thrift_status_t sai_thrift_set_debug_counter_attribute(
      const sai_thrift_object_id_t dc_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_debug_counter_api_t *debug_counter_api;
    int32_t *in_debug_counter_ids_list = NULL;
    int32_t *out_debug_counter_ids_list = NULL;

    printf("sai_thrift_set_debug_counter_attribute\n");

    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;

    sai_thrift_parse_debug_counter_attributes(thrift_attr_list,
                                              &attr,
                                              &in_debug_counter_ids_list,
                                              &out_debug_counter_ids_list);

    status = debug_counter_api->set_debug_counter_attribute(dc_id, &attr);

    free(in_debug_counter_ids_list);
    free(out_debug_counter_ids_list);

    return status;
  }

  void sai_thrift_get_debug_counter(
      sai_thrift_attribute_t &ret_thrift_attr,
      const sai_thrift_object_id_t debug_counter_id,
      const int32_t list_count,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_debug_counter_api_t *debug_counter_api;
    sai_attribute_t sai_attr;
    memset(&sai_attr, 0, sizeof(sai_attribute_t));
    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    sai_attr.id = thrift_attr.id;
    if ((sai_attr.id == SAI_DEBUG_COUNTER_ATTR_IN_DROP_REASON_LIST) ||
        (sai_attr.id == SAI_DEBUG_COUNTER_ATTR_OUT_DROP_REASON_LIST)) {
      assert(list_count != 0);
      sai_attr.value.s32list.list =
          (int32_t *)calloc(list_count, sizeof(int32_t));
      sai_attr.value.s32list.count = list_count;
    }

    status = debug_counter_api->get_debug_counter_attribute(
        debug_counter_id, 1, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    ret_thrift_attr.id = thrift_attr.id;
    if (sai_attr.id == SAI_DEBUG_COUNTER_ATTR_TYPE) {
      ret_thrift_attr.value.s32 = sai_attr.value.s32;
    } else if (sai_attr.id == SAI_DEBUG_COUNTER_ATTR_INDEX) {
      ret_thrift_attr.value.u32 = sai_attr.value.u32;
    } else {
      for (uint i = 0; i < sai_attr.value.s32list.count; i++) {
        ret_thrift_attr.value.s32list.s32list.push_back(
            sai_attr.value.s32list.list[i]);
      }
      ret_thrift_attr.value.s32list.count = sai_attr.value.s32list.count;
    }
    if ((sai_attr.id == SAI_DEBUG_COUNTER_ATTR_IN_DROP_REASON_LIST) ||
        (sai_attr.id == SAI_DEBUG_COUNTER_ATTR_OUT_DROP_REASON_LIST)) {
      free(sai_attr.value.s32list.list);
    }
  }

  //
  // SAI Next Hop Group API
  // *****************************************************************************************
  //

  void sai_thrift_parse_next_hop_group_attributes(
      sai_attribute_t *attr_list,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept {
    if (thrift_attr_list.empty() || attr_list == nullptr) {
      SAI_THRIFT_LOG_ERR("Invalid input arguments.");
      return;
    }

    std::vector<sai_thrift_attribute_t>::const_iterator cit =
        thrift_attr_list.begin();

    for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++) {
      sai_thrift_attribute_t attribute = *cit;
      attr_list[i].id = attribute.id;

      switch (attribute.id) {
        case SAI_NEXT_HOP_GROUP_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;

        case SAI_NEXT_HOP_GROUP_ATTR_CONFIGURED_SIZE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;

        default:
          SAI_THRIFT_LOG_ERR("Failed to parse attributes.");
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_next_hop_group_api_t *nhop_group_api = nullptr;
    auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP,
                                reinterpret_cast<void **>(&nhop_group_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list = nullptr;
    sai_uint32_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_next_hop_group_attributes(attr_list, thrift_attr_list);

    sai_object_id_t nhop_group_oid = 0;
    status = nhop_group_api->create_next_hop_group(
        &nhop_group_oid, gSwitchId, attr_size, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return nhop_group_oid;
    }

    SAI_THRIFT_LOG_ERR("Failed to create group.");

    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop_group(
      const sai_thrift_object_id_t nhop_group_oid) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_next_hop_group_api_t *nhop_group_api = nullptr;
    auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP,
                                reinterpret_cast<void **>(&nhop_group_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    status = nhop_group_api->remove_next_hop_group(nhop_group_oid);

    SAI_THRIFT_LOG_DBG("Exited.");

    return status;
  }

  void sai_thrift_get_next_hop_group_attr(
      sai_thrift_attribute_t &get_attr,
      const sai_thrift_object_id_t nhop_grp_id) {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_next_hop_group_api_t *nhop_grp_api = nullptr;
    auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP,
                                reinterpret_cast<void **>(&nhop_grp_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return;
    }
    sai_attribute_t sai_attr;
    sai_attr.id = SAI_NEXT_HOP_GROUP_ATTR_REAL_SIZE;
    sai_attr.value.u32 = 0;
    status = nhop_grp_api->get_next_hop_group_attribute(
        (sai_object_id_t)nhop_grp_id, 1, &sai_attr);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to retrive the next_hop_group attribute.");
      return;
    }
    get_attr.id = sai_attr.id;
    get_attr.value.u32 = sai_attr.value.u32;
    SAI_THRIFT_LOG_DBG("Exited.");
  }

  void sai_thrift_attr_to_sai_attr(
      sai_attribute_t &sai_attr,
      const sai_thrift_attribute_t &attribute) noexcept {
    sai_attr.id = attribute.id;
    switch (attribute.id) {
      case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_GROUP_ID:
      case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_ID:
        sai_attr.value.oid = attribute.value.oid;
        break;

      case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_WEIGHT:
        sai_attr.value.u32 = attribute.value.u32;
        break;

      case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_INDEX:
        sai_attr.value.u32 = attribute.value.u32;
        break;

      default:
        SAI_THRIFT_LOG_ERR("Parsing Error: Unsupported attribute");
        break;
    }
  }

  void sai_attr_to_sai_thrift_attr(const sai_attribute_t &sai_attr,
                                   sai_thrift_attribute_t &attribute) noexcept {
    attribute.id = sai_attr.id;
    switch (sai_attr.id) {
      case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_GROUP_ID:
      case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_NEXT_HOP_ID:
        attribute.value.oid = sai_attr.value.oid;
        break;

      case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_WEIGHT:
        attribute.value.u32 = sai_attr.value.u32;
        break;

      case SAI_NEXT_HOP_GROUP_MEMBER_ATTR_INDEX:
        attribute.value.u32 = sai_attr.value.u32;
        break;

      default:
        SAI_THRIFT_LOG_ERR("Parsing Error: Unsupported attribute");
        break;
    }
  }

  void sai_thrift_parse_next_hop_group_member_attributes(
      sai_attribute_t *attr_list,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept {
    if (thrift_attr_list.empty() || attr_list == nullptr) {
      SAI_THRIFT_LOG_ERR("Invalid input arguments.");
      return;
    }

    std::vector<sai_thrift_attribute_t>::const_iterator cit =
        thrift_attr_list.begin();

    for (sai_uint32_t i = 0; i < thrift_attr_list.size(); i++, cit++) {
      sai_thrift_attribute_t attribute = *cit;
      attr_list[i].id = attribute.id;
      sai_thrift_attr_to_sai_attr(attr_list[i], attribute);
    }
  }

  sai_thrift_object_id_t sai_thrift_create_next_hop_group_member(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_next_hop_group_api_t *nhop_group_api = nullptr;
    auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP,
                                reinterpret_cast<void **>(&nhop_group_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return SAI_NULL_OBJECT_ID;
    }

    sai_attribute_t *attr_list = nullptr;
    sai_uint32_t attr_size = thrift_attr_list.size();
    sai_thrift_alloc_attr(attr_list, attr_size);
    sai_thrift_parse_next_hop_group_member_attributes(attr_list,
                                                      thrift_attr_list);

    sai_object_id_t nhop_group_member_oid = 0;
    status = nhop_group_api->create_next_hop_group_member(
        &nhop_group_member_oid, gSwitchId, attr_size, attr_list);
    sai_thrift_free_attr(attr_list);

    if (status == SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_DBG("Exited.");
      return nhop_group_member_oid;
    }

    SAI_THRIFT_LOG_ERR("Failed to create group member.");

    return SAI_NULL_OBJECT_ID;
  }

  sai_thrift_status_t sai_thrift_remove_next_hop_group_member(
      const sai_thrift_object_id_t nhop_group_member_oid) noexcept {
    SAI_THRIFT_LOG_DBG("Called.");

    sai_next_hop_group_api_t *nhop_group_api = nullptr;
    auto status = sai_api_query(SAI_API_NEXT_HOP_GROUP,
                                reinterpret_cast<void **>(&nhop_group_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    status =
        nhop_group_api->remove_next_hop_group_member(nhop_group_member_oid);

    SAI_THRIFT_LOG_DBG("Exited.");

    return status;
  }

  sai_thrift_status_t sai_thrift_set_next_hop_group_member_attr(
      sai_thrift_object_id_t nhop_gmem_id,
      const sai_thrift_attribute_t &thrift_attr) {
    SAI_THRIFT_LOG_DBG("Called.");
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_next_hop_group_api_t *nhop_group_api = nullptr;
    status = sai_api_query(SAI_API_NEXT_HOP_GROUP,
                           reinterpret_cast<void **>(&nhop_group_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return status;
    }

    sai_attribute_t sai_attr;
    sai_thrift_attr_to_sai_attr(sai_attr, thrift_attr);
    status = nhop_group_api->set_next_hop_group_member_attribute(
        (sai_object_id_t)nhop_gmem_id, &sai_attr);

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to set next-hop-group-member attribute.");
    }
    return status;
  }

  void sai_thrift_get_next_hop_group_member_attr(
      sai_thrift_attribute_t &thrift_attr,
      sai_thrift_object_id_t nhop_gmem_id,
      const sai_thrift_attribute_t &attr) {
    SAI_THRIFT_LOG_DBG("Called.");
    sai_status_t status = SAI_STATUS_SUCCESS;

    sai_next_hop_group_api_t *nhop_group_api = nullptr;
    status = sai_api_query(SAI_API_NEXT_HOP_GROUP,
                           reinterpret_cast<void **>(&nhop_group_api));

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to get API.");
      return;
    }

    sai_attribute_t sai_attr;
    sai_thrift_attr_to_sai_attr(sai_attr, attr);
    status = nhop_group_api->get_next_hop_group_member_attribute(
        (sai_object_id_t)nhop_gmem_id, 1, &sai_attr);

    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to set next-hop-group-member attribute.");
    }
    sai_attr_to_sai_thrift_attr(sai_attr, thrift_attr);
    return;
  }

  // Sample Packet API
  void sai_thrift_parse_samplepacket_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_SAMPLEPACKET_ATTR_SAMPLE_RATE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_SAMPLEPACKET_ATTR_MODE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_SAMPLEPACKET_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
      }
    }
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_samplepacket(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_samplepacket_api_t *samplepacket_api;
    sai_object_id_t samplepacket_id;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_samplepacket_attributes(thrift_attr_list, attr_list);
    status = samplepacket_api->create_samplepacket(
        &samplepacket_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to create sample packet. Status: %d", status);
      return SAI_NULL_OBJECT_ID;
    }
    return samplepacket_id;
  }

  sai_thrift_status_t sai_thrift_remove_samplepacket(
      const sai_thrift_object_id_t samplepacket_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_samplepacket_api_t *samplepacket_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = samplepacket_api->remove_samplepacket(samplepacket_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_samplepacket_attribute(
      const sai_thrift_object_id_t samplepacket_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_samplepacket_api_t *samplepacket_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_SAMPLEPACKET, (void **)&samplepacket_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;
    sai_thrift_parse_samplepacket_attributes(thrift_attr_list, &attr);
    status = samplepacket_api->set_samplepacket_attribute(
        (sai_object_id_t)samplepacket_id, &attr);
    return status;
  }

  ////////////////////////////////////////////////////////////////////////////////
  void sai_thrift_parse_dtel_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_object_id_t **dtel_sink_port_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_DTEL_ATTR_SINK_PORT_LIST: {
          if (attribute.value.objlist.count > 0) {
            *dtel_sink_port_list = (sai_object_id_t *)malloc(
                sizeof(sai_object_id_t) * attribute.value.objlist.count);
            std::vector<sai_thrift_object_id_t>::const_iterator it1 =
                attribute.value.objlist.object_id_list.begin();
            for (int j = 0; j < attribute.value.objlist.count; j++, it1++) {
              (*dtel_sink_port_list)[j] = (sai_object_id_t)(*it1);
            }
            attr_list[i].value.objlist.count = attribute.value.objlist.count;
            attr_list[i].value.objlist.list = *dtel_sink_port_list;
          } else {
            *dtel_sink_port_list = NULL;
            attr_list[i].value.objlist.count = 0;
            attr_list[i].value.objlist.list = NULL;
          }
          break;
        }
        case SAI_DTEL_ATTR_INT_ENDPOINT_ENABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_DTEL_ATTR_INT_TRANSIT_ENABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_DTEL_ATTR_POSTCARD_ENABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_DTEL_ATTR_DROP_REPORT_ENABLE:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        case SAI_DTEL_ATTR_SWITCH_ID:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_DTEL_ATTR_FLOW_STATE_CLEAR_CYCLE:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        case SAI_DTEL_ATTR_LATENCY_SENSITIVITY:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_DTEL_ATTR_INT_L4_DSCP:
          attr_list[i].value.aclfield.data.u8 =
              attribute.value.aclfield.data.u8;
          attr_list[i].value.aclfield.mask.u8 =
              attribute.value.aclfield.mask.u8;
          break;
      }
    }
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;
    sai_object_id_t dtel_id;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_object_id_t *dtel_sink_port_list = NULL;
    sai_thrift_parse_dtel_attributes(
        thrift_attr_list, attr_list, &dtel_sink_port_list);
    status = dtel_api->create_dtel(&dtel_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    free(dtel_sink_port_list);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to create DTEL. Status: %d", status);
      return SAI_NULL_OBJECT_ID;
    }
    return dtel_id;
  }

  sai_thrift_status_t sai_thrift_remove_dtel(
      const sai_thrift_object_id_t dtel_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = dtel_api->remove_dtel(dtel_id);
    return status;
  }

  void sai_thrift_convert_to_dtel_thrift_attributes(
      sai_attribute_t *attr_list,
      int attr_count,
      sai_thrift_attribute_list_t &thrift_attr_value_list) {
    sai_attribute_t sai_attr;
    sai_thrift_attribute_t thrift_dtel_attribute;

    thrift_attr_value_list.attr_count = attr_count;
    for (int i = 0; i < attr_count; i++) {
      sai_attr = attr_list[i];
      thrift_dtel_attribute.id = sai_attr.id;
      switch (sai_attr.id) {
        case SAI_DTEL_ATTR_INT_ENDPOINT_ENABLE:
        case SAI_DTEL_ATTR_INT_TRANSIT_ENABLE:
        case SAI_DTEL_ATTR_POSTCARD_ENABLE:
        case SAI_DTEL_ATTR_DROP_REPORT_ENABLE:
          thrift_dtel_attribute.value.booldata = sai_attr.value.booldata;
          break;
        case SAI_DTEL_ATTR_SWITCH_ID:
          thrift_dtel_attribute.value.u32 = sai_attr.value.u32;
          break;
        case SAI_DTEL_ATTR_FLOW_STATE_CLEAR_CYCLE:
          thrift_dtel_attribute.value.u16 = sai_attr.value.u16;
          break;
        case SAI_DTEL_ATTR_LATENCY_SENSITIVITY:
          thrift_dtel_attribute.value.u8 = sai_attr.value.u8;
          break;
        case SAI_DTEL_ATTR_INT_L4_DSCP:
          thrift_dtel_attribute.value.aclfield.data.u8 =
              sai_attr.value.aclfield.data.u8;
          thrift_dtel_attribute.value.aclfield.mask.u8 =
              sai_attr.value.aclfield.mask.u8;
          break;
        default:
          break;
      }
      thrift_attr_value_list.attr_list.push_back(thrift_dtel_attribute);
    }
  }

  void sai_thrift_get_dtel_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_object_id_t dtel_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    uint32_t attr_count = thrift_attr_ids.size();
    if (attr_count == 0) {
      return;
    }
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);

    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_ids.size());

    memset(
        attr_list, 0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
    status = dtel_api->get_dtel_attribute(dtel_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      free(attr_list);
      return;
    }

    sai_thrift_convert_to_dtel_thrift_attributes(
        attr_list, attr_count, thrift_attr_values);
  }

  void sai_thrift_convert_to_dc_thrift_attributes(
      sai_attribute_t *attr_list,
      int attr_count,
      sai_thrift_attribute_list_t &thrift_attr_value_list) {
    sai_attribute_t sai_attr;
    sai_thrift_attribute_t thrift_dc_attribute;

    printf("sai_thrift_convert_to_dc_thrift_attributes\n");
    thrift_attr_value_list.attr_count = attr_count;
    for (int i = 0; i < attr_count; i++) {
      sai_attr = attr_list[i];
      thrift_dc_attribute.id = sai_attr.id;
      switch (sai_attr.id) {
        case SAI_DEBUG_COUNTER_ATTR_TYPE:
          thrift_dc_attribute.value.s32 = sai_attr.value.s32;
          break;
        case SAI_DEBUG_COUNTER_ATTR_INDEX:
          thrift_dc_attribute.value.u32 = sai_attr.value.u32;
          break;
        case SAI_DEBUG_COUNTER_ATTR_OUT_DROP_REASON_LIST:
        case SAI_DEBUG_COUNTER_ATTR_IN_DROP_REASON_LIST:
          thrift_dc_attribute.value.s32list.count =
              sai_attr.value.s32list.count;
          for (uint j = 0; j < sai_attr.value.s32list.count; j++) {
            thrift_dc_attribute.value.s32list.s32list[j] =
                sai_attr.value.s32list.list[j];
          }
          break;
        default:
          break;
      }
      thrift_attr_value_list.attr_list.push_back(thrift_dc_attribute);
    }
  }

  void sai_thrift_get_debug_counter_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_object_id_t dc_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_debug_counter_api_t *debug_counter_api;

    printf("sai_thrift_get_debug_counter_attribute\n");

    SAI_THRIFT_FUNC_LOG();
    uint32_t attr_count = thrift_attr_ids.size();
    if (attr_count == 0) {
      return;
    }
    status = sai_api_query(SAI_API_DEBUG_COUNTER, (void **)&debug_counter_api);

    sai_attribute_t *attr_list = (sai_attribute_t *)malloc(
        sizeof(sai_attribute_t) * thrift_attr_ids.size());

    memset(
        attr_list, 0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
    status = debug_counter_api->get_debug_counter_attribute(
        dc_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      free(attr_list);
      return;
    }

    sai_thrift_convert_to_dc_thrift_attributes(
        attr_list, attr_count, thrift_attr_values);
    free(attr_list);
  }

  int32_t sai_thrift_set_dtel_attribute(
      const sai_thrift_object_id_t dtel_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;
    sai_object_id_t *dtel_sink_port_list = NULL;
    sai_thrift_parse_dtel_attributes(
        thrift_attr_list, &attr, &dtel_sink_port_list);
    status = dtel_api->set_dtel_attribute((sai_object_id_t)dtel_id, &attr);
    free(dtel_sink_port_list);
    return status;
  }

  void sai_thrift_parse_dtel_queue_report_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_DTEL_QUEUE_REPORT_ATTR_QUEUE_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_DTEL_QUEUE_REPORT_ATTR_DEPTH_THRESHOLD:
        case SAI_DTEL_QUEUE_REPORT_ATTR_LATENCY_THRESHOLD:
        case SAI_DTEL_QUEUE_REPORT_ATTR_BREACH_QUOTA:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_DTEL_QUEUE_REPORT_ATTR_TAIL_DROP:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        default:
          break;
      }
    }
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_queue_report(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;
    sai_object_id_t dtel_queue_report_id;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_dtel_queue_report_attributes(thrift_attr_list, attr_list);
    status = dtel_api->create_dtel_queue_report(
        &dtel_queue_report_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to create DTEL queue report. Status: %d",
                         status);
      return SAI_NULL_OBJECT_ID;
    }
    return dtel_queue_report_id;
  }

  sai_thrift_status_t sai_thrift_remove_dtel_queue_report(
      const sai_thrift_object_id_t dtel_queue_report_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = dtel_api->remove_dtel_queue_report(dtel_queue_report_id);
    return status;
  }

  void sai_thrift_convert_to_dtel_queue_report_thrift_attributes(
      sai_attribute_t *attr_list,
      int attr_count,
      sai_thrift_attribute_list_t &thrift_attr_value_list) {
    sai_attribute_t sai_attr;
    sai_thrift_attribute_t thrift_dtel_queue_report_attribute;

    thrift_attr_value_list.attr_count = attr_count;
    for (int i = 0; i < attr_count; i++) {
      sai_attr = attr_list[i];
      thrift_dtel_queue_report_attribute.id = sai_attr.id;
      switch (sai_attr.id) {
        case SAI_DTEL_QUEUE_REPORT_ATTR_QUEUE_ID:
        case SAI_DTEL_QUEUE_REPORT_ATTR_DEPTH_THRESHOLD:
        case SAI_DTEL_QUEUE_REPORT_ATTR_LATENCY_THRESHOLD:
          thrift_dtel_queue_report_attribute.value.u32 = sai_attr.value.u32;
          break;
        default:
          break;
      }
      thrift_attr_value_list.attr_list.push_back(
          thrift_dtel_queue_report_attribute);
    }
  }

  void sai_thrift_get_dtel_queue_report_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_object_id_t dtel_queue_report_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);

    uint32_t attr_count = thrift_attr_ids.size();
    if (attr_count == 0) {
      return;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);

    memset(
        attr_list, 0, sizeof(sizeof(sai_attribute_t) * thrift_attr_ids.size()));
    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
    status = dtel_api->get_dtel_queue_report_attribute(
        dtel_queue_report_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      free(attr_list);
      return;
    }

    sai_thrift_convert_to_dtel_queue_report_thrift_attributes(
        attr_list, attr_count, thrift_attr_values);
    free(attr_list);
    return;
  }

  int32_t sai_thrift_set_dtel_queue_report_attribute(
      const sai_thrift_object_id_t dtel_queue_report_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;
    sai_thrift_parse_dtel_queue_report_attributes(thrift_attr_list, &attr);
    status = dtel_api->set_dtel_queue_report_attribute(
        (sai_object_id_t)dtel_queue_report_id, &attr);
    return status;
  }

  void sai_thrift_parse_dtel_int_session_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_DTEL_INT_SESSION_ATTR_MAX_HOP_COUNT:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_SWITCH_ID:
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_SWITCH_PORTS:
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_INGRESS_TIMESTAMP:
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_EGRESS_TIMESTAMP:
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_QUEUE_INFO:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;
        default:
          break;
      }
    }
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_int_session(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;
    sai_object_id_t dtel_int_session_id;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_dtel_int_session_attributes(thrift_attr_list, attr_list);
    status = dtel_api->create_dtel_int_session(
        &dtel_int_session_id, gSwitchId, attr_count, attr_list);
    free(attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to create DTEL int session. Status: %d",
                         status);
      return SAI_NULL_OBJECT_ID;
    }
    return dtel_int_session_id;
  }

  sai_thrift_status_t sai_thrift_remove_dtel_int_session(
      const sai_thrift_object_id_t dtel_int_session_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = dtel_api->remove_dtel_int_session(dtel_int_session_id);
    return status;
  }

  void sai_thrift_convert_to_dtel_int_session_thrift_attributes(
      sai_attribute_t *attr_list,
      int attr_count,
      sai_thrift_attribute_list_t &thrift_attr_value_list) {
    sai_attribute_t sai_attr;
    sai_thrift_attribute_t thrift_dtel_int_session_attribute;

    thrift_attr_value_list.attr_count = attr_count;
    for (int i = 0; i < attr_count; i++) {
      sai_attr = attr_list[i];
      thrift_dtel_int_session_attribute.id = sai_attr.id;
      switch (sai_attr.id) {
        case SAI_DTEL_INT_SESSION_ATTR_MAX_HOP_COUNT:
          thrift_dtel_int_session_attribute.value.u8 = sai_attr.value.u8;
          break;
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_SWITCH_ID:
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_SWITCH_PORTS:
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_INGRESS_TIMESTAMP:
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_EGRESS_TIMESTAMP:
        case SAI_DTEL_INT_SESSION_ATTR_COLLECT_QUEUE_INFO:
          thrift_dtel_int_session_attribute.value.booldata =
              sai_attr.value.booldata;
          break;
        default:
          break;
      }
      thrift_attr_value_list.attr_list.push_back(
          thrift_dtel_int_session_attribute);
    }
  }

  void sai_thrift_get_dtel_int_session_attribute(
      sai_thrift_attribute_list_t &thrift_attr_values,
      const sai_thrift_object_id_t dtel_int_session_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);

    uint32_t attr_count = thrift_attr_ids.size();
    if (attr_count == 0) {
      return;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);

    memset(attr_list, 0, sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_attribute_ids(thrift_attr_ids, attr_list);
    status = dtel_api->get_dtel_int_session_attribute(
        dtel_int_session_id, attr_count, attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      free(attr_list);
      return;
    }

    sai_thrift_convert_to_dtel_int_session_thrift_attributes(
        attr_list, attr_count, thrift_attr_values);
    free(attr_list);
    return;
  }

  sai_thrift_status_t sai_thrift_set_dtel_int_session_attribute(
      const sai_thrift_object_id_t dtel_int_session_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;
    sai_thrift_parse_dtel_int_session_attributes(thrift_attr_list, &attr);
    status = dtel_api->set_dtel_int_session_attribute(
        (sai_object_id_t)dtel_int_session_id, &attr);
    return status;
  }

  void sai_thrift_parse_dtel_report_session_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_ip_address_t **dst_ip_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;

    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_DTEL_REPORT_SESSION_ATTR_SRC_IP:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;
        case SAI_DTEL_REPORT_SESSION_ATTR_DST_IP_LIST: {
          if (attribute.value.ipaddrlist.count > 0) {
            *dst_ip_list = (sai_ip_address_t *)malloc(
                sizeof(sai_ip_address_t) * attribute.value.ipaddrlist.count);
            std::vector<sai_thrift_ip_address_t>::const_iterator it1 =
                attribute.value.ipaddrlist.ipaddr_list.begin();
            for (int j = 0; j < attribute.value.ipaddrlist.count; j++, it1++) {
              sai_thrift_parse_ip_address(*it1, &(*dst_ip_list)[j]);
            }
            attr_list[i].value.ipaddrlist.count =
                attribute.value.ipaddrlist.count;
            attr_list[i].value.ipaddrlist.list = *dst_ip_list;
          } else {
            *dst_ip_list = NULL;
            attr_list[i].value.ipaddrlist.count = 0;
            attr_list[i].value.ipaddrlist.list = NULL;
          }
          break;
        }
        case SAI_DTEL_REPORT_SESSION_ATTR_VIRTUAL_ROUTER_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_DTEL_REPORT_SESSION_ATTR_TRUNCATE_SIZE:
        case SAI_DTEL_REPORT_SESSION_ATTR_UDP_DST_PORT:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        default:
          break;
      }
    }
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_report_session(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;
    sai_object_id_t dtel_report_session_id;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);

    sai_ip_address_t *dst_ip_list = NULL;
    sai_thrift_parse_dtel_report_session_attributes(
        thrift_attr_list, attr_list, &dst_ip_list);
    status = dtel_api->create_dtel_report_session(
        &dtel_report_session_id, gSwitchId, attr_count, attr_list);

    free(dst_ip_list);
    free(attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to create DTEL report session. Status: %d",
                         status);
      return SAI_NULL_OBJECT_ID;
    }
    return dtel_report_session_id;
  }

  sai_thrift_status_t sai_thrift_remove_dtel_report_session(
      const sai_thrift_object_id_t dtel_report_session_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = dtel_api->remove_dtel_report_session(dtel_report_session_id);
    return status;
  }

  void sai_thrift_parse_dtel_event_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;

    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_DTEL_EVENT_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        case SAI_DTEL_EVENT_ATTR_REPORT_SESSION:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_DTEL_EVENT_ATTR_DSCP_VALUE:
          attr_list[i].value.u8 = attribute.value.u8;
          break;
        default:
          break;
      }
    }
    return;
  }

  sai_thrift_object_id_t sai_thrift_create_dtel_event(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;
    sai_object_id_t dtel_event_id;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);

    sai_thrift_parse_dtel_event_attributes(thrift_attr_list, attr_list);
    status = dtel_api->create_dtel_event(
        &dtel_event_id, gSwitchId, attr_count, attr_list);

    free(attr_list);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to create DTEL event. Status: %d", status);
      return SAI_NULL_OBJECT_ID;
    }
    return dtel_event_id;
  }

  sai_thrift_status_t sai_thrift_remove_dtel_event(
      const sai_thrift_object_id_t dtel_event_id) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = dtel_api->remove_dtel_event(dtel_event_id);
    return status;
  }

  sai_thrift_status_t sai_thrift_set_dtel_event_attribute(
      const sai_thrift_object_id_t dtel_event_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_dtel_api_t *dtel_api;

    SAI_THRIFT_FUNC_LOG();
    status = sai_api_query(SAI_API_DTEL, (void **)&dtel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;
    sai_thrift_parse_dtel_event_attributes(thrift_attr_list, &attr);
    status = dtel_api->set_dtel_event_attribute((sai_object_id_t)dtel_event_id,
                                                &attr);
    return status;
  }

  void sai_thrift_parse_tunnel_map_entry_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_TUNNEL_MAP_ENTRY_ATTR_TUNNEL_MAP_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;

        case SAI_TUNNEL_MAP_ENTRY_ATTR_TUNNEL_MAP:
          attr_list[i].value.oid = attribute.value.oid;
          break;

        case SAI_TUNNEL_MAP_ENTRY_ATTR_OECN_KEY:
        case SAI_TUNNEL_MAP_ENTRY_ATTR_OECN_VALUE:
        case SAI_TUNNEL_MAP_ENTRY_ATTR_UECN_KEY:
        case SAI_TUNNEL_MAP_ENTRY_ATTR_UECN_VALUE:
          attr_list[i].value.u8 = attribute.value.u8;
          break;

        case SAI_TUNNEL_MAP_ENTRY_ATTR_VLAN_ID_KEY:
        case SAI_TUNNEL_MAP_ENTRY_ATTR_VLAN_ID_VALUE:
          attr_list[i].value.u16 = attribute.value.u16;
          break;

        case SAI_TUNNEL_MAP_ENTRY_ATTR_VNI_ID_KEY:
        case SAI_TUNNEL_MAP_ENTRY_ATTR_VNI_ID_VALUE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;

        case SAI_TUNNEL_MAP_ENTRY_ATTR_BRIDGE_ID_KEY:
        case SAI_TUNNEL_MAP_ENTRY_ATTR_BRIDGE_ID_VALUE:
        case SAI_TUNNEL_MAP_ENTRY_ATTR_VIRTUAL_ROUTER_ID_KEY:
        case SAI_TUNNEL_MAP_ENTRY_ATTR_VIRTUAL_ROUTER_ID_VALUE:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_tunnel_map_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_TUNNEL_MAP_ATTR_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;
        default:
          break;
      }
    }
  }

  void sai_thrift_parse_tunnel_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list,
      sai_object_id_t **ing_mapper_list,
      sai_object_id_t **eg_mapper_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_TUNNEL_ATTR_TYPE:
        case SAI_TUNNEL_ATTR_ENCAP_TTL_MODE:
        case SAI_TUNNEL_ATTR_ENCAP_DSCP_MODE:
        case SAI_TUNNEL_ATTR_ENCAP_ECN_MODE:
        case SAI_TUNNEL_ATTR_DECAP_ECN_MODE:
        case SAI_TUNNEL_ATTR_DECAP_TTL_MODE:
        case SAI_TUNNEL_ATTR_DECAP_DSCP_MODE:
        case SAI_TUNNEL_ATTR_PEER_MODE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;

        case SAI_TUNNEL_ATTR_UNDERLAY_INTERFACE:
        case SAI_TUNNEL_ATTR_OVERLAY_INTERFACE:
          attr_list[i].value.oid = attribute.value.oid;
          break;
        case SAI_TUNNEL_ATTR_ENCAP_SRC_IP:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;

        case SAI_TUNNEL_ATTR_ENCAP_TTL_VAL:
        case SAI_TUNNEL_ATTR_ENCAP_DSCP_VAL:
          attr_list[i].value.u8 = attribute.value.u8;
          break;

        case SAI_TUNNEL_ATTR_ENCAP_GRE_KEY_VALID:
          attr_list[i].value.booldata = attribute.value.booldata;
          break;

        case SAI_TUNNEL_ATTR_ENCAP_GRE_KEY:
          attr_list[i].value.u32 = attribute.value.u32;
          break;

        case SAI_TUNNEL_ATTR_ENCAP_MAPPERS: {
          if (attribute.value.objlist.count > 0) {
            *ing_mapper_list = (sai_object_id_t *)malloc(
                sizeof(sai_object_id_t) * attribute.value.objlist.count);
            std::vector<sai_thrift_object_id_t>::const_iterator it2 =
                attribute.value.objlist.object_id_list.begin();
            for (uint32_t j = 0;
                 j < attribute.value.objlist.object_id_list.size();
                 j++, *it2++) {
              *ing_mapper_list[j] = (sai_object_id_t)*it2;
            }
            attr_list[i].value.objlist.count = attribute.value.objlist.count;
            attr_list[i].value.objlist.list = *ing_mapper_list;
          } else {
            *ing_mapper_list = NULL;
            attr_list[i].value.objlist.count = 0;
            attr_list[i].value.objlist.list = NULL;
          }
          break;
        }

        case SAI_TUNNEL_ATTR_DECAP_MAPPERS: {
          if (attribute.value.objlist.count > 0) {
            *eg_mapper_list = (sai_object_id_t *)malloc(
                sizeof(sai_object_id_t) * attribute.value.objlist.count);
            std::vector<sai_thrift_object_id_t>::const_iterator it2 =
                attribute.value.objlist.object_id_list.begin();
            for (uint32_t j = 0;
                 j < attribute.value.objlist.object_id_list.size();
                 j++, *it2++) {
              *eg_mapper_list[j] = (sai_object_id_t)*it2;
            }
            attr_list[i].value.objlist.count = attribute.value.objlist.count;
            attr_list[i].value.objlist.list = *eg_mapper_list;
          } else {
            *eg_mapper_list = NULL;
            attr_list[i].value.objlist.count = 0;
            attr_list[i].value.objlist.list = NULL;
          }
          break;
        }

        default:
          break;
      }
    }
  }

  void sai_thrift_parse_tunnel_term_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_VR_ID:
        case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_ACTION_TUNNEL_ID:
          attr_list[i].value.oid = attribute.value.oid;
          break;

        case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TYPE:
        case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_TUNNEL_TYPE:
          attr_list[i].value.s32 = attribute.value.s32;
          break;

        case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_DST_IP:
        case SAI_TUNNEL_TERM_TABLE_ENTRY_ATTR_SRC_IP:
          sai_thrift_parse_ip_address(attribute.value.ipaddr,
                                      &attr_list[i].value.ipaddr);
          break;

        default:
          break;
      }
    }
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_map(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    sai_object_id_t tunnel_map_id = 0;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_tunnel_map_attributes(thrift_attr_list, attr_list);
    tunnel_api->create_tunnel_map(&tunnel_map_id, 0, attr_count, attr_list);
    free(attr_list);
    return tunnel_map_id;
  }

  sai_thrift_status_t sai_thrift_remove_tunnel_map(
      const sai_thrift_object_id_t tunnel_map_id) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = tunnel_api->remove_tunnel_map((sai_object_id_t)tunnel_map_id);
    return status;
  }

  void sai_thrift_get_tunnel_map(std::vector<sai_thrift_attribute_t> &_return,
                                 const sai_thrift_object_id_t tunnel_map_id,
                                 const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    return;
  }

  sai_thrift_status_t sai_thrift_set_tunnel_map(
      const sai_thrift_object_id_t tunnel_map_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_map_entry(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    sai_object_id_t tunnel_map_entry_id = 0;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_tunnel_map_entry_attributes(thrift_attr_list, attr_list);
    tunnel_api->create_tunnel_map_entry(
        &tunnel_map_entry_id, 0, attr_count, attr_list);
    free(attr_list);
    return tunnel_map_entry_id;
  }

  sai_thrift_status_t sai_thrift_remove_tunnel_map_entry(
      const sai_thrift_object_id_t tunnel_map_entry_id) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = tunnel_api->remove_tunnel_map_entry(
        (sai_object_id_t)tunnel_map_entry_id);
    return status;
  }

  void sai_thrift_get_tunnel_map_entry(
      std::vector<sai_thrift_attribute_t> &thrift_attr_values,
      const sai_thrift_object_id_t tunnel_map_entry_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    return;
  }

  sai_thrift_status_t sai_thrift_set_tunnel_map_entry(
      const sai_thrift_object_id_t tunnel_map_entry_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    sai_object_id_t tunnel_id = 0;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);

    sai_object_id_t *ing_mapper_list = NULL;
    sai_object_id_t *eg_mapper_list = NULL;
    sai_thrift_parse_tunnel_attributes(
        thrift_attr_list, attr_list, &ing_mapper_list, &eg_mapper_list);
    tunnel_api->create_tunnel(&tunnel_id, 0, attr_count, attr_list);
    free(attr_list);
    if (ing_mapper_list) free(ing_mapper_list);
    if (eg_mapper_list) free(eg_mapper_list);
    return tunnel_id;
  }

  sai_thrift_status_t sai_thrift_remove_tunnel(
      const sai_thrift_object_id_t tunnel_id) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = tunnel_api->remove_tunnel((sai_object_id_t)tunnel_id);
    return status;
  }

  void sai_thrift_get_tunnel(
      std::vector<sai_thrift_attribute_t> &thrift_attr_values,
      const sai_thrift_object_id_t tunnel_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    return;
  }

  sai_thrift_status_t sai_thrift_set_tunnel(
      const sai_thrift_object_id_t tunnel_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    return status;
  }

  sai_thrift_object_id_t sai_thrift_create_tunnel_term(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    sai_object_id_t tunnel_term_id = 0;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }
    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return SAI_NULL_OBJECT_ID;
    }
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_tunnel_term_attributes(thrift_attr_list, attr_list);
    tunnel_api->create_tunnel_term_table_entry(
        &tunnel_term_id, 0, attr_count, attr_list);
    free(attr_list);
    return tunnel_term_id;
  }

  sai_thrift_status_t sai_thrift_remove_tunnel_term(
      const sai_thrift_object_id_t tunnel_term_id) {
    SAI_THRIFT_FUNC_LOG();
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    status = tunnel_api->remove_tunnel_term_table_entry(
        (sai_object_id_t)tunnel_term_id);
    return status;
  }

  void sai_thrift_get_tunnel_term(
      std::vector<sai_thrift_attribute_t> &thrift_attr_values,
      const sai_thrift_object_id_t tunnel_term_id,
      const std::vector<int32_t> &thrift_attr_ids) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }
    return;
  }

  sai_thrift_status_t sai_thrift_set_tunnel_term(
      const sai_thrift_object_id_t tunnel_term_id,
      const sai_thrift_attribute_t &thrift_attr) {
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_tunnel_api_t *tunnel_api = NULL;
    status = sai_api_query(SAI_API_TUNNEL, (void **)&tunnel_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }
    return status;
  }

  sai_thrift_status_t sai_thrift_set_lag_attribute(
      const sai_thrift_object_id_t lag_id,
      const sai_thrift_attribute_t &thrift_attr) {
    printf("sai_thrift_set_lag\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_port_api_t *lag_api;
    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return status;
    }

    std::vector<sai_thrift_attribute_t> thrift_attr_list;
    thrift_attr_list.push_back(thrift_attr);
    sai_attribute_t attr;

    sai_thrift_parse_lag_attributes(thrift_attr_list, &attr);
    status = lag_api->set_port_attribute((sai_object_id_t)lag_id, &attr);
    if (status != SAI_STATUS_SUCCESS) {
      SAI_THRIFT_LOG_ERR("Failed to set lag attributes.");
    }
    return status;
  }

  void sai_thrift_get_lag_attribute(
      sai_thrift_attribute_list_t &thrift_attr_list,
      const sai_thrift_object_id_t lag_id) {
    printf("sai_thrift_get_lag_attribute\n");
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_lag_api_t *lag_api;
    std::vector<sai_thrift_attribute_t> &attr_list = thrift_attr_list.attr_list;

    status = sai_api_query(SAI_API_LAG, (void **)&lag_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    /* get SAI_LAG_ATTR_DROP_UNTAGGED attribute */
    sai_attribute_t drop_untagged_packet_attribute;
    sai_thrift_attribute_t thrift_drop_untagged;
    thrift_attr_list.attr_count = 1;
    drop_untagged_packet_attribute.id = SAI_LAG_ATTR_DROP_UNTAGGED;
    lag_api->get_lag_attribute(lag_id, 1, &drop_untagged_packet_attribute);
    thrift_drop_untagged.id = SAI_LAG_ATTR_DROP_UNTAGGED;
    thrift_drop_untagged.value.booldata =
        drop_untagged_packet_attribute.value.booldata;
    attr_list.push_back(thrift_drop_untagged);

    /* get SAI_LAG_ATTR_DROP_TAGGED attribute */
    sai_attribute_t drop_tagged_packet_attribute;
    sai_thrift_attribute_t thrift_drop_tagged;
    thrift_attr_list.attr_count = 2;
    drop_tagged_packet_attribute.id = SAI_LAG_ATTR_DROP_TAGGED;
    lag_api->get_lag_attribute(lag_id, 1, &drop_tagged_packet_attribute);
    thrift_drop_tagged.id = SAI_LAG_ATTR_DROP_TAGGED;
    thrift_drop_tagged.value.booldata =
        drop_tagged_packet_attribute.value.booldata;
    attr_list.push_back(thrift_drop_tagged);

    /* get SAI_LAG_ATTR_PORT_VLAN_ID attribute */
    sai_attribute_t port_vlan_id_attribute;
    sai_thrift_attribute_t thrift_port_vlan_id;
    thrift_attr_list.attr_count = 3;
    port_vlan_id_attribute.id = SAI_LAG_ATTR_PORT_VLAN_ID;
    lag_api->get_lag_attribute(lag_id, 1, &port_vlan_id_attribute);
    thrift_port_vlan_id.id = SAI_LAG_ATTR_PORT_VLAN_ID;
    thrift_port_vlan_id.value.u16 = port_vlan_id_attribute.value.u16;
    attr_list.push_back(thrift_port_vlan_id);
  }

  void sai_thrift_parse_nat_entry(
      const sai_thrift_nat_entry_t &thrift_nat_entry,
      sai_nat_entry_t &nat_entry) {
    if (thrift_nat_entry.nat_type == SAI_NAT_TYPE_SOURCE_NAT ||
        thrift_nat_entry.nat_type == SAI_NAT_TYPE_DOUBLE_NAT) {
      sai_thrift_string_to_v4_ip(thrift_nat_entry.sip,
                                 &nat_entry.data.key.src_ip);
      nat_entry.data.key.l4_src_port = thrift_nat_entry.l4_src_port;
    }

    if (thrift_nat_entry.nat_type == SAI_NAT_TYPE_DESTINATION_NAT ||
        thrift_nat_entry.nat_type == SAI_NAT_TYPE_DOUBLE_NAT ||
        thrift_nat_entry.nat_type == SAI_NAT_TYPE_DESTINATION_NAT_POOL) {
      sai_thrift_string_to_v4_ip(thrift_nat_entry.dip,
                                 &nat_entry.data.key.dst_ip);
      nat_entry.data.key.l4_dst_port = thrift_nat_entry.l4_dst_port;
    }
    nat_entry.data.key.proto = thrift_nat_entry.ip_proto;
    nat_entry.nat_type = (sai_nat_type_t)thrift_nat_entry.nat_type;
  }

  void sai_thrift_parse_nat_entry_attributes(
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list,
      sai_attribute_t *attr_list) {
    std::vector<sai_thrift_attribute_t>::const_iterator it =
        thrift_attr_list.begin();
    sai_thrift_attribute_t attribute;
    for (uint32_t i = 0; i < thrift_attr_list.size(); i++, it++) {
      attribute = (sai_thrift_attribute_t)*it;
      attr_list[i].id = attribute.id;
      switch (attribute.id) {
        case SAI_NAT_ENTRY_ATTR_NAT_TYPE:
          attr_list[i].value.u32 = attribute.value.u32;
          break;
        case SAI_NAT_ENTRY_ATTR_SRC_IP:
        case SAI_NAT_ENTRY_ATTR_DST_IP:
          sai_thrift_string_to_v4_ip(attribute.value.ip4,
                                     &attr_list[i].value.ip4);
          break;
        case SAI_NAT_ENTRY_ATTR_L4_SRC_PORT:
        case SAI_NAT_ENTRY_ATTR_L4_DST_PORT:
          attr_list[i].value.u16 = attribute.value.u16;
          break;
        default:
          break;
      }
    }
  }

  sai_thrift_status_t sai_thrift_create_nat_entry(
      const sai_thrift_nat_entry_t &thrift_nat_entry,
      const std::vector<sai_thrift_attribute_t> &thrift_attr_list) {
    sai_nat_api_t *nat_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t nat_entry;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }

    uint32_t attr_count = thrift_attr_list.size();
    if (attr_count == 0) {
      return status;
    }

    memset(&nat_entry, 0, sizeof(nat_entry));
    sai_thrift_parse_nat_entry(thrift_nat_entry, nat_entry);
    sai_attribute_t *attr_list =
        (sai_attribute_t *)malloc(sizeof(sai_attribute_t) * attr_count);
    sai_thrift_parse_nat_entry_attributes(thrift_attr_list, attr_list);
    status = nat_api->create_nat_entry(&nat_entry, attr_count, attr_list);
    free(attr_list);
    return status;
  }

  sai_thrift_status_t sai_thrift_delete_nat_entry(
      const sai_thrift_nat_entry_t &thrift_nat_entry) {
    sai_nat_api_t *nat_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t nat_entry;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      return SAI_NULL_OBJECT_ID;
    }

    memset(&nat_entry, 0, sizeof(nat_entry));
    sai_thrift_parse_nat_entry(thrift_nat_entry, nat_entry);
    status = nat_api->remove_nat_entry(&nat_entry);
    return status;
  }

  void sai_thrift_get_nat_entry_attribute(
      sai_thrift_attribute_t &thrift_attr,
      const sai_thrift_nat_entry_t &thrift_nat_entry,
      const sai_thrift_attribute_t &nat_thrift_attr) {
    sai_nat_api_t *nat_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t nat_entry;
    sai_attribute_t sai_attr;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    memset(&nat_entry, 0, sizeof(nat_entry));
    sai_thrift_parse_nat_entry(thrift_nat_entry, nat_entry);
    sai_attr.id = nat_thrift_attr.id;
    status = nat_api->get_nat_entry_attribute(&nat_entry, 1, &sai_attr);
    if (sai_attr.id == SAI_NAT_ENTRY_ATTR_HIT_BIT) {
      thrift_attr.value.booldata = sai_attr.value.booldata;
    }
    if (sai_attr.id == SAI_NAT_ENTRY_ATTR_PACKET_COUNT ||
        sai_attr.id == SAI_NAT_ENTRY_ATTR_BYTE_COUNT) {
      thrift_attr.value.u64 = sai_attr.value.u64;
    }
    return;
  }
  void sai_thrift_set_nat_entry_attribute(
      const sai_thrift_nat_entry_t &thrift_nat_entry,
      const sai_thrift_attribute_t &nat_thrift_attr) {
    sai_nat_api_t *nat_api;
    sai_status_t status = SAI_STATUS_SUCCESS;
    sai_nat_entry_t nat_entry;
    sai_attribute_t sai_attr;

    status = sai_api_query(SAI_API_NAT, (void **)&nat_api);
    if (status != SAI_STATUS_SUCCESS) {
      return;
    }

    memset(&nat_entry, 0, sizeof(nat_entry));
    sai_thrift_parse_nat_entry(thrift_nat_entry, nat_entry);
    sai_attr.id = nat_thrift_attr.id;
    status = nat_api->set_nat_entry_attribute(&nat_entry, &sai_attr);
  }

  int32_t sai_thrift_is_feature_enable(const sai_thrift_feature_id_t feature) {
    switch_feature_id_t switch_feature = (switch_feature_id_t)feature;
    if (::bf_switch::bf_switch_is_feature_enabled(switch_feature) == true) {
      return 1;
    }
    return 0;
  }
};

static void *switch_sai_thrift_rpc_server_thread(void *arg) {
  int port = *(int *)arg;
  std::shared_ptr<switch_sai_rpcHandler> handler(new switch_sai_rpcHandler());
  std::shared_ptr<TProcessor> processor(new switch_sai_rpcProcessor(handler));
  std::shared_ptr<TServerTransport> serverTransport(new TServerSocket(port));
  std::shared_ptr<TTransportFactory> transportFactory(
      new TBufferedTransportFactory());
  std::shared_ptr<TProtocolFactory> protocolFactory(
      new TBinaryProtocolFactory());

  TSimpleServer server(
      processor, serverTransport, transportFactory, protocolFactory);
  pthread_mutex_lock(&cookie_mutex);
  cookie = (void *)processor.get();
  pthread_cond_signal(&cookie_cv);
  pthread_mutex_unlock(&cookie_mutex);
  server.serve();
  return 0;
}

static pthread_t switch_sai_thrift_rpc_thread;
static pthread_t switch_sonic_sai_thrift_rpc_thread;

extern "C" {

int start_sai_thrift_rpc_server(int port) {
  std::cerr << "Starting SAI RPC server on port " << port << std::endl;

  cookie = NULL;
  pthread_cond_init(&cookie_cv, NULL);
  int status = pthread_create(&switch_sonic_sai_thrift_rpc_thread,
                              NULL,
                              switch_sai_thrift_rpc_server_thread,
                              &port);
  if (status) return status;
  pthread_mutex_lock(&cookie_mutex);
  while (!cookie) {
    pthread_cond_wait(&cookie_cv, &cookie_mutex);
  }
  pthread_mutex_unlock(&cookie_mutex);
  pthread_mutex_destroy(&cookie_mutex);
  pthread_cond_destroy(&cookie_cv);
  return status;
}

int start_p4_sai_thrift_rpc_server_v1(char *port) {
  int num_ports = 32;
  char veth_str[10];
  static int *param = (int *)malloc(sizeof(int));
  *param = atoi(port);

  std::cerr << "Starting SAI RPC server on port " << port << std::endl;

  std::set<int> lanes;
  for (uint16_t index = 0; index < num_ports; index++) {
    sprintf(veth_str, "Veth%d", index * 2 + 1);
    lanes.insert(static_cast<int>(index));
    gPortMap.insert(std::pair<std::set<int>, std::string>(lanes, veth_str));
    memset(veth_str, 0x0, sizeof(veth_str));
    lanes.clear();
  }

  sai_switch_api_t *switch_api;
  sai_attribute_t attr;
  if (sai_api_query(SAI_API_SWITCH, (void **)&switch_api) !=
      SAI_STATUS_SUCCESS) {
    std::cerr << "failed sai api query" << std::endl;
    return -1;
  }
  if (switch_api->create_switch(&gSwitchId, 0, &attr) != SAI_STATUS_SUCCESS) {
    std::cerr << "failed sai api query" << std::endl;
    return -1;
  }

  attr.id = SAI_SWITCH_ATTR_DEFAULT_VLAN_ID;
  cookie = NULL;
  int status = pthread_create(&switch_sai_thrift_rpc_thread,
                              NULL,
                              switch_sai_thrift_rpc_server_thread,
                              param);
  if (status) return status;
  pthread_mutex_lock(&cookie_mutex);
  while (!cookie) {
    pthread_cond_wait(&cookie_cv, &cookie_mutex);
  }
  pthread_mutex_unlock(&cookie_mutex);
  pthread_mutex_destroy(&cookie_mutex);
  pthread_cond_destroy(&cookie_cv);
  return status;
}

int stop_sai_thrift_rpc_server(void) {
  int status = pthread_cancel(switch_sonic_sai_thrift_rpc_thread);
  if (status == 0) {
    int s = pthread_join(switch_sonic_sai_thrift_rpc_thread, NULL);
    if (s) return s;
  }
  return status;
}

int stop_p4_sai_thrift_rpc_server_v1(void) {
  int status = pthread_cancel(switch_sai_thrift_rpc_thread);
  if (status == 0) {
    int s = pthread_join(switch_sai_thrift_rpc_thread, NULL);
    if (s) return s;
  }
  return status;
}
}
